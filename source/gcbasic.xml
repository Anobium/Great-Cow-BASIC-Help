<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Great Cow BASIC documentation</title>
<date>2017-08-22</date>
<author>
<personname>
<firstname>The Great Cow BASIC development team @ 2017</firstname>
</personname>
</author>
<authorinitials>T</authorinitials>
</info>
<section xml:id="_introducing_great_cow_basic">
<title>Introducing Great Cow BASIC</title>
<simpara>Hello, and welcome to Great Cow BASIC help. This help file is intended
to provide you insights and knowledge to use Great Cow BASIC.</simpara>
<simpara>For information on installing Great Cow BASIC and several other programs that
may be helpful, please see
<link xlink:href="http://gcbasic.sourceforge.net/starting.html">Getting Started with Great Cow BASIC</link>.</simpara>
<simpara>If you are new to programming, you should try the Great Cow BASIC
demonstration programs these explains everything in a step-by-step manner, and assumes
no prior knowledge.</simpara>
<simpara>If you have programmed in another language, then the demonstration files
and this command reference may be the best place to turn.</simpara>
<simpara>If there is anything else that you need help on, please visit the
<link xlink:href="http://sourceforge.net/forum/?group_id=169286">Great Cow BASIC forum</link>.</simpara>
</section>
<section xml:id="_using_great_cow_basic">
<title>Using Great Cow BASIC</title>
<simpara>Need to compile a program with Great Cow BASIC, but don&#8217;t know where to begin? Try these simple instructions:
<?asciidoc-br?>
<?asciidoc-br?>
 - Complete the installation using the default values - select all the programmers but not the portable mode.
<?asciidoc-br?>
<?asciidoc-br?>
 - The installer will automatically start the IDE.
<?asciidoc-br?>
<?asciidoc-br?>
 - When a Great Cow BASIC sourcefile is opened, check out the IDE Tools menu - through this menu you can access the oneclick commands.
 Try right mousebutton - this will access the same options.
<?asciidoc-br?>
<?asciidoc-br?>
 - The IDE Tools&#8230;&#8203; commands (function keys F5 - F8) starts a Great Cow BASIC utility which calls the batchfiles for compiling sourcecode and programming
   ("flashing")<phrase role="small"><superscript>(1)</superscript></phrase> the target microcontroller.   By default these batchfiles are called flashAVR.bat (when the chipmodel is an AVR) and flashPIC.bat (when the chipmodel is a PIC) and a batch file to create and program your microcontroller called makeHEX.bat.  The chipmodel is autodetected by the IDE.
<?asciidoc-br?>
<?asciidoc-br?>
 - By editing these batchfiles you can configure the programmer software for
   your own needs. All the programmers are located in the G+Stools subfolder.
<?asciidoc-br?>
<?asciidoc-br?>
 - If there is a batchfile "FlashThis.bat" present in the same folder as
   the sourcefile, this batchfile is used for flashing. This may be useful
   for project-specific flashing.
<?asciidoc-br?>
<?asciidoc-br?>
   - Included programmer software is:
<?asciidoc-br?>
   &#8201;&#8212;&#8201;Avrdude for AVR,
<?asciidoc-br?>
   &#8201;&#8212;&#8201;PICPgm for PIC,
<?asciidoc-br?>
   &#8201;&#8212;&#8201;PicKit2 and PicKit3
<?asciidoc-br?>
   &#8201;&#8212;&#8201;TinyBootLoader+
<?asciidoc-br?>
   &#8201;&#8212;&#8201;Microchip Xpress Board and many, many more.</simpara>
<simpara><phrase role="small"><superscript>(1)</superscript> You need a suitable programmer to do this, and instructions should be
included with the programmer on how to download to the microcontroller.</phrase></simpara>
</section>
<section xml:id="_changes">
<title>Changes</title>
<simpara><emphasis role="strong">Formal Release of &lt;&gt;</emphasis></simpara>
<simpara><?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="60%"?>
<?dbfo table-width="60%"?>
<?dblatex table-width="60%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="128*"/>
<colspec colname="col_2" colwidth="128*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Reference</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Time Stamp</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>ASCIIDOCs rendered</simpara></entry>
<entry align="center" valign="top"><simpara>2017-09-01<?asciidoc-br?>
12:36:30 GMT Daylight Time</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>Master ToC information</simpara></entry>
<entry align="center" valign="top"><simpara>2017-08-22<?asciidoc-br?>
08:43:17 GMT Daylight Time</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?></simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">Updates to HELP are as follows</emphasis></term>
<listitem>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.98.00</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Updated #define USART_TX_BLOCKING examples</simpara>
</listitem>
<listitem>
<simpara>Updated Conditions page with the known constraints of using functions as test conditions</simpara>
</listitem>
<listitem>
<simpara>Updated SPI section, adding FastHWSPITransfer method</simpara>
</listitem>
<listitem>
<simpara>Revised GLCD section to support SSD1306 128 * 32 pixels</simpara>
</listitem>
<listitem>
<simpara>Updated ADC section to support all three read options for ReadAD, ReadAD10 and ReadAD12</simpara>
</listitem>
<listitem>
<simpara>Updated Input/Output section to clarify AVR support.</simpara>
</listitem>
<listitem>
<simpara>Added ILI9341 GLCD section.</simpara>
</listitem>
<listitem>
<simpara>Added ILI9486L GLCD section.</simpara>
</listitem>
<listitem>
<simpara>Updated Lookup Table section.</simpara>
</listitem>
<listitem>
<simpara>Updated OtherDirectives section and added improved information on ChipFamily</simpara>
</listitem>
<listitem>
<simpara>Updated PWM section to reflect support for PWM3 and PWM4 channels.</simpara>
</listitem>
<listitem>
<simpara>Revised PWM section to improve information</simpara>
</listitem>
<listitem>
<simpara>Added HPWMUpdate section</simpara>
</listitem>
<listitem>
<simpara>Updated Subroutine section with 16f memory usage</simpara>
</listitem>
<listitem>
<simpara>Added 47xxx section with a new Memory sub-section</simpara>
</listitem>
<listitem>
<simpara>Added PWM for AVR section</simpara>
</listitem>
<listitem>
<simpara>Updated Other Directives section with the Chips information</simpara>
</listitem>
<listitem>
<simpara>Added SMT timer section</simpara>
</listitem>
<listitem>
<simpara>Updated maintenance section</simpara>
</listitem>
<listitem>
<simpara>Updated timer section, again</simpara>
</listitem>
<listitem>
<simpara>Updated PWM section to include AVR capabilities</simpara>
</listitem>
<listitem>
<simpara>Updated On Interrupt section - removing typos and adding more examples</simpara>
</listitem>
<listitem>
<simpara>Updated GCLD drivers to add color parameter</simpara>
</listitem>
<listitem>
<simpara>Added FVR section</simpara>
</listitem>
<listitem>
<simpara>Updated STR to include STR32, STRInteger and another example.</simpara>
</listitem>
<listitem>
<simpara>Updated VAL to include Val32 and another example.</simpara>
</listitem>
<listitem>
<simpara>Updated the GLCD section to include SSD1306 low memory configuration and table of the GLCD capabilities.</simpara>
</listitem>
<listitem>
<simpara>Updated the GLCD section to include SSD1306 and SH1106 low memory configuration and add examples</simpara>
</listitem>
<listitem>
<simpara>Added Ellipse and FilledEllipse</simpara>
</listitem>
<listitem>
<simpara>Added Triangle and FilledTriangle</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<variablelist>
<varlistentry>
<term><emphasis role="strong">Release 0.97.00</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>#Startup section revised to document latest changes to priority of startup subroutines</simpara>
</listitem>
<listitem>
<simpara>Added maintenance section</simpara>
</listitem>
<listitem>
<simpara>Revised inittimer 1,3,5 and 7 to reflect additional clock sources</simpara>
</listitem>
<listitem>
<simpara>Updated all PPS sections to reflect #startup as the recommended method</simpara>
</listitem>
<listitem>
<simpara>Revised Pulsein and added PulseInInv</simpara>
</listitem>
<listitem>
<simpara>Added PORTCHANGE to OnInterrupt section.</simpara>
</listitem>
<listitem>
<simpara>Updated compiler insights for TRISIO cache.</simpara>
</listitem>
<listitem>
<simpara>Updated HSerGetNum to support Longs and added an example.</simpara>
</listitem>
<listitem>
<simpara>Revised LCD_IO 2_74xx164 to add the link to the circuit diagram</simpara>
</listitem>
<listitem>
<simpara>Added output usage to <literal>other Directives</literal></simpara>
</listitem>
<listitem>
<simpara>Added SDD1306 support for SPI to GLCD section</simpara>
</listitem>
<listitem>
<simpara>Added GetUserID section</simpara>
</listitem>
<listitem>
<simpara>Added Software Serial (optimised) section
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.96.00</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised String usage and String examples to show use of quote marks within a string</simpara>
</listitem>
<listitem>
<simpara>Revised OtherDirectives to include missing constants</simpara>
</listitem>
<listitem>
<simpara>Added DisplaySegment and revised DisplayChar</simpara>
</listitem>
<listitem>
<simpara>Revised initimer2/4 and 6 to show revised prescalers</simpara>
</listitem>
<listitem>
<simpara>Restore Bitwise operations and SetWith to Help
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.010</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added improvements to SerSend and SerPrint</simpara>
</listitem>
<listitem>
<simpara>Revised 7 Segment Section to provide clarity, improve code and remove errors.</simpara>
</listitem>
<listitem>
<simpara>Revised CCP and PWM section to include need capabilities</simpara>
</listitem>
<listitem>
<simpara>Revised ADC section and add ADReadPreReadCommand constant
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.009</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added SH1106 GLCD driver
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.008</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Updated version number only.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.007a</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added #option explicit.</simpara>
</listitem>
<listitem>
<simpara>Added variable lifecycle explanation.</simpara>
</listitem>
<listitem>
<simpara>Revised and Improved PlayRTTTL section.</simpara>
</listitem>
<listitem>
<simpara>Revised Wait and SPIMode sections.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.007</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added new capabilities to support 16F1885x range of Microcontrollers.</simpara>
</listitem>
<listitem>
<simpara>New PMW commands - support for hardware PWM</simpara>
</listitem>
<listitem>
<simpara>New Initimer0 option to support 8bit and 16bit timer modules.</simpara>
</listitem>
<listitem>
<simpara>New constants available ChipADC and ChipIO.</simpara>
</listitem>
<listitem>
<simpara>New commands to support PPS.  LOCKPPS and UNLOCKPPS.</simpara>
</listitem>
<listitem>
<simpara>Added I2CStartoccurred command. Missing from Help.</simpara>
</listitem>
<listitem>
<simpara>Additional information for Scripts.</simpara>
</listitem>
<listitem>
<simpara>General removal of typos in Help files.</simpara>
</listitem>
<listitem>
<simpara>Updated FnLSL section removing error.</simpara>
</listitem>
<listitem>
<simpara>Removal of SetWith, FnEQUBit and FnNOTBit should now be replaced by built-in compiler operations.
Bits are now correctly handled by built-in Not operator.</simpara>
</listitem>
<listitem>
<simpara>New command #option volatile.  Sensitive pins can be marked as volatile, and native assignment operators will set without glitching, replacing SetWith.</simpara>
</listitem>
<listitem>
<simpara>Added new sections on ADC and PWM code optimisation</simpara>
</listitem>
<listitem>
<simpara>Added new I2C command for software I2C - use_i2c_timeout
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.006</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Completed rewrite of the Help File.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>New Help File in PDF.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>New Help File in XML.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>New Help File in HTML5.<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>New Help File in HTML for Web.</simpara>
</listitem>
<listitem>
<simpara>Revised Linux section</simpara>
</listitem>
<listitem>
<simpara>Revised SPIMode section
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.005a</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised RS232 Hardware section to improve readability
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.005</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added LeftPad
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95.004</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Updated HSerial commands to support AVR 1, 2, 3 and 4.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.95</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added weak pullup command set</simpara>
</listitem>
<listitem>
<simpara>Added RAM usage when defining Array</simpara>
</listitem>
<listitem>
<simpara>Added new method to use a Constant to define an Array</simpara>
</listitem>
<listitem>
<simpara>Added information on how to set address on mjkdz I2C LCD 1602 Modules</simpara>
</listitem>
<listitem>
<simpara>Added new constants ChipWords and ChipEEPROM</simpara>
</listitem>
<listitem>
<simpara>Added new Table definition method</simpara>
</listitem>
<listitem>
<simpara>Added new capabilities to Lookup Tables</simpara>
</listitem>
<listitem>
<simpara>Added new capability to READAD for AVR microcomputers</simpara>
</listitem>
<listitem>
<simpara>Added instructions to compile Great Cow BASIC under Linux</simpara>
</listitem>
<listitem>
<simpara>Added new command to invert an KS0108 GLCD display</simpara>
</listitem>
<listitem>
<simpara>Added new example code - FLASH_LED</simpara>
</listitem>
<listitem>
<simpara>Added how to set chip speed to non standard speeds</simpara>
</listitem>
<listitem>
<simpara>Added new command parameter to hardware USART command set</simpara>
</listitem>
<listitem>
<simpara>Added new command set for second hardware I2C port. The HI2C2 command set</simpara>
</listitem>
<listitem>
<simpara>Added new command set for second USART port</simpara>
</listitem>
<listitem>
<simpara>Added new ILI9340 GLCD driver command set</simpara>
</listitem>
<listitem>
<simpara>Added SDD1289 GLCD driver command set</simpara>
</listitem>
<listitem>
<simpara>Added example code<?asciidoc-br?>
Measuring Pulse Width To Sub-Microsecond Resolution<?asciidoc-br?>
Generating Accurate Pulses using a Macro<?asciidoc-br?>
How to pass a Port address to routine using a Macro</simpara>
</listitem>
<listitem>
<simpara>Added .NET support section</simpara>
</listitem>
<listitem>
<simpara>Revised SPIMode command parameters</simpara>
</listitem>
<listitem>
<simpara>Added #option NoContextSave</simpara>
</listitem>
<listitem>
<simpara>Added On Intterupt: The default handler</simpara>
</listitem>
<listitem>
<simpara>Added new sub-section Compiler Options, moved options from Compiler Directives</simpara>
</listitem>
<listitem>
<simpara>Added new fonts support for GLCD</simpara>
</listitem>
<listitem>
<simpara>Added new color support for GLCD</simpara>
</listitem>
<listitem>
<simpara>Added LCD_IO_1 and changes LCD_IO_2 to support 74xx164 and 74xx174</simpara>
</listitem>
<listitem>
<simpara>Revised most of the Timer section to support correct information.</simpara>
</listitem>
<listitem>
<simpara>Added ADS7843 Touch Screen Controller support</simpara>
</listitem>
<listitem>
<simpara>Added Play and PlayRTTL command set</simpara>
</listitem>
<listitem>
<simpara>Added DIFFerence command</simpara>
</listitem>
<listitem>
<simpara>Added three bitwise methods.  FnNotBit, FnLSL and FnLSR</simpara>
</listitem>
<listitem>
<simpara>Updated FAQ with 'how to set a bit'</simpara>
</listitem>
<listitem>
<simpara>Added bitwise method FnequBit</simpara>
</listitem>
<listitem>
<simpara>Added Timer6, Timer7, Timer8, Timer10 and Timer12 details to On Interrupt.</simpara>
</listitem>
<listitem>
<simpara>Added new On Interrupt Example</simpara>
</listitem>
<listitem>
<simpara>Added command line /WX</simpara>
</listitem>
<listitem>
<simpara>Added HI2CWaitMSSP and HI2CWaitMSSPTimeout to the Hardware I2C section.</simpara>
</listitem>
<listitem>
<simpara>Updated command line parameters</simpara>
</listitem>
<listitem>
<simpara>Added Fill command</simpara>
</listitem>
<listitem>
<simpara>Revised Arrays section</simpara>
</listitem>
<listitem>
<simpara>Added ReadAD12 command</simpara>
</listitem>
<listitem>
<simpara>Added divide and division explanation</simpara>
</listitem>
<listitem>
<simpara>Added Str32 and Val32</simpara>
</listitem>
<listitem>
<simpara>Added Support for USART2. HSerReceive1 and HSerReceive2</simpara>
</listitem>
<listitem>
<simpara>Added HSerRecieveFrom</simpara>
</listitem>
<listitem>
<simpara>Added HSerGetNum.HSertGetString</simpara>
</listitem>
<listitem>
<simpara>Added Single channel measurement mode and Differential Channel Measurement mode to ADC overview.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release 0.94b</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added HEFM support</simpara>
</listitem>
<listitem>
<simpara>Added SSD 1306 GLCD Driver support
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release v0.91</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added USART_TX_BLOCKING</simpara>
</listitem>
<listitem>
<simpara>Added LCD_SPEED</simpara>
</listitem>
<listitem>
<simpara>Improved LCD section
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release v0.9ho</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Updated parameter passing to Sub routines</simpara>
</listitem>
<listitem>
<simpara>New and revised LCD section to include LCD_IO 10 and 12</simpara>
</listitem>
<listitem>
<simpara>Remove of LAT where appropiate</simpara>
</listitem>
<listitem>
<simpara>LAT has been deprecated. The compiler will redirect all I/O pin writes
from PORTx to LATx registers on PIC 16F1/18F.</simpara>
</listitem>
<listitem>
<simpara>Use #option nolatch if problems occur.</simpara>
</listitem>
<listitem>
<simpara>ADFormat changed to deprecated.</simpara>
</listitem>
<listitem>
<simpara>Add default action to #CHIP when no frequency is specified.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release v0.9hm</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Correct errors in PWM section and improved examples.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Release v0.9hn</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Changes to Arrays. Number of elements is now limited to 10,000 for 12F
and 16F devices, or, the available RAM.</simpara>
</listitem>
<listitem>
<simpara>Lookup tables updated to reflect new methods of populating tables.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>a single value on each line</simpara>
</listitem>
<listitem>
<simpara>multiple elements on a single line separated by commas</simpara>
</listitem>
<listitem>
<simpara>constants and calculations within the single line data table entries
are permitted</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Repeat loop changed to support EXIT REPEAT</simpara>
</listitem>
<listitem>
<simpara>New Pad command. The Pad method is used to create string to a specific
length that is extended with a specific character</simpara>
</listitem>
<listitem>
<simpara>Added DS18B20 command set.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">v0.9hm</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Updated I2C - software and hardware. Demonstration code now uses Chipino
demonstration board. Changed to Serial I2C section with these new
examples.</simpara>
</listitem>
<listitem>
<simpara>New Functional Commands:<?asciidoc-br?>
<literal>LCDDisplayOn</literal><?asciidoc-br?>
<literal>LCDDisplayOff</literal><?asciidoc-br?>
<literal>LCDBackLight ( On | Off )</literal></simpara>
</listitem>
<listitem>
<simpara>New Defines to support LCD functionality are:<?asciidoc-br?>
<literal>LCD_SPEED FAST</literal><?asciidoc-br?>
<literal>LCD_SPEED MEDIUM</literal><?asciidoc-br?>
<literal>LCD_SPEED SLOW</literal></simpara>
</listitem>
<listitem>
<simpara>Revised Functionality
LCDHex now supports printing of leading zeros when the HEX number is
less than 0x10. call LCDHex as follows to ensure leading zeros are
present.<?asciidoc-br?>
<literal>LCDHex byte_value, LeadingZeroActive ; parameter called LeadingZeroActive</literal></simpara>
</listitem>
<listitem>
<simpara>New support for GLCD PCD8544 devices.<?asciidoc-br?>
Changed GLCD section of the help to support the new device.<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">v0.9hl</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>HSERPRINTCLRF - Added parameter to repeat the number of CRLF sent.</simpara>
</listitem>
<listitem>
<simpara>Hardware I2C command set added. This is revised functionality to provide
support the MSSP module.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@0.9hk</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Help file updated to correct Power entry, it was in the incorrect
section. Moved to Maths section and other minors typos.</simpara>
</listitem>
<listitem>
<simpara>Correct Timer0 information. Revised to show constants and the timer code
was corrected.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hj</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>This information relates to the Hot Release 11 May 2014. Where
functionality is not supported by earlier versions of GCB please
upgrade. Some functions will not work in the earlier releases of Great
Cow Basic.</simpara>
</listitem>
<listitem>
<simpara>New Functional Commands<?asciidoc-br?>
<link linkend="_circle">Circle</link>. Draws a circle on the GLCD screen.<?asciidoc-br?>
<link linkend="_filledcircle">FilledCircle</link>. Fills a circle on the GLCD screen<?asciidoc-br?>
<link linkend="_logarithms">Log</link> function(s)<?asciidoc-br?>
<link linkend="_power">Power</link> function.</simpara>
</listitem>
<listitem>
<simpara>Revised Functional Commands<?asciidoc-br?>
<link linkend="_line">Line</link>. Now draws lines between any two points on the
GLCD display.<?asciidoc-br?>
<literal>#define GLCD_PROTECTOVERRUN</literal> . Controls drawing of circles to prevent
overdraw of the circle at display extremes.<?asciidoc-br?>
<literal>#define Line OldLine</literal>. Adding this define will revert to the old line
drawing routines. This has been added for backward compatibility.</simpara>
</listitem>
<listitem>
<simpara>Help File Revisions<?asciidoc-br?>
Added <link linkend="_pulsein">PulseIn</link><?asciidoc-br?>
Added <link linkend="_infrared_remote">IR_Remote</link> header example<?asciidoc-br?>
Added revised <link linkend="_graphical_lcd_demonstration">GLCD demonstration</link> example<?asciidoc-br?>
Added <link linkend="_rgb_led_control">RGB LED Control</link> example<?asciidoc-br?>
Added section to show inline documentation method, see
<link linkend="_code_documentation">Code Documentation</link>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@ v0.9hk</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Documented method for GCGB documentation.<?asciidoc-br?>
Added MATHS.H<?asciidoc-br?>
Added SQRT function.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@ v0.9hi</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Support for ST7735 documented. Functionality added to GLCD.h</simpara>
</listitem>
<listitem>
<simpara>Support for ST7920 Graphical LCD 128 * 64 device.</simpara>
</listitem>
<listitem>
<simpara>Revised GLCD section to include the one new and one undocumented device.</simpara>
</listitem>
<listitem>
<simpara>New GLCD commands for support of ST7920 GLCD<?asciidoc-br?>
<literal>ST7920GLCDEnableGraphics</literal><?asciidoc-br?>
<literal>ST7920GLCDDisableGraphics</literal><?asciidoc-br?>
<literal>ST7920GLCDClearGraphics</literal><?asciidoc-br?>
<literal>ST7920Locate</literal><?asciidoc-br?>
<literal>ST7920gTile</literal><?asciidoc-br?>
<literal>ST7920Tile</literal><?asciidoc-br?>
<literal>ST7920cTile</literal><?asciidoc-br?>
<literal>ST7920SetIcon</literal><?asciidoc-br?>
<literal>ST7920GraphicTest</literal><?asciidoc-br?>
<literal>ST7920LineHs</literal><?asciidoc-br?>
<literal>ST7920gLocate</literal><?asciidoc-br?>
<literal>ST7920lineh</literal><?asciidoc-br?>
<literal>ST7920linev</literal></simpara>
</listitem>
<listitem>
<simpara>Documented support for ST7735 GLCD.</simpara>
</listitem>
<listitem>
<simpara>Revise GLCD commands with backwards compatibility:<?asciidoc-br?>
<literal>GLCDCLS</literal><?asciidoc-br?>
<literal>GLCDPrint</literal> - supports LCD and GLCD modes<?asciidoc-br?>
<literal>GLCDDrawString</literal> - support for string handling<?asciidoc-br?>
<literal>GLCDDrawChar</literal> - Optional Colour<?asciidoc-br?>
<literal>Box</literal><?asciidoc-br?>
<literal>FilledBox</literal><?asciidoc-br?>
<literal>Line</literal><?asciidoc-br?>
<literal>PSet</literal><?asciidoc-br?>
<literal>GLCDReady</literal></simpara>
</listitem>
<listitem>
<simpara>InitGLCD, includes fix for startup routine for KS0108 devices<?asciidoc-br?>
Private ST7920 functions but can be used as needed..<?asciidoc-br?>
<literal>ST7920WriteCommand</literal><?asciidoc-br?>
<literal>ST7920WriteData</literal><?asciidoc-br?>
<literal>ST7920WriteByte</literal><?asciidoc-br?>
<literal>ST7920gReaddata</literal><?asciidoc-br?>
<literal>ST7920GLCDReadByte</literal><?asciidoc-br?>
<literal>GLCDTimeDelay</literal></simpara>
</listitem>
<listitem>
<simpara>Updated conditional test information.</simpara>
</listitem>
<listitem>
<simpara>Updated KeyPad information.</simpara>
</listitem>
<listitem>
<simpara>Updated Lookup table information.</simpara>
</listitem>
<listitem>
<simpara>Added Macro information.</simpara>
</listitem>
<listitem>
<simpara>Added new Trig maths section.</simpara>
</listitem>
<listitem>
<simpara>Added two new Circle examples</simpara>
</listitem>
<listitem>
<simpara>Added Other Directive information.</simpara>
</listitem>
<listitem>
<simpara>Added example programs</simpara>
</listitem>
<listitem>
<simpara>Mid Point Circles</simpara>
</listitem>
<listitem>
<simpara>Trigonometry Circles
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hg</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Corrected GLCD Common Anode display pages
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hf</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised 7 Segment section to support Common Cathode. Split 7 Segment
entry to show the two options available.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9he</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>New commands. Required post March 2014 LCD.h:<?asciidoc-br?>
<literal>LCDHOME</literal>,
<literal>LCDSPACE</literal>,
<literal>LCDCreateGraph</literal>,
<literal>LCDCursor</literal>,
<literal>LCDCmd</literal></simpara>
</listitem>
<listitem>
<simpara>Added Concatenation</simpara>
</listitem>
<listitem>
<simpara>Updated DisplayValue to show the support for HEX values. Required post
March 2014 7Segment.h</simpara>
</listitem>
<listitem>
<simpara>Updated GLCD example code to ensure the example compiled without
external files.</simpara>
</listitem>
<listitem>
<simpara>Added Trigonometry and the example application</simpara>
</listitem>
<listitem>
<simpara>Updated the LCD Overview to include the LATx support for higher clock
speed. Required post March 2014 LCD.h
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hd</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised Rotate to clarify type supported byte types.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hc Mar 2014</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised HSERPRINT to show Integers and Longs are supported and changed
the text to be correct.</simpara>
</listitem>
<listitem>
<simpara>Added HserPrintByteCRLF and HserPrintCRLF</simpara>
</listitem>
<listitem>
<simpara>Added Sine Table Example</simpara>
</listitem>
<listitem>
<simpara>Revised TABLE to show the limitation with respect to using WORDS when
placing TABLES in EEPROM
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hb Mar 2014</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added PulseOutInv</simpara>
</listitem>
<listitem>
<simpara>I2CRestart</simpara>
</listitem>
<listitem>
<simpara>Add new variants to use of Comments</simpara>
</listitem>
<listitem>
<simpara>Added Assembler Section
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Jan 14</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>New item(s):<?asciidoc-br?>
<literal>Len</literal>,
<literal>Asc</literal>,
<literal>Chr</literal>,
<literal>Trim</literal>,
<literal>Ltrim</literal>,
<literal>Rtrim</literal>,
<literal>Swap4</literal>,
<literal>Swap</literal>,
<literal>Abs</literal>,
<literal>Average</literal>,
<literal>Trim</literal>,
<literal>Ltrim</literal>,
<literal>Rtrim</literal>,
<literal>Wordtobin</literal>,
<literal>Bytetobin</literal>,
<literal>GLCD</literal>,
<literal>DectoBCD</literal>,
<literal>BCDtoDec</literal><?asciidoc-br?>
Using variables<?asciidoc-br?>
More on constants and variables<?asciidoc-br?>
Acknowledgements</simpara>
</listitem>
<listitem>
<simpara>Changes to:<?asciidoc-br?>
<literal>Str</literal>,
<literal>Hex</literal>,
<literal>Poke</literal>,
<literal>Else</literal>,
<literal>Readtable</literal>,
<literal>Exit</literal> (was exitsub)<?asciidoc-br?>
Command line parameters
Frequently asked questions</simpara>
</listitem>
<listitem>
<simpara>Fixed typos.</simpara>
</listitem>
<listitem>
<simpara>Updated REPEAT maximum repeat value.</simpara>
</listitem>
<listitem>
<simpara>Updated most pages for layout.<?asciidoc-br?>
Fixed links to external pages, again. This time downloaded as full html
pages, for POT and LC.<?asciidoc-br?>
Added LABEL, Bootloader and revise Select, add READAD10<?asciidoc-br?>
Fix Double SWAP
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hg</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Corrected GLCD Common Anode display pages
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hf</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised 7 Segment section to support Common Cathode. Split 7 Segment
entry to show the two options available.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9he</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>New commands. Required post March 2014 LCD.h:<?asciidoc-br?>
<literal>LCDHOME</literal>,
<literal>LCDSPACE</literal>,
<literal>LCDCreateGraph</literal>,
<literal>LCDCursor</literal>,
<literal>LCDCmd</literal></simpara>
</listitem>
<listitem>
<simpara>Added Concatenation</simpara>
</listitem>
<listitem>
<simpara>Updated DisplayValue to show the support for HEX values. Required post
March 2014 7Segment.h</simpara>
</listitem>
<listitem>
<simpara>Updated GLCD example code to ensure the example compiled without
external files.</simpara>
</listitem>
<listitem>
<simpara>Added Trigonometry and the example application</simpara>
</listitem>
<listitem>
<simpara>Updated the LCD Overview to include the LATx support for higher clock
speed. Required post March 2014 LCD.h
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hd</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised Rotate to clarify type supported byte types.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">@v0.9hc Mar 2014</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Revised HSERPRINT to show Integers and Longs are supported and changed
the text to be correct.</simpara>
</listitem>
<listitem>
<simpara>Added HserPrintByteCRLF and HserPrintCRLF</simpara>
</listitem>
<listitem>
<simpara>Added Sine Table Example</simpara>
</listitem>
<listitem>
<simpara>Revised TABLE to show the limitation with respect to using WORDS when
placing TABLES in EEPROM
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>@<emphasis role="strong">v0.9hb Mar 2014</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>Added PulseOutInv</simpara>
</listitem>
<listitem>
<simpara>I2CRestart</simpara>
</listitem>
<listitem>
<simpara>Add new variants to use of Comments</simpara>
</listitem>
<listitem>
<simpara>Added Assembler Section
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term><emphasis role="strong">Jan 14</emphasis></term>
<listitem>
<itemizedlist>
<listitem>
<simpara>New item(s):<?asciidoc-br?>
<literal>Len</literal>,
<literal>sc</literal>,
<literal>Chr</literal>,
<literal>Trim</literal>,
<literal>Ltrim</literal>,
<literal>Rtrim</literal>,
<literal>Swap4</literal>,
<literal>Swap</literal>,
<literal>Abs</literal>,
<literal>Average</literal>,
<literal>Trim</literal>,
<literal>Ltrim</literal>,
<literal>Rtrim</literal>,
<literal>Wordtobin</literal>,
<literal>Bytetobin</literal>,
<literal>GLCD</literal>,
<literal>DectoBCD</literal>,
<literal>BCDtoDec</literal><?asciidoc-br?>
Using variables<?asciidoc-br?>
More on constants and variables<?asciidoc-br?>
Acknowledgements</simpara>
</listitem>
<listitem>
<simpara>Changes to:<?asciidoc-br?>
<literal>Str</literal>,
<literal>Hex</literal>,
<literal>Poke</literal>,
<literal>Else</literal>,
<literal>Readtable</literal>,
<literal>Exit</literal> (was exitsub)<?asciidoc-br?>
Command line parameters
Frequently asked questions</simpara>
</listitem>
<listitem>
<simpara>Fixed typos.</simpara>
</listitem>
<listitem>
<simpara>Updated REPEAT maximum repeat value.</simpara>
</listitem>
<listitem>
<simpara>Updated most pages for layout.<?asciidoc-br?>
Fixed links to external pages, again. This time downloaded as full html
pages, for POT and LC.<?asciidoc-br?>
Added LABEL, Bootloader and revise Select, add READAD10<?asciidoc-br?>
Fix Double SWAP
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section xml:id="_command_line_parameters">
<title>Command Line Parameters</title>
<simpara><emphasis role="strong">About the Command Line Parameters</emphasis></simpara>
<screen>    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:\{C|A}] [/V] [/L] [/NP] <emphasis>filename</emphasis>

    GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/V] [/L] [/WX]  [/NP] <emphasis>filename</emphasis>

    GCBASIC /version</screen>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Switch</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>/O:<emphasis>filename</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the name of the assembly file generated to <literal><emphasis>filename</emphasis></literal>.</simpara></entry>
<entry align="left" valign="top"><simpara>Same name as the input file, but with a <literal>.asm</literal> extension.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/A:assembler</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Batch file used to call assembler<superscript>(1)</superscript>. If <literal>/A:GCASM</literal> is given, Great Cow BASIC will use its internal assembler.</simpara></entry>
<entry align="left" valign="top"><simpara>The program will not be assembled</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/P:programmer</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Batch file used to call programmer<superscript>(1)</superscript>. This parameter is ignored if the program is not assembled.</simpara></entry>
<entry align="left" valign="top"><simpara>The program will not be downloaded.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/K:{C|A}</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Keep original code in assembly output. <literal>/K:C</literal> will save comments, <literal>/K:A</literal> will preserve all input code.</simpara></entry>
<entry align="left" valign="top"><simpara>No original code left in output.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/V</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Verbose mode - compiler gives more detailed information about its activities.</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/L</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Show license and exit.</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/NP</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Do not pause on errors. Use with IDEs.</simpara></entry>
<entry align="left" valign="top"><simpara>Pause when an error occurs, and wait for the user to press a key.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/WX</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Force compiler to ensure all include files are valid.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/version</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Shown build date and version of the compiler.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>/S</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Load the settings from a specified file, rather than use the defaults.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>filename</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The file to compile.</simpara></entry>
<entry align="left" valign="top"><simpara>-</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><phrase role="small"><superscript>(1)</superscript> For the <literal>/A:</literal> and <literal>/P:</literal> switches, there are special options available. If
<literal>%FILENAME%</literal> is present, it will be replaced by the name of the <literal>.asm</literal> file.
<literal>%FN_NOEXT%</literal> will be replaced by the name of the <literal>.asm</literal> file but without an
extension, and <literal>%CHIPMODEL%</literal> will be replaced with the name of the chip.
The name of the chip will be the same as that on the chip data file.</phrase></simpara>
<simpara>A batch file to load the <literal>ASM</literal> from Great Cow BASIC into <literal>MPASM</literal>. Command line should be like this:</simpara>
<screen>    C:\progra~1\microc~1\mpasms~1\MPASMWIN /c- /o- /q+ /l- /x- /w1 %code%.asm</screen>
<simpara>A batch file to compile in Great Cow BASIC then load the <literal>ASM</literal> from Great Cow BASIC into <literal>GPASM</literal>. Command line should be like this:</simpara>
<screen>    gcbasic.exe %1 /NP /K:A /A:"..\gputils\bin\gpasm.exe %~d1%~p1%~n1.asm"</screen>
<simpara>To instruct MAKEHEX.BAT to use <literal>GPASM</literal>.   You have GPUTILS installed.  The batch file should be edited as follows:</simpara>
<screen>    REM Create the ASM
    gcbasic.exe /NP /K:A %1
    REM Use GPASM piping to the GCB error log
    gpasm.exe "%~d1%~p1%~n1.asm" -k -i -w1 &gt;&gt; errors.txt</screen>
<simpara>To summarise, you can use any of the following:</simpara>
<screen>    gcbasic.exe filetocompile.gcb /A:GCASM /P:"icprog -L%FILENAME%" /V /O:compiled.asm</screen>
<simpara>Great Cow BASIC will compile the file, then assemble the program, and run this command:</simpara>
<screen>    `icprog -Lcompiled.hex`</screen>
<simpara>You can also create/edit the gcbasic.ini file :</simpara>
<screen>    'Assembler settings
    Assembler = C:\Program Files\Microchip\MPASM Suite\mpasmwin
    AssemblerParams = /c- /o- /q+ /l+ /x- /w1 "%FileName%"

    'Programmer settings
    Programmer = C:\Program Files\WinPic\Winpic.exe
    ProgrammerParams = /device=PIC%ChipModel% /p "%FileName%"</screen>
<simpara>This example will use MPASM to assemble the program. It will run the program specified in the assembler = line, and give it these parameters:</simpara>
<screen>    `/c- /o- /q+ /l+ /x- /w1 "compiled.asm"`</screen>
<simpara>Then, it will run the programmer, and give it these parameters when it calls it:</simpara>
<screen>    `/device=PIC16F88 /p "compiled.hex"`</screen>
<simpara><literal>%ChipModel%</literal> will get replaced with the chip you are using, so this the chip Great Cow BASIC will pass to WinPIC.</simpara>
</section>
<section xml:id="_frequently_asked_questions">
<title>Frequently Asked Questions</title>
<simpara><emphasis role="strong">Why doesn&#8217;t anything come up when I run GCBASIC.exe?</emphasis></simpara>
<simpara>Great Cow BASIC is a command line compiler. To compile a file, you can
drag and drop it onto the GCBASIC.exe icon. There are also several
Integrated Development Environments, or IDEs, available for Great Cow BASIC.
These will give you an area where you can edit your program and a button
to send the program to the chip. Several are listed on the Great Cow BASIC
website.</simpara>
<simpara><emphasis role="strong">What Microchip PIC and Atmel AVR microcontrollers does Great Cow BASIC support?</emphasis></simpara>
<simpara>Hopefully, all 8 bit Microchip PIC and Atmel AVR microcontrollers (those in the PIC10, PIC12, PIC16 and
PIC18 families). If you find one that Great Cow BASIC does not work with
properly, please post about it in the Compiler Problems section of the
Great Cow BASIC forum.</simpara>
<simpara><emphasis role="strong">Is Great Cow BASIC case sensitive?</emphasis></simpara>
<simpara>No! For example, <literal>Set</literal>, <literal>SET</literal>, <literal>set</literal>, <literal>SeT</literal>, etc are all treated exactly the
same way by Great Cow BASIC.</simpara>
<simpara><emphasis role="strong">Can I specify the bit of a variable to alter using another variable?</emphasis></simpara>
<simpara>Setting a  variable with other variable will expected. Great Cow BASIC support bitwise assignments. As follows:</simpara>
<screen>    portc.0 = !porta.1</screen>
<simpara>You can also use a shift function.  As in other languages, by using the Shift Function FnLSL.  AN example is:</simpara>
<screen>    MyVar = FnLSL( 1, BitNum)`  is Equivalent to `MyVar = 1&lt;&lt;BitNum`</screen>
<simpara>To set a bit of a port prevent glitches during the output update, use this method.</simpara>
<screen>    'add this option for a specific port.
    #option volatile portc.0

    'then in your code
    portc.0 = !porta.1</screen>
<simpara>You can use this method to set a bit of a port. Encapsulate it in the SetWith method, this also eliminates any glitches during the update, use this method.</simpara>
<screen>    SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))</screen>
<simpara>To clear a bit of a port, use this method.</simpara>
<screen>    MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))</screen>
<simpara>To set a bit within an array, use this method.</simpara>
<screen>    video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)</screen>
<simpara>See also  <link linkend="_set">Set</link>, <link linkend="_fnlsl">FnLSL</link>, <link linkend="_fnlsr">FnLSR</link> and <link linkend="_rotate">Rotate</link></simpara>
<simpara><emphasis role="strong">Why is x feature not implemented?</emphasis></simpara>
<simpara>Because it hasn&#8217;t been thought of, or no-one has been able to implement
it! If there are any features that you would like to see in Great Cow
BASIC, please post them in the "Open Discussion" section of the Great Cow BASIC
forum. Or, if you can, have a go at adding the feature yourself!</simpara>
<simpara><emphasis role="strong">When using an include file does this use lots of memory?</emphasis></simpara>
<simpara>When using include files, in this instance the &lt;ds3231.h&gt; include, if
you are not using all the functions of the include file, does GCB know
not to include the non used functions within the include file when
compiling, or does everything get included anyway. For instance, if I am
not using the hardware I2C, does all the code related to hardware I2C
still get compiled in the code?<?asciidoc-br?></simpara>
<simpara>Great Cow BASIC only compiles functions and subroutines if they are called.
Great Cow BASIC starts by compiling the main routine, then anything called from
there. Each time it finds a new subroutine that is called, it compiles
it and anything that it calls. If a subroutine is not needed, it does
not get compiled.</simpara>
<simpara><emphasis role="strong">My LCD will not operate as expected?</emphasis></simpara>
<simpara>Try adding. <literal>#define LCD_SPEED SLOW</literal></simpara>
<simpara>This will slow the writing to the LCD.</simpara>
<simpara><emphasis role="strong">Atmel AVR memory usage displayed is incorrect?</emphasis></simpara>
<simpara>Atmel AVR memory values are specified in WORDS in Great Cow BASIC. The Great Cow BASIC compiler uses words, not bytes, for consistency between Microchip PIC and Atmel AVR microcontrollers. This keeps parts of the compiler simpler.</simpara>
<simpara><emphasis role="strong">I cannot open the Window Help File?</emphasis></simpara>
<simpara>See <link xlink:href="http://digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0">http://digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0</link></simpara>
</section>
<section xml:id="_troubleshooting">
<title>Troubleshooting</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Problem</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Common Causes</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">More Assistance</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="middle" morerows="2"><simpara>Cannot compile a program</simpara></entry>
<entry align="left" valign="top"><simpara>There is an error in the program. Is Great Cow BASIC complaining about a
particular line of code?</simpara></entry>
<entry align="left" valign="top"><simpara>Great Cow BASIC Forums</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Great Cow BASIC has not been installed correctly - reinstall it.</simpara></entry>
<entry align="left" valign="top"><simpara>Great Cow BASIC Forums</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>There is a bug in Great Cow BASIC</simpara></entry>
<entry align="left" valign="top"><simpara>Post on the Great Cow BASIC Forums. Ensure you state the version of your compiler and attach your code as a ZIP.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>A program compiles and downloads fine, but will not run</simpara></entry>
<entry align="left" valign="top"><simpara>Oscillator not selected.</simpara></entry>
<entry align="left" valign="top"><simpara><link linkend="_configuration">Configuration</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_compiler_insights">
<title>Compiler Insights</title>
<simpara>This section will provide some insights into what the compiler does</simpara>
<simpara><emphasis role="strong">How does the compiler cope with read only registers in the Chip Family 12 range?</emphasis></simpara>
<simpara>Within this chip range the Option register is a write only register. Reading the register is not permitted.</simpara>
<simpara>Great Cow BASIC needs to update this when the user wants to change the configuration - the Sleep process is an example of a user change.</simpara>
<simpara>The compiler handles this by the creation of the Option_reg byte variable. This byte is created by the compiler to manage the required write process.</simpara>
<simpara>The Option_reg variable is a cache that compiler will create if any bits of option_reg have been set manually.</simpara>
<simpara>If the user changes any of the bits in a program, then the compiler will find any uses of the option instruction and insert a "movwf OPTION_REG" immediately before the option instruction to cache the value in the buffer.</simpara>
<simpara>If Option_reg bits aren&#8217;t set individually anywhere, then option_reg doesn&#8217;t get created, and nothing special is done with the option instruction.</simpara>
<simpara>Essentially the compiler maintains a special variable and manages the whole process without the user being aware.</simpara>
<simpara><emphasis role="strong">How does the compiler cope with the TRIS register in the 10f products?</emphasis></simpara>
<simpara>The compiler ensures that a TRIS cache matches the actual TRIS register.  The TRIS cache is a byte variable called TRISIO.  The TRISIO cache is required as TRIS is a write-only register.</simpara>
<simpara>All ports default to input ( where all TRIS bits to 1) on reset.  Therefore, this is assummed to be the value 255.</simpara>
<simpara>TRISIO is updated when required by the user code and then used in the writing to the correct register.</simpara>
<simpara>The example user code and the assiocated assembly shows TRISIO cache in use.  This method complies with datasheet.</simpara>
<simpara>User Code</simpara>
<literallayout class="monospaced">'set as input
dir gpio.0 in
gpio0State = gpio.0
'set as output this will require TRIS GPIO to be set using the TRISIO cache.
dir gpio.0 out
gpio.0 = 1</literallayout>
<simpara>ASM</simpara>
<literallayout class="monospaced">;dir gpio.0 in
  bsf    TRISIO,0
  movf    TRISIO,W
  tris    GPIO
;gpio0State = gpio.0
  clrf    GPIO0STATE
  btfsc    GPIO,0
  incf    GPIO0STATE,F
;dir gpio.0 out
  bcf    TRISIO,0
  movf    TRISIO,W
  tris    GPIO
;gpio.0 = 1
  bsf    GPIO,0</literallayout>
<simpara>Anywhere that an individual TRIS bit is set/cleared by change the port direction, the bit in the cache is changed and then that gets written to the TRIS register.</simpara>
</section>
<section xml:id="_libraries_overview">
<title>Libraries Overview</title>
<simpara><emphasis role="strong">About Libraries</emphasis></simpara>
<simpara>Great Cow BASIC (as with most other microcontroller programming languages) supports libraries.</simpara>
<simpara>You can create you own device specific library, you are not limited to those shown below.  If you create a new device specific library - please submit for inclusion in the next release via the Great Cow BASIC forum.</simpara>
<simpara>Maintenance of these libraries is completed by the Great Cow BASIC development team.  If you wish to adapt these libraries you should create a local copy, edit and save within your development file structure.  The development team may update these libraries as part of a release and we do not want you to lose your local changes.</simpara>
<simpara>To use a library, simple inlcude the following in your user code</simpara>
<screen>    #include &lt;3PI.H&gt;    'this will include the 3PI capabilities within your program</screen>
<simpara>To use a local copy of a library, simple inlcude the following in your user code</simpara>
<screen>    #include "C:\mydev\library\3pi.h"    'this will include a local copy of the the 3PI capabilities within your program</screen>
<simpara>Great Cow BASIC supports the following device libraries.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Library</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Class</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>3PI</simpara></entry>
<entry align="left" valign="top"><simpara>Polulu 3pi robot</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the switch and the motors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47XXX_EERAM.H</simpara></entry>
<entry align="left" valign="top"><simpara>I2C EERAM memory</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for the Microchip EERAM device classs</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ALPS-EC11</simpara></entry>
<entry align="left" valign="top"><simpara>Rotary Encoder</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for a rotary encoder.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843</simpara></entry>
<entry align="left" valign="top"><simpara>Touch Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces with the ADS7843 touch screen.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>CHIPINO</simpara></entry>
<entry align="left" valign="top"><simpara>Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the Chipino board with Arduino like port addresses.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DHT</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature and Humidity</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the DHT22 and the DHT11 Temperature and Humidity sensors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS1307</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS1672</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18B20</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS18S20</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS2482</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the I2C to Dallas OneWire functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DS3231</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>DUEMILANOVE</simpara></entry>
<entry align="left" valign="top"><simpara>Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the Duemilanove board with Arduino like port addresses.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EMC1001</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions and the other device capabilities.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FRAM</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Eeprom</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports memory functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GETUSERID</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip read ID</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the identification of Microchip microcontrollers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A core library for Graphical LCD support.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ILI9340</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ILI9341</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ILI9486L</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_IMAGESANDFONTS_ADDIN3</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A library to increase the capabilities of the Graphical LCDs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_KS0108</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_PCD8544</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_SH1106</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_SSD1289</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_SSD1306</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ST7735</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>GLCD_ST7920</simpara></entry>
<entry align="left" valign="top"><simpara>Graphical LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HEFLASH</simpara></entry>
<entry align="left" valign="top"><simpara>HEF Memory Driver</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the HEF memory functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HMC5883L</simpara></entry>
<entry align="left" valign="top"><simpara>Triple-axis Magnetometer</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the magnetometer functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C_ISR_HANDLER</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Slave Driver</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the use of a Microchip microcontroller as an I2C slave.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C_MESSAGEINTERFACE</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Slave</simpara></entry>
<entry align="left" valign="top"><simpara>A support library that supports the use of a Microchip microcontroller as an I2C slave.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2CEEPROM</simpara></entry>
<entry align="left" valign="top"><simpara>I2C EEProm memory</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports memory functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCD2SERIALREDIRECT</simpara></entry>
<entry align="left" valign="top"><simpara>LCD to Serial Handler</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the use of a serial and PC terminal as a psuedo LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LEGO-PF</simpara></entry>
<entry align="left" valign="top"><simpara>Lego Mindstorms shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the Lego Mindstorms robot</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LEGO</simpara></entry>
<entry align="left" valign="top"><simpara>Lego Mindstorms shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the Lego Mindstorms robot</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MATHS</simpara></entry>
<entry align="left" valign="top"><simpara>Maths routines</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports maths functions such as logs, power and atan.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MAX6675</simpara></entry>
<entry align="left" valign="top"><simpara>Temperature</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the temperature functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP23008</simpara></entry>
<entry align="left" valign="top"><simpara>i2C to serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the I2C to serial functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP23017</simpara></entry>
<entry align="left" valign="top"><simpara>i2C to serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the I2C to serial functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP4XXXDIGITALPOT</simpara></entry>
<entry align="left" valign="top"><simpara>Digital Pot</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MCPxxxx range of digital potentiometers.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MCP7940N</simpara></entry>
<entry align="left" valign="top"><simpara>Clock</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the timer clock and NVRAM functions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>NUNCHUCK</simpara></entry>
<entry align="left" valign="top"><simpara>Game controller</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the NunChuck game controller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PCF8574</simpara></entry>
<entry align="left" valign="top"><simpara>GLCD</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an Graphical LCD.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SD</simpara></entry>
<entry align="left" valign="top"><simpara>SD Card</simpara></entry>
<entry align="left" valign="top"><simpara>A device specific library for an SD Card.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIAL</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIALCH1</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIALCH2</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOFTSERIALCH3</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for software serial.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SONGLAY</simpara></entry>
<entry align="left" valign="top"><simpara>Music</simpara></entry>
<entry align="left" valign="top"><simpara>A library for play music. Supports QBASIC and RTTTL format.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SONYREMOTE</simpara></entry>
<entry align="left" valign="top"><simpara>Infrared</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the functions of a Sony remote control.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRF02</simpara></entry>
<entry align="left" valign="top"><simpara>Distance Sensor</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the SRF02 ultrasonic sensor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SRF04</simpara></entry>
<entry align="left" valign="top"><simpara>Distance Sensor</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the SRF04 ultrasonic sensor.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TEA5767</simpara></entry>
<entry align="left" valign="top"><simpara>I2C Radio</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the TEA5767 radio.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TRIG2PLACES</simpara></entry>
<entry align="left" valign="top"><simpara>Maths functions</simpara></entry>
<entry align="left" valign="top"><simpara>A maths library that supports trignometry to two places.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TRIG3PLACES</simpara></entry>
<entry align="left" valign="top"><simpara>Maths functions</simpara></entry>
<entry align="left" valign="top"><simpara>A maths library that supports trignometry to three places</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TRIG4PLACES</simpara></entry>
<entry align="left" valign="top"><simpara>Maths functions</simpara></entry>
<entry align="left" valign="top"><simpara>A maths library that supports trignometry to four places</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UNO_MEGA328P</simpara></entry>
<entry align="left" valign="top"><simpara>Shield</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the shield with Arduino like port addresses.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?></simpara>
<simpara><?asciidoc-br?>
Great Cow BASIC supports the following core libraries.   These libraries are automatically included in your user program therefore you do not need to use '#include' to access the libraries capabilities.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Library</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Class</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>7SEGMENT</simpara></entry>
<entry align="left" valign="top"><simpara>7 Segment LED display</simpara></entry>
<entry align="left" valign="top"><simpara>A library that interfaces the device.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>A-D</simpara></entry>
<entry align="left" valign="top"><simpara>Analog to Digital</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the ADC functionality.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EEPROM</simpara></entry>
<entry align="left" valign="top"><simpara>EEProm</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports I2C eeprom devices.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MSSP and TWI hardware modules of I2C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C2</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MSSP and TWI hardware modules of I2C on channel two</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWSPI</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the MSSP and TWI hardware modules of SPI</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports software I2C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>KEYPAD</simpara></entry>
<entry align="left" valign="top"><simpara>KeyPad</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports a keypad.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>HWI2C</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports keyboard functionality</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>LCD</simpara></entry>
<entry align="left" valign="top"><simpara>LCD</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports LCD functionality, library supports many different communications methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PWM</simpara></entry>
<entry align="left" valign="top"><simpara>Pulse Width Modulation</simpara></entry>
<entry align="left" valign="top"><simpara>A library supports PWM functionality.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RANDOM</simpara></entry>
<entry align="left" valign="top"><simpara>Random Numbers</simpara></entry>
<entry align="left" valign="top"><simpara>A library supports random number functionality.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>REMOTE</simpara></entry>
<entry align="left" valign="top"><simpara>Infrared</simpara></entry>
<entry align="left" valign="top"><simpara>A library that supports the functions of a NEC remote control.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>RS232</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>A library for serial communications.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SOUND</simpara></entry>
<entry align="left" valign="top"><simpara>Tones</simpara></entry>
<entry align="left" valign="top"><simpara>A library for sound and tone generation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>STDBASIC</simpara></entry>
<entry align="left" valign="top"><simpara>Utility Functions</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains many of the utility methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>STRING</simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the string methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SYSTEM</simpara></entry>
<entry align="left" valign="top"><simpara>System</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the system methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>TIMER</simpara></entry>
<entry align="left" valign="top"><simpara>Timers</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the timer methods.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>USART</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>The library that contains the hardware serial methods that use the MSSP or AVR equivilent hardware module.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_acknowledgements">
<title>Acknowledgements</title>
<simpara><emphasis role="strong">Developers and Contributors:</emphasis></simpara>
<simpara>Hugh Considine - Main developer of Great Cow BASIC</simpara>
<simpara>Stefano Bonomi - Two-wire LCD subroutines</simpara>
<simpara>Geordie Millar - Swap and Swap4 subroutines</simpara>
<simpara>Jacques Nilo - HEFM and help file conversion to asciidoc</simpara>
<simpara>Finn Stokes - 8-bit multiply routine, program memory access code</simpara>
<simpara>Evan Venn - Utilities, revised I2C routines, this help file and generally everything else!</simpara>
<simpara><emphasis role="strong">Translation Contributors:</emphasis></simpara>
<simpara>Stefano Delfiore - Italian</simpara>
<simpara>Pablo Curvelo - Spanish</simpara>
<simpara>Murat Inceer - Turkish</simpara>
<simpara><emphasis role="strong">Other Contributors:</emphasis></simpara>
<simpara>Russ Hensel - Great Cow BASIC Notes.</simpara>
<simpara>Chuck Hellebuyck - His documentation for the GLCD and other pieces, see <link xlink:href="http://www.elproducts.com">http://www.elproducts.com</link>.</simpara>
<simpara>Frank Steinberg - GCB@SYN IDE for Great Cow BASIC, see
<link xlink:href="http://sourceforge.net/projects/gcbasic/files/IDE/GCB%40Syn/GCB%40Syn.zip">http://sourceforge.net/projects/gcbasic/files/IDE/GCB%40Syn/GCB%40Syn.zip</link>.</simpara>
<simpara>Alexy T. - SynWrite IDE used for GCB IDE, see <link xlink:href="http://www.uvviewsoft.com/synwrite">http://www.uvviewsoft.com/synwrite</link>.</simpara>
<simpara>Thomas Henry for the Select Case and the Sine Table examples.</simpara>
<simpara>William Roth for the LCD code and supporting diagrams.</simpara>
<simpara>Theo Loermans for the revised LCD sections and the library.</simpara>
<simpara>Chris Roper for the bitwise methods including the library including FnEquBit, FnNotBit, FnlslBit, FnlsrBit, SetWith and 47xxx.</simpara>
<simpara><emphasis role="strong">Conversion of asciidoctor documentation files</emphasis>:</simpara>
<simpara>See the <link xlink:href="http://asciidoctor.org/">asciidoctor Web site</link> and the <link xlink:href="http://discuss.asciidoctor.org/">support forum</link>.</simpara>
</section>
<section xml:id="_microcontroller_fundamentals">
<title>Microcontroller Fundamentals</title>
<section xml:id="_inputs_outputs">
<title>Inputs/Outputs</title>
<simpara><emphasis role="strong">About Inputs and Outputs</emphasis></simpara>
<simpara>Most general purpose pins on a microcontroller can function in one of
two modes: input mode, or output mode.</simpara>
<simpara>When acting as an input, the general purpose input/output pin will be placed in a high impedance state.
The microcontroller will then sense the general purpose input/output pin, and the program can read
the state of the general purpose input/output pin and make decisions based on it.</simpara>
<simpara>When in output mode, the microcontroller will connect the general purpose input/output pin to either
Vcc (the positive supply), or Vss (ground, or the negative supply). The
program can then set the state of the general purpose input/output pin to either high or low.</simpara>
<simpara>Great Cow BASIC will attempt to determine the direction of each general purpose input/output pin, and set it
appropriately, when possible. Great Cow BASIC will try to set the direction of the general purpose input/output pin.
However, if the general purpose input/output pin is read from and written to in your program, then
the general purpose input/output pin must be configured to input or output mode by the program, using
the appropriate <link linkend="_dir">Dir</link> commands.</simpara>
<simpara>Example of <literal>dir</literal> commands.</simpara>
<screen>    'The port address is microcontroller specific.  Portx.x is a general case for PICs and AVRs
    dir portb.0 in
    dir portb.1 out

    'The port address is microcontroller specific.  gpiox.x is a general case for some PICs
    dir gpio.0 in
    dir gpio.1 Out

    'Set the whole port as an output
    dir portb out
    dir gpio out

    'Set the whole port as an input
    dir portc in
    dir gpio in</screen>
<simpara><emphasis role="strong">Microchip specifics for read/write operations</emphasis></simpara>
<simpara>For the specific ports and general purpose input/output pins available for a specific microcontroller please refer to the datasheet.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Port</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>PORTx maps to the microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</simpara></entry>
<entry align="left" valign="top"><simpara>Read:
</simpara><simpara>PORTx the port data register for a  read operation.</simpara></entry>
<entry align="left" valign="top"><simpara>uservar=PORTA
</simpara><simpara>uservar=PORTA.1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PORTx maps to microcontrollers digital pins 0 to 7. Where x can be a,b,c,d,e,f or g</simpara></entry>
<entry align="left" valign="top"><simpara>Write:
</simpara><simpara>PORTx the port data register for a  write operation, and, where LATx is not required as Great Cow BASIC will implement LATx when needed.
</simpara><simpara>See <link linkend="__option_nolatch">Option NoLatch</link> for more information on LAT registers and how to disable this automatic function.</simpara></entry>
<entry align="left" valign="top"><simpara>PORTA=255
</simpara><simpara>PORTA.1=1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To read a general purpose input/output pin, you need to ensure the direction is correct <literal>DIR Portx IN</literal> is set (default is IN) or a specific set of port bits.
Where <literal>uservar = PORTx.n</literal> can be used.</simpara>
<simpara>Examples:</simpara>
<screen>    uservar = PORTb.0
    uservar = PORTb</screen>
<simpara>To write to a general purpose input/output pin, you need to ensure the direction is correct <literal>DIR Portx OUT</literal> for port or a specific set of port bits.
Where  <literal>PORTx.n = uservar</literal> can be used.</simpara>
<simpara>Examples:</simpara>
<screen>    PORTb.0 = uservar
    PORTb = uservar</screen>
<simpara><emphasis role="strong">ATMEL specifics for read/write operations</emphasis></simpara>
<simpara>Using a Mega328p as a general the following provides insights for the AVR devices.  For the specific ports and general purpose input/output pins available for a specific microcontroller please refer to the datasheet.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Port</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Write operation</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Read operation</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>PORTD maps to Mega328p (and, the AVR microcontrollers) digital pins 0 to 7</simpara></entry>
<entry align="left" valign="top"><simpara>PORTD - The Port D Data Register - write operation  (a read operation to a port will provide the pull-up status)</simpara></entry>
<entry align="left" valign="top"><simpara>PIND - The Port D Input Pins Register - read only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PORTB maps to Mega328p (and, the AVR microcontrollers) digital pins 8 to 13. The two high bits (6 &amp; 7) map to the crystal pins and are not usable</simpara></entry>
<entry align="left" valign="top"><simpara>PORTB - The Port B Data Register - write operation  (a read operation to a port will provide the pull-up status)</simpara></entry>
<entry align="left" valign="top"><simpara>PINB - The Port B Input Pins Register - read only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PORTC maps to Mega328p (and, the AVR microcontrollers) analog pins 0 to 5. Pins 6 &amp; 7 are only accessible on the Mega328p (and, the AVR microcontrollers) Mini</simpara></entry>
<entry align="left" valign="top"><simpara>PORTC - The Port C Data Register - write operation (a read operation to a port will provide the pull-up status)</simpara></entry>
<entry align="left" valign="top"><simpara>PINC - The Port C Input Pins Register - read only</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To read a general purpose input/output pin, you need to ensure the direction is correct <literal>DIR Portx IN</literal> is set (default is IN) or a specific set of port bits.
Where <literal>uservar = PINx.n</literal> can be used and therefore to read data port use <literal>uservar = PINx</literal>.</simpara>
<simpara>Examples:</simpara>
<screen>    uservar = PINb.0
    uservar = PINb</screen>
<simpara>To write to a general purpose input/output pin you need to ensure the direction is correct <literal>DIR Portx OUT</literal> for port or a specific set of port bits.
Where <literal>PORTx.n = uservar</literal> can be used and therefore to write to a data port use <literal>PORTx = uservar</literal>.</simpara>
<simpara>Examples:</simpara>
<screen>    PORTb.0 = uservar
    PORTb = uservar</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Setting Ports and Port.bit</emphasis></simpara>
<simpara>You can set a port as shown above with a variable, or, you can set with a constant or any combination using the bitwise and logical operators.</simpara>
<screen>    #define InitStateofPort 0b11110000
    PORTb = InitStateofPort               'will unconditionally set bits 4:7

    PORTb = 0b11110000                    'will unconditionally set bits 4:7

    PORTb = uservar OR 0b11110000         'will OR bits 4:7 to ensure bits 4:7 are set</screen>
<simpara>The following is also valid - read a port.bit and then set port.bit with a variable or port value. As shown below.</simpara>
<screen>    dir portb out

    portb.0 = NOT  portb.0</screen>
<simpara>The user code above may cause issues with glitches when the read and write operations occurs.  Let us look at the generated assembler.</simpara>
<screen>    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      bcf PORTB,0
      btfsc SysTemp1,0
      bsf PORTB,0</screen>
<simpara>To resolve any glitches add <literal>#option Volatile</literal> to your user code.</simpara>
<screen>    #option Volatile portb.0

    dir portb out

    portb.0 = NOT  portb.0</screen>
<simpara>This option provides the following assembler resolving the glitch issue.</simpara>
<screen>    ;portb.0 = NOT  portb.0
      banksel SYSTEMP1
      clrf  SysTemp1
      btfsc PORTB,0
      incf  SysTemp1,F
      comf  SysTemp1,F
      btfsc SysTemp1,0
      bsf PORTB,0
      btfss SysTemp1,0
      bcf PORTB,0</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See also</emphasis>  <link linkend="_dir">Dir</link>, <link linkend="__option_volatile">#Option Volatile</link></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_configuration">
<title>Configuration</title>
<simpara><emphasis role="strong">About Configuration</emphasis></simpara>
<simpara><emphasis>(Note: This section does not apply to Atmel AVR microcontrollers. Atmel AVR microcontrollers
do have a similar configuration settings, but they are controlled
through "Configuration Fuses". Great Cow BASIC cannot set these -
you MUST use the programmer software.)</emphasis></simpara>
<simpara>Every Microchip PIC has a CONFIG word. This is an area of memory on the chip
that stores settings which govern the operation of the chip.</simpara>
<simpara>The following asects of the chip are governed by the CONFIG word:</simpara>
<itemizedlist>
<listitem>
<simpara>Oscillator selection - will the chip run from an internal oscillator,
or is an external one attached?</simpara>
</listitem>
<listitem>
<simpara>Automatic resets - should the chip reset if the power drops too low?
If it detects it is running the same piece of code over and over?</simpara>
</listitem>
<listitem>
<simpara>Code protection - what areas of memory must be kept hidden once
written to?</simpara>
</listitem>
<listitem>
<simpara>Pin usage - which pins are available for programming, resetting the
chip, or emitting PWM signals?</simpara>
</listitem>
</itemizedlist>
<simpara>The exact configuration settings vary amongst chips. To find out a list
of valid settings, please consult the datasheet for the microcontrollers that
you wish to use.</simpara>
<simpara>This can all be rather confusing - hence, Great Cow BASIC will automatically set
some config settings, unless told otherwise:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Low Voltage Programming (LVP) is turned off.</emphasis> This enables the PGM
pin (usually B3 or B4) to be used as a normal I/O pin.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Watchdog Timer (WDT) is turned off.</emphasis> The WDT resets the chip if it
runs the same piece of code over and over - this can cause trouble with
some of the longer delay routines in Great Cow BASIC.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Master Clear (MCLR) is disabled where possible.</emphasis> On many newer chips
this allows the MCLR pin (often PORTA.5) to be used as a standard input
port. It also removes the need for a pull-up resistor on the MCLR pin.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">An oscillator mode will be selected, based on the following rules:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>If the microcontroller has an internal oscillator, and the internal oscillator is
capable of generating the speed specified in the #chip line, then the
internal oscillator will be used.</simpara>
</listitem>
<listitem>
<simpara>If the clock speed is over 4 Mhz, the external HS oscillator is
selected</simpara>
</listitem>
<listitem>
<simpara>If the clock speed is 4 MHz or less, then the external XT oscillator
mode is selected.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Note that these settings can easily be individually overridden whenever
needed. For example, if the Watchdog Timer is needed, adding the line</simpara>
<screen>    #config WDT = ON</screen>
<simpara>This will enable the watchdog timer, without affecting any other
configuration settings.</simpara>
<simpara><emphasis role="strong">Using Configuration</emphasis></simpara>
<simpara>Once the necessary CONFIG options have been determined, adding them to
the program is easy. On a new line type "#config" and then list the
desired options separated by commas, such as in this line:</simpara>
<screen>    #config OSC = RC, BODEN = OFF</screen>
<simpara>Great Cow BASIC also supports this format on 10/12/16 series chips:</simpara>
<screen>    #config INTOSC_OSC_NOCLKOUT, BODEN_OFF</screen>
<simpara>However, for upwards compatibility with 18F chips, you should use the = style config settings.</simpara>
<simpara>It is possible to have several #config lines in a program - for
instance, one in the main program, and one in each of several #include
files. However, care must then be taken to ensure that the settings in
one file do not conflict with those in another.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="__config">#config Directive</link></simpara>
</section>
</section>
<section xml:id="_syntax">
<title>Syntax</title>
<section xml:id="_arrays">
<title>Arrays</title>
<simpara><emphasis role="strong">About Arrays</emphasis></simpara>
<simpara>An array is a special type of variable - one which can store several
values at once. It is essentially a list of byte numbers in which each one
can be addressed individually through the use of an "index". The index
is a value in brackets immediately after the name of the array.</simpara>
<simpara>Examples of array names are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Array/Index</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Fish(10)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Element 10 of an array called <literal>Fish</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DataLog(2)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The second number in an array named <literal>DataLog</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ButtonList(Temp)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An element in the array <literal>ButtonList</literal> that is selected according to the
value in the variable <literal>Temp</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Defining an array</emphasis></simpara>
<simpara>Use the DIM command to define an array.</simpara>
<screen>    DIM array_title ( number_of_elements )</screen>
<simpara>The number of elements can be number, a variable or a constant.</simpara>
<simpara><emphasis role="strong">Setting an entire array at once</emphasis></simpara>
<simpara>It is possible to set several elements of an array with a single line of
code. This short example shows how:</simpara>
<screen>    Dim TestVar(10)
    TestVar = 1, 2, 3, 4, 5, 6, 7, 8, 9</screen>
<simpara>When using the method above element 0 of the array TestVar will be set to the number of items in the list, which in this case is 9. Each element of the array will then be loaded with the corresponding value in the list - so in the example, TestVar(1) will be set to 1, TestVar(2) to 2, and so on.  Element 0 will only be set to number of items in the array when using this method up to 48 data elements.</simpara>
<simpara><emphasis role="strong">Array Length</emphasis>
Element 0 should not be used to obtain the length of the array. Element 0 will only be a consistent with respect to the length of the array when the array is set as shown above.</simpara>
<simpara>The correct method is to use a constant to set the array size and use the constant within your code to obtain the array length.</simpara>
<screen>    #Define ArraySizeConstant 500
    Dim TestVar( ArraySizeConstant )

    SerPrint ArraySizeConstant     'or, other usage</screen>
<simpara><emphasis role="strong">Using Arrays</emphasis></simpara>
<simpara>To use an array, its name is specified, then the index. Arrays can be
used everywhere that a normal variable can be used.</simpara>
<simpara>The limit on array size varies dependent on the chip type.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The 12F/16F series of chips the array limit is the physical RAM less a few bytes for array handling.</simpara>
</listitem>
<listitem>
<simpara>For the Atmel AVR or an 18F there is not limit other than free RAM.</simpara>
</listitem>
<listitem>
<simpara>However, Great Cow BASIC limits the array size of any array to 10,000 elements.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Get the most from the available memory</emphasis></simpara>
<simpara>Array RAM usage is determined by the architecture of the chip type. Getting most out of the available memory is determined by the allocation of the array within the available banks of memory.</simpara>
<simpara>An example is an array of 6 or 7 bytes when there is only 24 bytes of RAM  and the 24 bytes is split across multiple memory banks.  Assume in this example that 18 bytes have allocated to other variables and there is 29 bytes total available.  An array of 6 bytes will fit into the free space in one bank, but the array of 7 will not.</simpara>
<simpara>Great Cow BASIC currently cannot split an array over banks, so if there are 6 bytes free in one bank and 5 in another, you cannot have an array of 7 bytes.  This would be very hard to do efficiently on 12F/16F as there would be a series of special function registers in the middle of the array when using a 12F or 16F.   This constraint is not the case on 16F1/18F as linear addressing makes it easy to span banks because the SFRs are not making the problem (as with 12F/16F).</simpara>
<simpara><emphasis role="strong">Using Tables as an alternative.</emphasis></simpara>
<simpara>If there are many items in the array, it may be better to use a Lookup Table to store the items, and then copy some of the data items into a smaller array as needed.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_dim">Declaring arrays with DIM</link></simpara>
</section>
<section xml:id="_comments">
<title>Comments</title>
<simpara><emphasis role="strong">About Comments</emphasis></simpara>
<simpara>Adding comments to your Great Cow BASIC program is done with an apostrophe before
the comment line. You can also comment out sections of code if you want
just by placing an apostrophe, a semi-colon or use the statement REM at
the beginning of each line. The SynGCB IDE has a feature to do this
automatically.</simpara>
<simpara>Warning: Great Cow Graphical BASIC uses semi-colons to mark comments that it has
inserted automatically. It does not read these comments when opening a file, so any
comments in a Great Cow BASIC program starting with a semi-colon will be deleted if the
program is opened using Great Cow Graphical BASIC.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' The number of pins to flash
    #define FlashPins 2

    REM You can create a header using an apostrophe before each line
    REM This is a great way to describe your program
    REM You can also use it to describe the hardware connections.

    ' You can place comments above the command or on the same line
    Dir PORTB Out ' Initialise PORTB to all Outputs

    ; The Main loop
    do
    PORTB = 0 ' All Pins off
    Wait 1 S ' Delay 1 second
    PORTB = 0xFF ' All pins on
    Wait 1 s ' Delay 1 second
    Loop</screen>
</section>
<section xml:id="_conditions">
<title>Conditions</title>
<simpara><emphasis role="strong">About Conditions</emphasis></simpara>
<simpara>In Great Cow BASIC (and most other programming languages) a condition is a
statement that can be either true or false. Conditions are used when the
program must make a decision.
A condition is generally given as a value or variable, a relative
operator (such as = or &gt;), and another value or variable. Several
conditions can be combined to form one condition through the use of
logical operators such as AND and OR.</simpara>
<simpara>Great Cow BASIC supports these relative operators:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="60%"?>
<?dbfo table-width="60%"?>
<?dblatex table-width="60%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="128*"/>
<colspec colname="col_2" colwidth="128*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Symbol</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara><literal>=</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Equal</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&lt;&gt;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Not Equal</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&lt;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Less Than</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&gt;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Greater Than</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&#8656;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Less than or equal to</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>&gt;=</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Equal to or greater than</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>In addition, these logical operators can be used to combine several
conditions into one:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Name</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Abbreviation</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Condition true if</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara><literal>AND</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>&amp;</literal></simpara></entry>
<entry align="center" valign="top"><simpara>both conditions are true</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>OR</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>|</literal></simpara></entry>
<entry align="center" valign="top"><simpara>at least one condition is true</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>XOR</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>#</literal></simpara></entry>
<entry align="center" valign="top"><simpara>one condition is true</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara><literal>NOT</literal></simpara></entry>
<entry align="center" valign="top"><simpara><literal>!</literal></simpara></entry>
<entry align="center" valign="top"><simpara>the condition is not true</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>NOT is slightly different to the other logical operators, in that it
only needs one other condition. Other arithmetic operators may be
combined in conditions, to change values before they are compared, for
example.</simpara>
<simpara>Great Cow BASIC has two built in conditions - TRUE, which is always true, and
FALSE, which is always false. These can be used to create infinite
loops.</simpara>
<simpara>It is also possible to test individual bits in conditions. To do this,
specify the bit to test, then 1 or 0 (or ON and OFF respectively).
Presently there is no way to combine bit tests with other conditions -
NOT, AND, OR and XOR will not work.</simpara>
<simpara><emphasis role="strong">Example conditions:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Condition</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comments</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Temp = 0</simpara></entry>
<entry align="left" valign="top"><simpara>Condition is true if Temp = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Sensor &lt;&gt; 0</simpara></entry>
<entry align="left" valign="top"><simpara>Condition is true if Sensor is not 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Reading1 &gt; Reading2</simpara></entry>
<entry align="left" valign="top"><simpara>True if Reading1 is more than Reading2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Mode = 1 AND Time &gt; 10</simpara></entry>
<entry align="left" valign="top"><simpara>True if Mode is 1 and Time is more than 10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Heat &gt; 5 OR Smoke &gt; 2</simpara></entry>
<entry align="left" valign="top"><simpara>True if Heat is more than 5 or Smoke is more than 2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Light &gt;= 10 AND (NOT Time &gt; 7)</simpara></entry>
<entry align="left" valign="top"><simpara>True if Light is 10 or more, and Time is 7 or less</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Temp.0 ON</simpara></entry>
<entry align="left" valign="top"><simpara>True if Temp bit 0 is on</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Constraints when using Conditional Test</emphasis></simpara>
<simpara>As Great Cow BASIC is very flexible with the use of variables type this can cause issues when testing constants and/or functions.</simpara>
<simpara>A few simple rules. Always put the function or constant first, or, always call the function with the addition of the braces.</simpara>
<simpara>The example code below shows the correct method and an example that does compile but will not work as expected.</simpara>
<screen>    'Example A - works
    'Call the function by adding the braces
    '
    Do
    Loop While HSerReceive() &lt;&gt; 62

    'Example B - works
    'Please the constant first - this is the general rule - put the constant first.
    '
    Do
    Loop While 62 &lt;&gt; HSerReceive</screen>
<simpara>This fails as the function will not be called</simpara>
<screen>    'Example C - compiles but does not operate as expected
    Do
    Loop While HSerReceive &lt;&gt; 62</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_constants">
<title>Constants</title>
<simpara><emphasis role="strong">About Constants</emphasis></simpara>
<simpara>A constant tells the compiler to find a given
word, and replace it with another word or number. Define directives create constants.</simpara>
<simpara>Constants are useful for situations where a routine needs to be easily altered. For example, a
define could be used to specify the amount of time to run an alarm for
once triggered.</simpara>
<simpara>It is also possible to use defines to specify ports - thus defines can
be used to aid in the creation of code that can easily be adapted to run
on a different microcontroller with different ports.</simpara>
<simpara>Great Cow BASIC makes considerable use of defines internally. For instance, the
LCD code uses defines to set the ports that it must use to communicate
with the LCD.</simpara>
<simpara><emphasis role="strong">About Defines</emphasis></simpara>
<simpara>To create a define is a matter of using the #define directive. Here are
some examples of defines:</simpara>
<screen>    #define Line 34
    #define Light PORTB.0
    #define LightOn Set PORTB.0 on</screen>
<simpara><literal>Line</literal> is a simple constant - Great Cow BASIC will find <literal>Line</literal> in the program, and
replace it with the number 34. This could be used in a line following
program, to make it easier to calibrate the program for different
lighting conditions.</simpara>
<simpara><literal>Light</literal> is a port - it represents a particular pin on the microcontroller. This
would be of use if the program had many lines of code that controlled
the light, and there was a possibility that the port the light was
attached to would need to change in the future.</simpara>
<simpara><literal>LightOn</literal> is a define used to make the program more readable. Rather than
typing <literal>Set PORTB.0 on</literal> over and over, it would then be made possible to
type <literal>LightOn</literal>, and have the compiler do the hard work.</simpara>
<simpara><emphasis role="strong">Great Cow BASIC Defined constants</emphasis></simpara>
<screen>    #define ON 1
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    'Names for symbols
    #define AND &amp;
    #define OR |
    #define XOR #
    #define NOT !
    #define MOD %</screen>
<simpara><emphasis role="strong">Great Cow BASIC special constant</emphasis></simpara>
<simpara><literal>Forever</literal> is a special constant.  For Great Cow BASIC Graphical users think of this as 'false'. For those not using Great Cow BASIC Graphical think of this as a non numeric value that has no value.  You can use in a DO-LOOP but not in a REPEAT-END REPEAT loop, as the in the later case the REPEAT will have no value and you will create an error condition.</simpara>
<simpara><emphasis role="strong">Precedence of Constants within Great Cow BASIC.</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>#define</literal> command creates constants, and, a script can creates constants.
<?asciidoc-br?>
<?asciidoc-br?>
The precedence is as follows:
<?asciidoc-br?>
<?asciidoc-br?>
<literal>#define</literal> in the main program are read first,
<?asciidoc-br?>
<?asciidoc-br?>
then, the <literal>#define</literal> in the include files. Constants defined in the include files will be ignored if they conflict or are different to another constant in the main program,
<?asciidoc-br?>
<?asciidoc-br?>
then, the scripts are processed. Scripts that create constants always override any constant value previously defined.
<?asciidoc-br?>
<?asciidoc-br?>
Scripts are highest priority, then constants in the main program, then constants in include files from the main program, then constants in the standard libraries.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>See <emphasis role="strong"><link linkend="__define">#define</link></emphasis></simpara>
</section>
<section xml:id="_functions">
<title>Functions</title>
<simpara><emphasis role="strong">About Functions</emphasis></simpara>
<simpara>Functions are a special type of subroutine that can return a value. This
means that when the name of the function is used in the place of a
variable, Great Cow BASIC will call the function, get a value from it, and then
put the value into the line of code in the place of the variable.</simpara>
<simpara>Functions may also have parameters - these are treated in exactly the
same way as parameters for subroutines. The only exception is that
brackets are required around any parameters when calling a function.</simpara>
<simpara><emphasis role="strong">Using Functions</emphasis></simpara>
<simpara>This program uses a function called <literal>AverageAD</literal> to take two analog
readings, and then make a decision based on the average:</simpara>
<screen>    'Select chip
    #chip 16F88, 20

    'Define ports
    #define LED PORTB.0
    #define Sensor AN0

    'Set port directions
    dir LED out
    dir PORTA.0 in

    'Main code
    Do
    Set PORTB.0 Off
    If AverageAD &gt; 128 Then Set PORTB.0 On
    wait 10 ms
    Loop

    Function AverageAD
    'Get 2 readings, divide by 2, store in AverageAD
    'Note the cast, the result of ReadAD needs to be converted to
    'a word before adding, or the result may overflow.
    AverageAD = ([word]ReadAD(Sensor) + ReadAD(Sensor)) / 2
    end function</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_subroutines">Subroutines</link>, <link linkend="_exit">Exit</link></simpara>
</section>
<section xml:id="_labels">
<title>Labels</title>
<simpara><emphasis role="strong">About Labels</emphasis></simpara>
<simpara>Labels are used as markers throughout the program. Labels are used to
mark a position in the program to ‘jump to’ from another position using
a goto, gosub or other command.</simpara>
<simpara>Labels can be any word (that is not already a reserved keyword) and may
contain digits and the underscore character. Labels must start with a
letter or underscore (not digit), and are followed directly by a colon
(:) at the marker position. The colon is not required within the actual
commands.</simpara>
<simpara>The compiler is not case sensitive. Lower and/or upper case may be used
at any time.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir BUTTON Out

    Do
    PulseOut LIGHT, 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Wait 500 ms
    If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_goto">Goto</link>, <link linkend="_gosub">Gosub</link></simpara>
</section>
<section xml:id="_lookup_tables">
<title>Lookup Tables</title>
<simpara><emphasis role="strong">About Lookup Tables</emphasis></simpara>
<simpara>A lookup table is a list of values that are stored in the program memory
of the chip, which can be accessed using the <literal>ReadTable</literal> command.</simpara>
<simpara>The advantage of lookup tables is that they are memory efficient,
compared to an equivalent set of IF statements.</simpara>
<simpara>Data tables are defined as</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>a single value on each line</simpara>
</listitem>
<listitem>
<simpara>byte, word, longs and integer values are valid (no strings or decimals!)</simpara>
</listitem>
<listitem>
<simpara>multiple elements on a single line separated by commas</simpara>
</listitem>
<listitem>
<simpara>constants and calculations within the single line data table entries are permitted</simpara>
</listitem>
<listitem>
<simpara>an external data source file</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">Defining Tables</emphasis></simpara>
<simpara>A single value on each line</simpara>
<screen>    Table TestDataSource as Integer
        12
        24
        36
        48
        60
        72
    End Table</screen>
<simpara>Multiple elements on a single line separated by commas:</simpara>
<screen>    Table TestDataSource as Integer
        12,  24, 36
        48,  60, 72
    End Table</screen>
<simpara>Constants and calculations within the single line:</simpara>
<screen>#define calculation_constant 2

    Table TestDataSource as Integer
      1 * calculation_constant
      2 * calculation_constant
      4 * calculation_constant
      8 * calculation_constant
      16 * calculation_constant
      32 * calculation_constant
    End Table</screen>
<simpara>Data tables can now be loaded directly from a file.  The source file will be read as a hexidecimal raw file.</simpara>
<screen>Table TestDataSource from "sourcefile.raw"</screen>
<simpara><emphasis role="strong">Using Lookup Tables</emphasis></simpara>
<simpara>First, the table must be created. The code to create a lookup table is
simple - a line that has <literal>Table</literal> and then the name of the table, a list
of numbers (up to 10,000 elements), and then <literal>End Table</literal>.</simpara>
<simpara>For tables with more than 255 elements it is mandated to used a WORD variable to read the size of the table. See below.</simpara>
<simpara>Once the table is created, the <literal>ReadTable</literal> command is used to read data
from it. The <literal>ReadTable</literal> command requires the name of the table it is to
read, the location of the item to retrieve, and a variable to store the
retrieved number in.</simpara>
<simpara>Lookup tables can store byte, word, longs and integer values. Great Cow BASIC
will automatically detect the type of the table depending on the values
in it. Great Cow BASIC can be explicitly instructed to cast the table to a
variable type, as follows:</simpara>
<screen>    Table TestDataSource as Integer
        12
        24
        36
        48
        60
        72
    End Table</screen>
<simpara>Item 0 of a lookup table stores the size of the table. If the <literal>ReadTable</literal>
command attempts to read beyond the end of the table, the value 0 will
be returned.</simpara>
<simpara>For tables with more than 255 elements it is <emphasis role="strong">mandatory</emphasis> to use a WORD variable to read the size of the table. See below.</simpara>
<screen>    dim lengthoftable  word
    readtable TestDataSource , 0, lengthoftable
    print lengthoftable  ; will print the size as a word

    table TestDataSource
    'a table with more than 255 elements
    end table</screen>
<simpara>For tables that are defined using an external file the table data will be read into the TestDataSource table from the external file.</simpara>
<simpara>An example file is shown below:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lookuptablesb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The following program will import the external data file.</simpara>
<screen>    #chip 16f877a

    Table TestDataSource from "sourcefile.raw"

    for nn = 1 to 10
      ReadTable TestDataSource, nn, inc
      HSerPrint inc
    next</screen>
<simpara>And the program will out the following:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lookuptablesb2.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Advanced use of Lookup Tables</emphasis></simpara>
<simpara>You can use the <literal>Table</literal> statement to store the data table in EEPROM. If
the compiler is told to store a data table in "Data" memory, it will
store it in the EEPROM.</simpara>
<simpara><emphasis role="strong">NOTE</emphasis>
The limitation of of using EPPROM tables is that you can only
store BYTEs. You cannot store WORD values in the EEPROM tables.</simpara>
<simpara>Here is some example code:</simpara>
<screen>    #chip 16F628

    'Read table item
    'Must use ReadTable and a variable for the index, or the table won't be
    downloaded to EEPROM

    TableLoc = 2
    ReadTable TestDataSource, TableLoc, SomeVar

    'Write to table , this is not required
    EPWrite 1, 45

    'Table of values to write to EEPROM
    'EEPROM location 0 will store length of table
    'Subsequent locations will each store a value

    Table TestDataSource Store Data
        12
        24
        36
        48
        60
        72
    End Table</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_readtable">ReadTable</link></simpara>
</section>
<section xml:id="_miscellaneous">
<title>Miscellaneous</title>
<simpara><emphasis role="strong">About Miscellaneous things&#8230;&#8203;.</emphasis></simpara>
<simpara>It is possible to combine multiple instructions on a single line, by
separating them with a colon. For example, this code:</simpara>
<screen>    Set PORTB.0 On
    Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off
    Set PORTB.0 Off</screen>
<simpara>could also be written as:</simpara>
<screen>    Set PORTB.0 On: Set PORTB.1 On
    Wait 1 sec
    Set PORTB.0 Off: Set PORTB.0 Off</screen>
<simpara>In most cases, it will make no difference if commands share a line or
not. However, special care should be taken with If commands, as this
code:</simpara>
<screen>    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp &gt; 10 Then Set PORTB.0 On: Set PORTB.1 On
    Wait 1 s</screen>
<simpara>Will be equivalent to this:</simpara>
<screen>    Set PORTB.0 Off
    Set PORTB.1 Off
    If Temp &gt; 10 Then
    Set PORTB.0 On
    Set PORTB.1 On
    End If
    Wait 1 s</screen>
<simpara>Also, the commands used to start and end subroutines, data tables and
functions must be alone on a line. For example, this is WRONG:</simpara>
<screen>    Sub Something: Set PORTB.0 Off: End Sub</screen>
</section>
<section xml:id="_readtable">
<title>ReadTable</title>
<simpara><emphasis role="strong">About ReadTable</emphasis></simpara>
<simpara>The <literal>ReadTable</literal> command is used to read information from lookup tables.
<literal><emphasis>TableName</emphasis></literal> is the name of the table that is to be read, <literal><emphasis>Item</emphasis></literal> is the
line of the table to read, and <literal><emphasis>Output</emphasis></literal> is the variable to write the
retrieved value in to.</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ReadTable <emphasis>TableName, Item, Output</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal><emphasis>Item</emphasis></literal> is 1 for the first line of the table, 2 for the second, and so on.
Item 0 gives the size of the table. Care must be taken to ensure that
the program is not told to read beyond the end of the table, or strange
effects will be observed.</simpara>
<simpara>The type of <literal><emphasis>Output</emphasis></literal> should match the type of data stored in the table.
For example, if the table contains Word values then <literal><emphasis>Output</emphasis></literal> should be a
Word variable. If the type does not match, Great Cow BASIC will attempt to
convert the value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings
    #chip 16F88, 20

    'Hardware Settings
    #define LED PORTB.0
    Dir LED Out

    'Main Routine
    ReadTable TimesTwelve, 4, Temp
    Set LED Off
    If Temp = 48 Then Set LED On

    'Lookup table named "TimesTwelve"
    Table TimesTwelve
    12
    24
    36
    48
    60
    72
    84
    96
    108
    120
    132
    144
    End Table</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lookup_tables">Lookup Tables</link></simpara>
</section>
<section xml:id="_scripts">
<title>Scripts</title>
<simpara><emphasis role="strong">About Scripts</emphasis></simpara>
<simpara>A script is a small section of code that Great Cow BASIC runs when it
starts to compile a program.  Uses include performing calculations
that are required to adjust the program for different chip frequencies.</simpara>
<simpara>Scripts are not compiled or downloaded to the microcontroller - Great Cow BASIC
reads them, executes them, then removes them from the program and then the
results calculated can be used as <emphasis>constants</emphasis> in the user program.</simpara>
<simpara>Inside a script, <emphasis>constants</emphasis> are treated like variables.  Scripts can read
the values of <emphasis>constants</emphasis>, and set them to contain new values.</simpara>
<simpara><emphasis role="strong">Using Scripts</emphasis></simpara>
<simpara>Scripts start with <literal>#script</literal> and end with <literal>#endscript</literal>. Inside, they can
consist of the following commands:</simpara>
<screen>    If
    Assignment (=)
    Error
    Warning
    Int()</screen>
<simpara><literal>If</literal> is similar to the If command in normal Great Cow BASIC code, except that it does not have an <literal>Else</literal> clause.
It is used to compare the values of the script constants.</simpara>
<simpara>The <literal>=</literal> sign is identical to that in Great Cow BASIC programs.
The <emphasis>constant</emphasis> that is to be set goes on the left side of the <literal>=</literal> and the new value goes to the right of the <literal>=</literal>.</simpara>
<simpara><literal>Error</literal> is used to display an error message.
Anything after the <literal>Error</literal> command is displayed at the end of compilation, and is saved in the error log for the program.</simpara>
<simpara><literal>Warning</literal> is used to display a warning message. Anything after the <literal>Warning</literal> command is displayed at the end of compilation but warning does not halt compilation.</simpara>
<simpara><literal>Int()</literal> will calculate the integer value of a calculation. Using <literal>Int()</literal> is critical to set the <emphasis>constant</emphasis> to the integer component of the calculation.</simpara>
<simpara><emphasis role="strong">Notes:</emphasis></simpara>
<simpara>Use <literal>Warning</literal> to display constant values when creating and debugging scripts.</simpara>
<simpara>Scripts have a limited syntax and limited error checking when compiling.  The compiler may halt if you get something wrong.</simpara>
<simpara>Scripts that are incorrectly formatted may also halt the compiler or return unrelated error.</simpara>
<simpara>Scripts used for calculations should use the <literal>Int( expression )</literal> where you may have a floating point numbers returned.<?asciidoc-br?>
Scripts do use floating point for all calculations and a failure to use <literal>Int()</literal> may set the script constant and the resulting <emphasis>constant</emphasis> to 0.</simpara>
<simpara>Scripts may require that complex math expressions may require definition in multiple steps/line to simplify the calculation.<?asciidoc-br?>
The returned value could be incorrect if simplification is not implemented.</simpara>
<simpara>Scripts can only access existing <literal>constants</literal> both user and system defined.</simpara>
<simpara>User defines variables are not accessible within the scope of a script.</simpara>
<simpara>Scripts has precendence over #define.  A #define constant statements are read first, then scripts run.
So, a script will always overwrite a constant that was set with #define.</simpara>
<simpara>Use <literal>Warning</literal> to display constants values when creating and debugging scripts.</simpara>
<simpara><emphasis role="strong">Example Script</emphasis></simpara>
<simpara>This script is used in the pwm.h file.
It takes the values of the user defined <emphasis>constants</emphasis> PWM_Freq, PWM_Duty and system <emphasis>constant</emphasis> ChipMHz and calculates the results using the equations.
These calculation are based on information from a Microchip PIC datasheet to calculate the correct values to setup Pulse Width Modulation (PWM).</simpara>
<screen>    #script
        PR2Temp = INT((1/PWM_Freq)/(4*(1/(ChipMHz*1000))))
        T2PR = 1
        If PR2Temp &gt; 255 Then
            PR2Temp = INT((1 / PWM_Freq) / (16 * (1 / (ChipMHz * 1000))))
            T2PR = 4
            If PR2Temp &gt; 255 Then
                PR2Temp = INT(( 1 / PWM_Freq) / (64 * (1 / (ChipMHz * 1000))))
                T2PR = 16
                If PR2Temp &gt; 255 Then
                    Error Invalid PWM Frequency value
                End If
            End If
        End If

        DutyCycle = (PWM_Duty * 10.24) * PR2Temp / 1024
        DutyCycleH = (DutyCycle AND 1020) / 4
        DutyCycleL = DutyCycle AND 3
    #endscript</screen>
<simpara>During the execution of the script the calculations and assignment uses the constants in the script.</simpara>
<simpara>After this script has completed the <emphasis>constants</emphasis> <literal>PR2Temp</literal>, <literal>DutyCycleH</literal> and <literal>DutyCycleL</literal> are set using the constants and/or the calculations.</simpara>
<simpara>The <emphasis>constants</emphasis> assigned in this script, <literal>PR2Temp</literal>, <literal>DutyCycleH</literal> and <literal>DutyCycleL</literal>, are made available as <emphasis>constants</emphasis> in the user program.</simpara>
</section>
<section xml:id="_subroutines">
<title>Subroutines</title>
<simpara><emphasis role="strong">About Subroutines</emphasis></simpara>
<simpara>A subroutine is a small program inside of the main program. Subroutines
are typically used when a task needs to be repeated several times in
different parts of the main program.</simpara>
<simpara>There are two main uses for subroutines:</simpara>
<itemizedlist>
<listitem>
<simpara>Keeping programs neat and easy to read</simpara>
</listitem>
<listitem>
<simpara>Reducing the size of programs by allowing common sections of code to
be reused.</simpara>
</listitem>
</itemizedlist>
<simpara>When the microcontroller comes to a subroutine it saves its location in the current
program before jumping to the start of, or calling, the subroutine. Once
it reaches the end of the subroutine it returns to the main program, and
continues to run the code where it left off previously.</simpara>
<simpara>Normally, it is possible for subroutines to call other subroutines.
There are limits to the number of times that a subroutine can call
another sub, which vary from chip to chip:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Microcontroller Family</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Instruction Width</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Number of subs called</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>10F*, 12C5*, 12F5*, 16C5*, 16F5*</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12C*, 12F*, 16C*, 16F*, except those above</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>18F*, 18C*</simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
<entry align="center" valign="top"><simpara>31</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These limits are due to the amount of memory on the microcontroller which saves its
location before it jumps to a new subroutine. Some Great Cow BASIC commands are
subroutines, so you should always allow for 2 or 3 subroutine calls more
than your program has.</simpara>
<simpara>On 16F chips, the program memory is divided into pages. Each page holds 2048 instructions.&#160;&#160;&#160;
If the program jumps from code on one page to code on another, the compiler has to select the new page.&#160;&#160;&#160;Having to do this makes the program bigger, so try to avoid this.
To keep jumps between pages down, Great Cow BASIC imposes a rule that each subroutine must be entirely within one page, so that only jumps to other subroutines require the page selection.&#160;&#160;&#160;
As an example, say you have two pages of memory, each 2048 instructions (words) long.<?asciidoc-br?>
If you have a main sub that is 1500 words, and four other subroutines each 600 words long, your total program size would be 3900 words and you might expect it to fit into the 4096 words available. &#160;&#160;&#160;
The problem though is that once the main routine takes 1500 words from page 1, nothing else will fit after it. Three of the 600 word subroutines would fit onto page 2, but that leaves one 600 word subroutine that will not fit into the 500 left on page 1 or the 200 left on page 2.&#160;&#160;&#160;
If you want to reduce the chance of this happening, the best option is to keep your subroutines smaller - move anything out of the main routine and into another one - this will resolve memory page constraints.&#160;&#160;&#160;</simpara>
<simpara>Atmel AVR microcontrollers have no fixed limit on how many subroutines can be
called at a time, but if too many are called then some variables on the
chip may be corrupted. To check if there are too many subroutines, work
out the most that will be called at once, then multiply that number by 2
and create an array of that size. If an out of memory error message
comes up, there are too many calls.</simpara>
<simpara>Another feature of subroutines is that they are able to accept
parameters. These are values that are passed from the main program to
the subroutine when it is called, and then passed back when the
subroutine ends.</simpara>
<simpara><emphasis role="strong">Using Subroutines</emphasis></simpara>
<simpara>To call a subroutine is very simple - all that is needed is the name of
the sub, and then a list of parameters. This code will call a subroutine
named "Buzz" that has no parameters:</simpara>
<screen>    Buzz</screen>
<simpara>If the sub has parameters, then they should be listed after the name of
the subroutine. This would be the command to call a subroutine named
"MoveArm" that has three parameters:</simpara>
<screen>    MoveArm NewX, NewY, 10</screen>
<simpara>Or, you may choose to put brackets around the parameters, like so:</simpara>
<screen>    MoveArm (NewX, NewY, 10)</screen>
<simpara>All that this does is change the appearance of the code - it doesn&#8217;t
make any difference to what the code does. Decide which one meets your
own personal preference, and then stick with it.</simpara>
<simpara><emphasis role="strong">Creating subroutines</emphasis></simpara>
<simpara>To create a subroutine is almost as simple as using one. There must be a
line at the start which has <literal>sub</literal>, and then the name of the subroutine.
Also, there needs to be a line at the end of the subroutine which reads
<literal>end sub</literal>. To create a subroutine called <literal>Buzz</literal>, this is the required
code:</simpara>
<screen>    sub Buzz

    'code for the subroutine goes here

    end sub</screen>
<simpara>If the subroutine has parameters, then they need to be listed after the
name. For example, to define the <literal>MoveArm</literal> sub used above, use this
code:</simpara>
<screen>    sub MoveArm(ArmX, ArmY, ArmZ)

    'code for the subroutine goes here

    end sub</screen>
<simpara>In the above sub, <literal>ArmX</literal>, <literal>ArmY</literal> and <literal>ArmZ</literal> are all variables. If the call
from above is used, the variables will have these values at the start of
the subroutine:</simpara>
<screen>    ArmX = NewX
    ArmY = NewY
    ArmZ = 10</screen>
<simpara>When the subroutine has finished running, Great Cow BASIC will copy the values
back where possible. <literal>NewX</literal> will be assigned to <literal>ArmX</literal>, and <literal>NewY</literal> will be
assigned to <literal>ArmY</literal>. Great Cow BASIC will not attempt to set the number 10 to <literal>ArmZ</literal>.</simpara>
<simpara><emphasis role="strong">Controlling the direction data moves in</emphasis></simpara>
<simpara>It is possible to instruct Great Cow BASIC not to copy the value back after the
subroutine is called. If a subroutine is defined like this:</simpara>
<screen>    sub MoveArm(In ArmX, In ArmY, In ArmZ)
    'code for the subroutine goes here

    end sub</screen>
<simpara>Then Great Cow BASIC will copy the values to the subroutine, but will not copy
them back.</simpara>
<simpara>Great Cow BASIC can also be prevented from copying the values back, by adding
<literal>Out</literal> before the parameter name. This is used in the EEPROM reading
routines - there is no point copying a data value into the read
subroutine, so <literal>Out</literal> has been used to avoid wasting time and memory. The
EPRead routine is defined as <literal>Sub EPRead(In Address, Out Data)</literal>.</simpara>
<simpara>Many older sections of code use <literal>#NR</literal> at the end of the line where the
parameters are specified. The <literal>#NR</literal> means "No Return", and when used has
the same effect as adding <literal>In</literal> before every parameter. Use of <literal>#NR</literal> is
not recommended, as it does not give the same level of control.</simpara>
<simpara><emphasis role="strong">Using different data types for parameters</emphasis></simpara>
<simpara>It is possible to use any type of variable a as parameter for a
subroutine. Just add <literal>As</literal> and then the data type to the end of the
parameter name. For example, to make all of the parameters for the
<literal>MoveArm</literal> subroutine word variables, use this code:</simpara>
<screen>    sub MoveArm(ArmX As Word, ArmY As Word, ArmZ As Word)
    ...
    end sub</screen>
<simpara><emphasis role="strong">Optional parameters</emphasis></simpara>
<simpara>Sometimes, the same value may be used over and over again for a
parameter, except in a particular case. If this occurs, a default value
may be specified for the parameter, and then a value for that parameter
only needs to be given in a call if it is different to the default.</simpara>
<simpara>For example, suppose a subroutine to create an error beep is required.
Normally it emits ! 440 Hz tone, but sometimes a different tone is
required. To create the sub, this code would be use:</simpara>
<screen>    Sub ErrorBeep(Optional OutTone As Word = 440)
      Tone OutTone, 100
    End Sub</screen>
<simpara>Note the <literal>Optional</literal> before the parameter, and the <literal>= 440</literal> after it.
This tells Great Cow BASIC that if no parameter is supplied, then set the
<literal>OutTone</literal> parameter to 440.</simpara>
<simpara>If called using this line:</simpara>
<screen>    ErrorBeep</screen>
<simpara>then a 440 Hz beep will be emitted. If called using this line:</simpara>
<screen>    ErrorBeep 1000</screen>
<simpara>then the sub will produce a 1000 Hz tone.</simpara>
<simpara>When using several parameters, it is possible to make any number of them
optional. If the optional parameter/s are at the end of the call, then
no value needs to be specified. If they are at the start or in the
middle, then you must insert commas to allow Great Cow BASIC to tell where the
optional parameters are.</simpara>
<simpara><emphasis role="strong">Overloading</emphasis></simpara>
<simpara>It is possible to have 2 subroutines with the same name, but different
parameters. This is known as overloading, and Great Cow BASIC will automatically
select the most appropriate subroutine for each call.</simpara>
<simpara>An example of this is the Print routine in the LCD routines. There are
actually several Print subroutines; for example, one has a byte
parameter, one a word parameter, and one a string parameter. If this
command is used:</simpara>
<screen>    Print 100</screen>
<simpara>Then the Print (byte) subroutine will be called. However, if this
command is used:</simpara>
<screen>    Print 30112</screen>
<simpara>Then the Print (word) subroutine will be called. If there is no exact
match for a particular call, Great Cow BASIC will use the option that requires
the least conversion of variable types. For example, if this command is
used:</simpara>
<screen>    Print PORTB.0</screen>
<simpara>The byte print will be used. This is because byte is the closest type to
the single bit parameter.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_functions">Functions</link>, <link linkend="_exit">Exit</link></simpara>
</section>
<section xml:id="_variables">
<title>Variables</title>
<simpara><emphasis role="strong">About Variables</emphasis></simpara>
<simpara>A variable is an area of memory on the microcontroller that can be used
to store a number or a series of letters. This is useful for many
purposes, such as taking a sensor reading and acting on it, or counting
the number of times the robot has performed a particular task.</simpara>
<simpara>Each variable must be given a name, such as "MyVariable" or
"PieCounter". Choosing a name for a variable is easy - just don&#8217;t
include spaces or any symbols (other than _), and make sure that the
name is at least 2 characters (letters and/or numbers) long.</simpara>
<simpara><emphasis role="strong">Variable Types</emphasis></simpara>
<simpara>There are several different types of variable, and each type can store a
different sort of information. These are the variable types that Great
Cow BASIC can currently use:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable type</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Information that this variable can store</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example uses for this type of variable</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Bit</simpara></entry>
<entry align="left" valign="top"><simpara>A bit (0 or 1)</simpara></entry>
<entry align="left" valign="top"><simpara>Flags to track whether or not a piece of code has run</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Byte</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between 0 and 255</simpara></entry>
<entry align="left" valign="top"><simpara>General purpose storage of data, such as counters</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between 0 and 65535</simpara></entry>
<entry align="left" valign="top"><simpara>Storage of extra large numbers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Integer</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between -32768 and 32767</simpara></entry>
<entry align="left" valign="top"><simpara>Anything where a negative number will occur</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Long</simpara></entry>
<entry align="left" valign="top"><simpara>A whole number between 0 and 2<superscript>32</superscript> (4.29 billion)</simpara></entry>
<entry align="left" valign="top"><simpara>Storing very, very big numbers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Array</simpara></entry>
<entry align="left" valign="top"><simpara>A list of whole numbers ranging from 0 to 255</simpara></entry>
<entry align="left" valign="top"><simpara>Logs of sensor readings</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>A series of letters, numbers and symbols.</simpara></entry>
<entry align="left" valign="top"><simpara>Messages that are to be shown on a screen</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Using Variables</emphasis></simpara>
<simpara>Byte variables do not need any special commands to set them up - just
put the name of the variable in to the command where the variable is
needed.</simpara>
<simpara>Other types of variable can be used in a very similar way, except that
they must be "dimensioned" first. This involves using the DIM command,
to tell Great Cow BASIC that it is dealing with something other than a
byte variable.</simpara>
<simpara>A key feature of variables is that it is possible the have the
microcontroller check a variable, and only run a section of code if it
is a given value. This can be done with the IF command.</simpara>
<simpara><emphasis role="strong">String Variables</emphasis></simpara>
<simpara>Strings are defined as follows:</simpara>
<screen>    'Create buffer variables to store received messages

    Dim Buffer As String</screen>
<simpara>String variables default to the following rules and the RAM constraints
of a specific chip.</simpara>
<itemizedlist>
<listitem>
<simpara>10 bytes for chips with less than 16 bytes of RAM.</simpara>
</listitem>
<listitem>
<simpara>20 bytes for chips with 16 to 367 bytes of RAM.</simpara>
</listitem>
<listitem>
<simpara>40 bytes for devices with more RAM than 367 bytes.</simpara>
</listitem>
<listitem>
<simpara>For chips that have less RAM then the required RAM to support the user define strings the strings (and therefore the RAM) will be NOT be allocated. Please reduce string size.</simpara>
</listitem>
</itemizedlist>
<simpara>You cannot store a string 20 characters long in a chip with 16 bytes of RAM.</simpara>
<simpara>To change the default string size handled internally by the Great Cow BASIC compiler you add increase/decrease the default string size</simpara>
<screen>    'To define the default string size as the follows constant.
    #define STRINGSIZE 24</screen>
<simpara>Defining a length for the string is the best way to limit memory usage.
It is good practice if you need a string of a certain size to set the
length of a strings, since the default length for a string variable
changes depending on the amount of memory in the microcontroller (see
above).</simpara>
<simpara>To set the length of a string, see the example below:</simpara>
<screen>    'Create buffer variables to store received messages as 16 bytes long
    Dim OutBuffer As String * 16</screen>
<simpara>To place quotation marks (" ") in a string of text. For example:</simpara>
<screen>    She said, "You deserve a treat!"</screen>
<simpara>Use the following method to show the string with the insertion of two quotation marks in a row as an embedded quotation mark.
These two examples apply to all output methods like HerPrint, Print etc.</simpara>
<screen>    hserprint "She said, ""You deserve a treat!"" "

    dim myString as string * 39
    myString = "She said, ""You deserve another treat!"" "
    hserprint myString</screen>
<simpara><emphasis role="strong">Variable Aliases</emphasis></simpara>
<simpara>Some variables are aliases, which are used to refer to memory locations
used by other variables. These are useful for joining predefined byte
variable together to form word variables.</simpara>
<simpara>Alias are not like pointers in many languages - they must always refer
to the same variable or variables and cannot be changed.</simpara>
<simpara><emphasis role="strong">Casting</emphasis></simpara>
<simpara>Casting changes the type of a variable or value. Placing the type that
the value should be converted to in square brackets will tell the
compiler to convert it. For example, this will cause two byte variables
to be treated as word variables by the addition code:</simpara>
<screen>    Dim MyWord As Word
    MyWord = [word]ByteVar + AnotherByteVar</screen>
<simpara>Why do this? If there are no casts, then Great Cow BASIC will add the two values
using the byte addition code, and then convert the result to a word to
store in <literal>MyWord</literal>. Suppose that <literal>ByteVar</literal> is 150, and <literal>AnotherByteVar</literal> is 231.
When added, this will come to 381 - which will overflow, leaving 125 in
the result. However, when the cast is added, Great Cow BASIC will treat <literal>ByteVar</literal>
as if it were a word, and so will use the word addition code. This will
cause the correct result to be calculated.</simpara>
<simpara>Often, a cast will be used when calculating an average:</simpara>
<screen>    MyAverage = ([word]Value1 + Value2) / 2</screen>
<simpara>It&#8217;s also possible to cast the second value:</simpara>
<screen>    MyAverage = (Value1 + [word]Value2) / 2</screen>
<simpara>The result will be exactly the same.</simpara>
<simpara><emphasis role="strong">For more help, see:</emphasis> <link linkend="_dim">Declaring variables with DIM</link>,
<link linkend="_setting_variables">Setting Variables</link></simpara>
<simpara>Doing things to individual bits of variables see,
<link linkend="_set">Set</link>, <link linkend="_rotate">Rotate</link></simpara>
<simpara>Checking variables and doing different things based on their value, see
<link linkend="_if">If</link>, <link linkend="_do">Do</link>, <link linkend="_for">For</link>, <link linkend="_conditions">Conditions</link></simpara>
</section>
<section xml:id="_converters">
<title>Converters</title>
<simpara><emphasis role="strong">About Converters</emphasis></simpara>
<simpara>Converters allow Great Cow BASIC to read files that have been created by other programs.
A converter can convert these files into Great Cow BASIC libraries or any Great Cow BASIC instruction or a Great Cow BASIC dataset.</simpara>
<simpara>A typical use case is when you have a data source file from another computer system and you want to consume the data within your Great Cow BASIC program.
The data source file could be database, graphic, reference data or music file.
The converter will read these source files and convert them into a format that can be processed by Great Cow BASIC.
The conversion process is completed by external application which can be written by the developer or you can use
one of the converters provided with the Great Cow BASIC release.</simpara>
<simpara>The Great Cow BASIC release includes the converter for BMP files and standard Text files.</simpara>
<simpara>With an appropriate Converter installed, and an associated <literal>#include</literal> to these non-Great Cow BASIC files,
Great Cow BASIC will detect that the file extension and hand the processing to the external converting program.
When the external converting program had complete, Great Cow BASIC will then continue with the converted source file as a Great Cow BASIC source file.</simpara>
<simpara>An example of a converter is to read an existing picture file, convert the picture file to a GCB table and then refer to the picture
file table to display the picture file on a GLCD.</simpara>
<simpara>Conversion is achieved by including a command within the source program to transform external data.
The command used is the instruction <literal>#include</literal> followed by the data source.  An example:</simpara>
<screen>    'Convert ManLooking.BMP to a Great Cow BASIC usable format.

    #include &lt;..\converters\ManLooking.BMP&gt;</screen>
<simpara>The inclusion of the #include line within a Great Cow BASIC  program will enable the commencement of the following process:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Great Cow BASIC  will examine the <literal>..\converters</literal> folder structure for a configuration file that will handle the file extension specified in the include statement.</simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC  will examine the configuration file(s) <literal>*.INI</literal> for command line instructions.</simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC  will at stage examine the folder structure for the source file and the target transformed file.
If the source file is older than the transformed file the next step will not be executed, goto step 6.</simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC  will execute the command as specified within the configuration file to transform the source file to the target file.</simpara>
<simpara>The Conversion program must create the output file extension as specified in the configuration file.  If the include statement as an extension
of <literal>.TXT</literal> and the configuration files states the input file extension as <literal>.TXT</literal> and the output as <literal>.GCB</literal> the converted file must have the extension of <literal>.GCB</literal>.</simpara>
<literallayout class="monospaced">#include &lt;..\converters\ManLooking.BMP&gt;</literallayout>
<simpara>Init file is input file as BMP and output as GCB, then the file expected is <literal>..\converters\ManLooking.GCB</literal></simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC  will attempt to include the transformed target file (with the file extension as specified in the configuration file) within the Great Cow BASIC  program.</simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC  will resume normal processing of the Great Cow BASIC program including the transformed target file, therefore, with normal compiling and errors handling.</simpara>
</listitem>
</orderedlist>
<simpara>For example programs see <link linkend="XX0">here</link>.</simpara>
<simpara><emphasis role="strong">More about Converters</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The configuration file</simpara>
<simpara>The configuration file MUST have the extension of <literal>.INI</literal>.  No leading spaces are permitted in the configuration file.
Specification of the configuration file.
The file has four items: <literal>desc</literal>, <literal>in</literal>, <literal>out</literal> and <literal>exe</literal>. Where:</simpara>
<literallayout class="monospaced">desc      : Is the description shown in GCGB
in        : Is the source file extension to be transformed
out       : Is the target transformed file extension.
exe       : Is the executable to be run for this specific configuration file.
params    : Optional, is the required parameter to be passed from the compiler.  Example:  params = %filename% %chipmodel%
purge     : Optional, will always recreate the target transformed file. The default is to retain the target transformed file unless source has changed.</literallayout>
<simpara>You can have multiple configuration files within the <literal>..\converters folder structure</literal>.</simpara>
<simpara>Great Cow BASIC will examine all configuration file to match the extension as specified in the <literal>#include</literal> command.</simpara>
<simpara><emphasis role="strong">Example 1 :</emphasis></simpara>
<informalexample>
<simpara>BMP (Black and White) conversion configuration file is called <literal>BMP2GCBasic.ini</literal>.  The source extension is <literal>.bmp</literal>,
the transformed file extension is <literal>.GCB</literal>, and the executable is called <literal>BMP2GCBASIC.exe</literal>.</simpara>
<literallayout class="monospaced">desc = BMP file (*.bmp)
in = bmp
out = GCB
exe = BMP2GCBASIC .exe</literallayout>
<simpara>An example :</simpara>
<literallayout class="monospaced">#include &lt;..\converters\ManLooking.BMP&gt;</literallayout>
<simpara>Will be converted by the <literal>BMP2GCBASIC .EXE</literal> to <literal>..\converters\ManLooking.GCB</literal></simpara>
</informalexample>
<simpara><emphasis role="strong">Example 2 :</emphasis></simpara>
<informalexample>
<simpara>Data file conversion configuration file is called <literal>TXT2GCB.ini</literal>.  The source extension is <literal>.TXT</literal>, the transformed
file extension is <literal>.GCB</literal>, and the command line called <literal>AWKRUN.BAT</literal> .</simpara>
<literallayout class="monospaced">desc = Infrared Patterns (*.txt)
in = txt
out = GCB
exe = awkrun.bat</literallayout>
<simpara>An example :</simpara>
<literallayout class="monospaced">#include &lt;..\converters\InfraRedPatterns.TXT&gt;</literallayout>
<simpara>Will be converted by the <literal>AWKRUN.BAT</literal> to <literal>..\converters\ InfraRedPatterns.GCB</literal></simpara>
<simpara>The example would require a supporting batch file and a script process to complete the transformation.</simpara>
</informalexample>
</listitem>
<listitem>
<simpara>Conversion Executable</simpara>
<simpara>The conversion executable may be written in any language (compiled or interpreted).</simpara>
<simpara>The conversion executable MUST create the converted file with the correct file extension as specified in the configuration file.</simpara>
<simpara>The conversion executable will be passed one parameter - the source file name.
Using example #1 the conversion executable would be passed   <literal>..\converters\ManLooking.BMP</literal></simpara>
<simpara>The conversion executable MUST create a Great Cow BASIC compatible source file.  Any valid commands/instruction are permitted.</simpara>
</listitem>
<listitem>
<simpara>Installation</simpara>
<simpara>The <literal>INI</literal> file, the source file and the conversion executable MUST be located in the <literal>..\converters folder</literal>.
The converters folder is relative to the <literal>GCBASIC.EXE</literal> compiler folder.</simpara>
</listitem>
</orderedlist>
<simpara xml:id="XX0"><emphasis role="strong">Example 3 : Converter Program</emphasis></simpara>
<informalexample>
<simpara>This program converts the <literal>InfraRedPatterns.TXT</literal> into <literal>InfraRedPatterns.GCB</literal> that will have a Great Cow BASIC table called <literal>DataSource</literal>.
This example is located in the converter folder of the Great Cow BASIC installation.</simpara>
<screen>  #chip16f877a, 16
  #include &lt;..\converters\InfraRedPatterns.TXT&gt;

  dir portb out

  ' These must be WORDs as this could be large table.
  dim TableReadPosition, TableLen as word

  dir portb out

  ' Read the table length
  TableReadPosition = 0
  ReadTable DataSource, TableReadPosition, TableLen


  Do Forever
      For TableReadPosition = 1 to TableLen step 2
          ReadTable DataSource, TableReadPosition, TransmissionPattern
          ReadTable DataSource, TableReadPosition+1 , PulseDelay
          portb = TransmissionPattern
          wait PulseDelay ms
      next
  Loop</screen>
</informalexample>
<simpara><emphasis role="strong">Example 4 : Dynamic Import</emphasis></simpara>
<informalexample>
<simpara>This program converts a chip specific configuration file into <literal>manifest.GCB</literal> that will have a Great Cow BASIC functions called <literal>DataIn</literal> and <literal>DataOut</literal>.
This example is located in the converter folder of the Great Cow BASIC installation.</simpara>
<screen>    #chip 16f18326

    #include &lt;..\converters\manifest.mcc&gt;

    DataOut ( TX, RA0 )  'this method is created during the convert process. They do not exist withiut the converter.
    DataIn  ( Rx, RC6 )  'this method is created during the convert process. They do not exist withiut the converter.</screen>
<simpara>This example would use the optional parameters of <literal>params</literal> and <literal>purge</literal> in the converter configuration file as follows:</simpara>
<screen>    desc = PPS file (*.PPS)
    params = %filename% %chipmodel%
    in = mcc
    out = GCB
    exe = DataHandler.exe
    purge = on</screen>
</informalexample>
</section>
</section>
<section xml:id="_command_references">
<title>Command References</title>
<section xml:id="_analog_digital_conversion">
<title>Analog/Digital conversion</title>
<simpara>This is the Analog/Digital conversion section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_analog_digital_conversion_overview">
<title>Analog/Digital Conversion Overview</title>
<simpara><emphasis role="strong">About Analog to Digital Conversion</emphasis></simpara>
<simpara>The analog to digital converter (ADC or A/D) module support is implemented by Great Cow BASIC to provide 8-bit, 10-bit and 12-bit Single channel measurement mode and Differential Channel Measurement mode.</simpara>
<simpara>Great Cow BASIC configures the analog to digital converter clock source, the programmed acquisition time and justification of the response byte, word or integer (as defined in the Great Cow BASIC method).</simpara>
<simpara><emphasis role="strong">Normal or Single channel measurement mode</emphasis></simpara>
<simpara>The Single channel measurement mode is the default method for reading the ADC port.  The positive input is attached to suitable device (a light sensor or adjustable resistor) and the command ReadADC, ReadADC10, ReadADC12 with return a byte, word or word value respectively.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/adcoverviewb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The A/D module on most microcontrollers only supports single-ended mode. Single channel mode uses a single A/D port and the returned Value represents the difference between the voltage on the analog pin and a fixed negative reference which is usually ground or Vss.</simpara>
<simpara>The syntax for single-ended A/D is Returned_Value = ReadAD(Port)</simpara>
<simpara>Example</simpara>
<screen>  Print ReadAD10(AN3)</screen>
<simpara><emphasis role="strong">Differential channel measurement mode</emphasis></simpara>
<simpara>Some of the in the Microchip PIC family of devices also support differential analog to digital conversion. With differential conversion, the differential voltage between two channels is measured and converted to a digital value.  The returned value can be either positive or negative (therefore an integer value).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/adcoverviewb2.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When configured to differential channel measurement mode, the positive channel is connected to the defined positive analog pin (ANx), and the negative channel is connected to the defined negative analog pin. These two pins are internally connected (within the microcontroller) to a unity gain differential amplifier and once the amplifier has completed the comparison the result is returned as an integer.</simpara>
<simpara>The positive channel Input is selected using the CHSx bits and the negative channel input is selected using the CHSNx bits.  These bits are managed by Great Cow BASIC.  The programmer only needs to supply the correct analog pin designators in the ReadADx commands.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/adcoverviewb3.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The 12-bit returned result is available on the ADRESH and ADRESL registers which is returned by the Great Cow BASIC methods as an integer variable.</simpara>
<simpara>Some Microchip PIC microcontrollers have differential A/D modules and support differential Mode as well as 12-Bit A/D. With DIfferential mode the returned value can be either a positive or negative number that represents the voltage differential between the two A/D ports.</simpara>
<simpara>The syntax for differential A/D is ReadAD( PositiveANPort , NegativeANPort ).  Note: if "negative port" is omitted readAd() will perform a single-ended read on the positive AN port.</simpara>
<simpara>Example</simpara>
<screen>  Print ReadAD12( AN3, An4 )</screen>
<simpara><emphasis role="strong">Optimising Great Cow BASIC Code</emphasis></simpara>
<simpara>Great Cow BASIC supports a wide range of A/D modules and the supporting library addresses up to 34 channels.
To reduce the size of the code produced you can define which channels are specifically supported.  See <link linkend="_analog_digital_conversion_code_optimisation">Optimising ADC code</link> for more details.</simpara>
<simpara>See also <link linkend="_readad">ReadAD</link>, <link linkend="_readad10">ReadAD10</link> and <link linkend="_readad12">ReadAD12</link></simpara>
<simpara>The Microchip PIC microcontrollers that support Differential and 12-bit A/D are listed below. Dated December 2015.</simpara>
<screen>    16f1782  16lf1782
    16f1783  16lf1783
    16f1784  16lf1784
    16f1786  16lf1786
    16f1787  16lf1787
    16f1788  16lf1788
    16f1789  16lf1789


    18f65k22
    18f66k22
    18f67k22
    18f85k22
    18f86k22
    18f86k22


    18f25k80 18lf25k80
    18f26k80 18lf26k80
    18f45k80 18lf45k80
    18f46k80 18lf46k80
    18f65k80 18lf65k80
    18f66k80 18lf66k80


    18f65k90
    18f66k90
    18f67k90
    18f85k90
    18f86k90
    18f87k22
    18f87k90</screen>
</section>
<section xml:id="_adformat_deprecated_do_not_use">
<title>ADFormat (Deprecated - Do not use)</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>ADFormat ( Format_Left | Format_Right )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available only on Microchip PIC microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Left justified means 8 bits in the high byte, 2 in the low. Right
justified means 2 in the high byte, and the remaining 8 in the low byte.
It&#8217;s only supported on Microchip PIC microcontrollers.</simpara>
</section>
<section xml:id="_adoff">
<title>ADOff</title>
<simpara><emphasis role="strong">This command is obsolete</emphasis>. There should be no need to call it. Great Cow BASIC
will automatically disable the A/D converter and set all pins to digital
mode when starting the program, and after every use of the ReadAD
function.</simpara>
<simpara>It is recommended that this command be removed from all programs.</simpara>
</section>
<section xml:id="_readad">
<title>ReadAD</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>For a normal ( also called a Single Channel )  read use.</simpara>
<screen>    var = ReadAD_port( ANX )</screen>
<simpara>For a Differential Channel read use the following. Where ANpX is the positive port, and ANnY is the negative port.</simpara>
<screen>    user_variable = ReadAD( ANpX , ANnY )</screen>
<simpara>To obtain a byte value from an AD Channel use the following to force an 8 bit AD Channel to respond with a byte value [0 to 255].</simpara>
<screen>    user_variable = ReadAD( ANX , TRUE )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>When using <emphasis role="strong">ReadAD</emphasis> ( ANx ) the returned value is an 8 bit number [0- 255]. The user variable assigned by the function can be a byte, word, integer or long.</simpara>
<simpara>When using <emphasis role="strong">ReadAD</emphasis> ( ANpX , ANnY ) the returned value is an integer, as negative values can be returned.</simpara>
<simpara>When using <emphasis role="strong">ReadAD</emphasis> ( ANpX , TRUE ) the returned value is an integer, but you should treat as a byte.</simpara>
<simpara>ReadAD is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include. port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use. Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc. Refer to the datasheet for the microcontroller chip to find the number of ports available. (Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller)</simpara>
<simpara>Another function, <emphasis role="strong">ReadAD10</emphasis>, is similar to <emphasis role="strong">ReadAD</emphasis>.  The only difference is that it returns a full value of the ADC either 8bits or 10 bits.</simpara>
<simpara>The constant <emphasis role="strong">AD_Delay</emphasis> controls is the acquisition delay.  The default value is 20 us. This can be changed by adding the following constant.</simpara>
<screen>    #define AD_Delay 2 10us</screen>
<simpara><emphasis role="strong">ADSpeed</emphasis> controls the source of the clock for the ADC module.  It varies from one chip to another.  InternalClock is a Microchip PIC microcontroller only option that will drive the ADC from an internal RC oscillator. The default value is 128.</simpara>
<simpara>Using ADSPEED</simpara>
<screen>    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</screen>
<simpara><emphasis role="strong">AD_VREF_DELAY</emphasis> controls the charging time for VRef capacitor on Atmel AVR microcontrollers only. This therefore controls the charge from internal VRef.  ReadAD will not be accurate for internal reference without this.</simpara>
<simpara><emphasis role="strong">AD_Acquisition_Time_Select_bits</emphasis> also controls the Acquisition Time Select bits.  Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</simpara>
<simpara>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set. To change use the following.</simpara>
<screen>    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</screen>
<simpara><emphasis role="strong">Example 1</emphasis></simpara>
<simpara>This example reads the ADC port and writes the output to the EEPROM.</simpara>
<screen>    #chip 16F819, 8
    #config osc = int


    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 2</emphasis></simpara>
<simpara>This example reads the ADC port and writes the output to the EEPROM. The output value will be in the range of [0-255].</simpara>
<screen>    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD(AN0, TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 3</emphasis></simpara>
<simpara>This example used the diffential capabilities of ADC port and writes the output to the EEPROM. The output value will be in the range of [-255 to 255].</simpara>
<simpara>AN0 and AN2 are used for the diffential ADC reading.</simpara>
<screen>    #chip 16F1789, 8


    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        EPWrite CurrentAddress, ReadAD( AN0, AN2 )

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_readad10">ReadAD10</link>, <link linkend="_readad12">ReadAD12</link></simpara>
</section>
<section xml:id="_readad10">
<title>ReadAD10</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>For a normal ( also called a Single Channel )  read use.</simpara>
<screen>    user_variable = ReadAD10( ANX )</screen>
<simpara>For a Differential Channel read use the following. Where ANpX is the positive port, and ANnY is the negative port.</simpara>
<screen>    user_variable = ReadAD10( ANpX , ANnY )</screen>
<simpara>To obtain a 10-bit value from an AD Channel use the following to force a 10 bit AD Channel to respond with the correct value, in terms of the range [0 to 1023]</simpara>
<screen>    user_variable = ReadAD10( ANX , TRUE )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>When using <emphasis role="strong">ReadAD10</emphasis> ( ANX ) the returned value is the <emphasis role="strong">full range</emphasis> of the ADC module. Therefore, the method will return an 8 bit value [0-255], or an 10 bit value [0-1023] or an 12 bit value [0-4095].  This is dependent on the microcontrollers capabilities.   For a 10 bit value [0-1023] always to be returned use  user_variable = ReadAD10( ANX , TRUE )</simpara>
<simpara>The user variable can be a word, integer or long.</simpara>
<simpara>When using <emphasis role="strong">ReadAD10</emphasis> ( ANpX , ANnY ), for differential ADC reading, the returned value is an integer as negative values can be returned.</simpara>
<simpara>ReadAD10 is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include. The port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use. Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc. Refer to the datasheet for the microcontroller chip to find the number of ports available. (Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)</simpara>
<simpara>Another function, <emphasis role="strong">ReadAD</emphasis> is similar to <emphasis role="strong">ReadAD10</emphasis>. The only difference is that the <emphasis role="strong">ReadAD</emphasis> method returns a byte variable.</simpara>
<simpara><emphasis role="strong">AD_Delay</emphasis> controls is the acquisition delay.  The default value is 20 us. This can be changed to a longer acquisition delay by adding the following constant.</simpara>
<screen>    #define AD_Delay 4 10us</screen>
<simpara><emphasis role="strong">ADSpeed</emphasis>( controls the source of the clock for the ADC module.  It varies from one chip to another.  InternalClock is a microcontroller only option that will drive the ADC from an internal RC oscillator. The default value is 128.</simpara>
<screen>    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</screen>
<simpara><emphasis role="strong">AD_Acquisition_Time_Select_bits</emphasis> also controls the Acquisition Time Select bits.  Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</simpara>
<simpara>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set. To change use the following.</simpara>
<screen>    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</screen>
<simpara><emphasis role="strong">Example 1 - Read 10-bit ADC</emphasis></simpara>
<screen>    #chip 16F819, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 2 - Reading Reference Voltages:</emphasis></simpara>
<simpara>When selecting the  reference source for ADC on ATmega328 Great Cow BASIC will overwrite anything that you put into te ADMUX register - but this option allow you change the ADC reference source on Atmel AVR microcontrollers.  You can set the AD_REF_SOURCE constant to whatever you want to use.  It defaults to the VCC pin, as example you can set the Atmel AVR to use the 1.1V reference with this:
<emphasis role="strong">#define AD_REF_SOURCE AD_REF_256</emphasis> where 256 refers to the 2.56V reference on some older AVRs, but the same code will select the 1.1V reference on an ATmega328p</simpara>
<screen>    ' Dynamically switching reference.
    #define AD_REF_SOURCE ADRefSource
    #define AD_VREF_DELAY 5 ms
    AdRefSource = AD_REF_AVCC
    HSerPrint ReadAD10(AN1)
    HSerPrint ", "
    AdRefSource = AD_REF_256
    HSerPrint ReadAD10(AN1)</screen>
<simpara>The example above sets the AD_REF_SOURCE to a variable, and then changes the value of the variable to select the source.  With this approach, we also need to allow time to charge the reference capacitor to the correct voltage.</simpara>
<simpara><emphasis role="strong">Example 3 - Read 10-bit ADC forcing a 10-bit value to be returned</emphasis></simpara>
<screen>    #chip 16F1789, 8

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD10(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 4</emphasis></simpara>
<simpara>This example used the diffential capabilities of ADC port and writes the output to the EEPROM. The output value will be in the range of [-1023 to 1023].</simpara>
<simpara>AN0 and AN2 are used for the diffential ADC reading.</simpara>
<screen>    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD10( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_readad">ReadAD</link>, <link linkend="_readad12">ReadAD12</link></simpara>
</section>
<section xml:id="_readad12">
<title>ReadAD12</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>For a normal ( also called a Single Channel )  read use.</simpara>
<screen>    user_variable = ReadAD12( ANX )</screen>
<simpara>For a Differential Channel read use the following. Where ANpX is the positive port, and ANnY is the negative port.</simpara>
<screen>    user_variable = ReadAD12( ANpX , ANnY )</screen>
<simpara>To obtain a 12-bit value from an AD Channel use the following to force a 12 bit AD Channel to respond with the correct value, in terms of the range of [0 to 4095]</simpara>
<screen>    user_variable = ReadAD12( ANX , TRUE )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>When using <emphasis role="strong">ReadAD12</emphasis> ( ANX ) the returned value is an 12 bit number [0-4095]. The user variable can be a word, integer or long.</simpara>
<simpara>When using <emphasis role="strong">ReadAD12</emphasis> ( ANpX , ANnY ) the returned value is an integer as negative values can be returned.</simpara>
<simpara><emphasis role="strong">ReadAD12</emphasis>  is a function that can be used to read the built-in analog to digital converter that many microcontroller chips include. Port should be specified as AN0, AN1, AN2, etc., up to the number of analog inputs available on the chip that is in use. Those familiar with Atmel AVR microcontrollers can also refer to the ports as ADC0, ADC1, etc. Refer to the datasheet for the microcontroller chip to find the number of ports available. (Note: it&#8217;s perfectly acceptable to use ANx on AVR, or ADCx on the microcontroller.)</simpara>
<simpara>Another function, <emphasis role="strong">ReadAD10</emphasis> is similar to <emphasis role="strong">ReadAD12</emphasis>. The only difference is that it returns a 10 bit number.</simpara>
<simpara><emphasis role="strong">AD_Delay</emphasis> controls is the acquisition delay.  The default value is 20 us. This can be changed to a longer acquisition delay by adding the following constant.</simpara>
<screen>    #define AD_Delay 4 10us</screen>
<simpara><emphasis role="strong">ADSpeed</emphasis>( controls the source of the clock for the ADC module.  It varies from one microcontroller to another.  InternalClock is a Microchip PIC microcontroller only option that will drive the ADC from an internal RC oscillator. The default value is 128.</simpara>
<screen>    'default value
    #define ADSpeed MediumSpeed


    'pre-defined constants
    #define HighSpeed 255
    #define MediumSpeed 128
    #define LowSpeed 0</screen>
<simpara><emphasis role="strong">AD_Acquisition_Time_Select_bits</emphasis> also controls the Acquisition Time Select bits.  Acquisition time is the duration that the AD charge
holding capacitor remains connected to AD channel from the instant the read is commenced is set until conversions begins.</simpara>
<simpara>The default value of AD_Acquisition_Time_Select_bits is 0b100 or decimal 4, where all three ACQT bits will be set. To change use the following.</simpara>
<screen>    'change the default value
    #define AD_Acquisition_Time_Select_bits 0b001    'this will only set ACQT bit 0, ACQT bits 1 and 2 will be cleared.</screen>
<simpara><emphasis role="strong">Example 1  - Read 12-bit ADC</emphasis></simpara>
<screen>    #chip 16F1788, 8
    #config osc = int


    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 2  - Force a 12-bit value to be returned</emphasis></simpara>
<screen>    #chip 16F1788, 8


    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 readings
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        Print str(ReadAD12(AN0), TRUE)

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next</screen>
<simpara><emphasis role="strong">Example 3</emphasis></simpara>
<simpara>This example used the diffential capabilities of ADC port and writes the output to the EEPROM. The output value will be in the range of [-4095 to 4095].</simpara>
<simpara>AN0 and AN2 are used for the diffential ADC reading.</simpara>
<screen>    #chip 16F1789, 8

    'USART settings
    #define USART_BAUD_RATE 9600  'Initializes USART port with 9600 baud
    #define USART_TX_BLOCKING ' wait for tx register to be empty
    wait 100 ms

    'Set the input pin direction
    Dir PORTA.0 In
    Dir PORTA.2 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

        'Take a reading and log it
        HSerPrint ReadAD12( AN0, AN2 )
        HserPrintCRLF
        'Wait 10 minutes before getting another reading
        Wait 10 min

    Next</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_readad">ReadAD</link>, <link linkend="_readad10">ReadAD10</link></simpara>
</section>
<section xml:id="_analog_digital_conversion_code_optimisation">
<title>Analog/Digital Conversion Code Optimisation</title>
<simpara><emphasis role="strong">About Analog/Digital Conversion Code Optimisation</emphasis></simpara>
<simpara>The analog to digital converter (ADC or A/D) module support is implemented by Great Cow BASIC to provide 8-bit, 10-bit and 12-bit Single channel measurement mode and Differential Channel Measurement with support up to 34 channels.  For compatibility all channels are supported.</simpara>
<simpara>There are two methods to optimise the code.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>To mimise the code, use the contstants to disable support for a specfic channels</simpara>
</listitem>
<listitem>
<simpara>To adapt the ADC configuration by inserting specfic commands to set registers or register bits.</simpara>
</listitem>
</orderedlist>
<simpara><emphasis role="strong">1. Minimise the code</emphasis></simpara>
<simpara>The example below would disable support for ADC port 0 (AD0).</simpara>
<screen>    #define USE_AD0 FALSE</screen>
<simpara>The following tables show the #defines that can be used to reduce the code size - these are the defines for the standard microcontrollers.
For 16f1688x and similar microcontrollers please see the second table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Channel</entry>
<entry align="left" valign="top">Optimisation Value</entry>
<entry align="left" valign="top">Default Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD9</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD10</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD11</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD12</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD13</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD14</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD15</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD16</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD17</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD18</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD19</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD20</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD21</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD22</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD23</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD24</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD25</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD26</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD27</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD28</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD29</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD30</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD31</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD32</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD33</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_AD34</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For 16f1688x devices see the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Channel</entry>
<entry align="left" valign="top">Optimisation Value</entry>
<entry align="left" valign="top">Default Value</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADA7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADC7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD3</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD5</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD6</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADD7</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADE0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADE1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USE_ADE2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FALSE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TRUE</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This is a example - disables every channel except the specified channel by defining every channel except USE_AD0 as FALSE.</simpara>
<simpara>This will save 146 bytes of program memory.</simpara>
<screen>; ----- Configuration
    #chip 16F1939

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    'Set the input pin direction
    Dir PORTA.0 In


    'Print 255 reading
    For CurrentAddress = 0 to 255

        'Take a reading and show it
        HSerPrint str(ReadAD10(AN0))

        'Wait 10 minutes before getting another reading
        Wait 10 min
    Next

    #define USE_AD0 TRUE
    #define USE_AD1 FALSE
    #define USE_AD2 FALSE
    #define USE_AD2 FALSE
    #define USE_AD3 FALSE
    #define USE_AD4 FALSE
    #define USE_AD5 FALSE
    #define USE_AD6 FALSE
    #define USE_AD7 FALSE
    #define USE_AD8 FALSE
    #define USE_AD9 FALSE
    #define USE_AD10 FALSE
    #define USE_AD11 FALSE
    #define USE_AD12 FALSE
    #define USE_AD13 FALSE
    #define USE_AD14 FALSE
    #define USE_AD15 FALSE
    #define USE_AD16 FALSE
    #define USE_AD17 FALSE
    #define USE_AD18 FALSE
    #define USE_AD19 FALSE
    #define USE_AD20 FALSE
    #define USE_AD21 FALSE
    #define USE_AD22 FALSE
    #define USE_AD23 FALSE
    #define USE_AD24 FALSE
    #define USE_AD25 FALSE
    #define USE_AD26 FALSE
    #define USE_AD27 FALSE
    #define USE_AD28 FALSE
    #define USE_AD29 FALSE
    #define USE_AD30 FALSE
    #define USE_AD31 FALSE
    #define USE_AD32 FALSE
    #define USE_AD33 FALSE
    #define USE_AD34 FALSE</screen>
<simpara>For 16f18855 family of microcontrollers this is a example.  This will save 149 bytes of program memory.</simpara>
<screen>    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCB@SYN
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: 13.3.2016
    '''


        'Chip Settings.
        #chip 16f18855,32
        #Config FEXTOSC_OFF, RSTOSC_HFINT32
        #Config WRT_OFF, CPD_ON, MCLRE_ON

        '' -------------------LATA-----------------
        '' Bit#:  -7---6---5---4---3---2---1---0---
        '' LED:   ---------------|D5 |D4 |D3 |D1 |-
        ''-----------------------------------------
        ''

        #define USART_BAUD_RATE 19200
        #define USART_TX_BLOCKING

        #define LEDD2 PORTA.0
        #define LEDD3 PORTA.1
        #define LEDD4 PORTA.2
        #define LEDD5 PORTA.3
        Dir     LEDD2 OUT
        Dir     LEDD3 OUT
        Dir     LEDD4 OUT
        Dir     LEDD5 OUT

        #define SWITCH_DOWN         0
        #define SWITCH_UP           1

        #define SWITCH              PORTA.5


        'Setup an Interrupt event when porta.5 goes negative.
        IOCAN5 = 1
        On Interrupt PORTBChange  Call InterruptHandler

        do

         'Read the value from the EEPROM from register Zero in the EEPROM
          EPRead ( 0, OutValue )

          'Leave the Top Bytes alone and set the lower four bits
          PortA = ( PortA &amp; 0XF0 ) OR ( OutValue / 16 )
          Sleep

        loop


    sub InterruptHandler

        if IOCAF5 = 1 then                         'S2 was just pressed
            IOCAN5 = 0                             'Prevent the event from reentering the InterruptHandler routine
            IOCAF5 = 0                             'We must clear the flag in software

            wait 5 ms                              'debounce by waiting and seeing if still held down
            if ( SWITCH = DOWN ) then
                'Read the ADC
                adc_value = readad ( AN4 )
                'Write the value to register Zero in the EEPROM
                EPWrite ( 0, adc_value )
            end if
            IOCAN5 = 1                              'ReEnable the InterruptHandler routine

        end if

    end sub

    #define USE_ADA0 FALSE
    #define USE_ADA1 FALSE
    #define USE_ADA2 FALSE
    #define USE_ADA3 FALSE
    #define USE_ADA4 TRUE
    #define USE_ADA5 FALSE
    #define USE_ADA6 FALSE
    #define USE_ADA7 FALSE
    #define USE_ADB0 FALSE
    #define USE_ADB1 FALSE
    #define USE_ADB2 FALSE
    #define USE_ADB3 FALSE
    #define USE_ADB4 FALSE
    #define USE_ADB5 FALSE
    #define USE_ADB6 FALSE
    #define USE_ADB7 FALSE
    #define USE_ADC0 FALSE
    #define USE_ADC1 FALSE
    #define USE_ADC2 FALSE
    #define USE_ADC3 FALSE
    #define USE_ADC4 FALSE
    #define USE_ADC5 FALSE
    #define USE_ADC6 FALSE
    #define USE_ADC7 FALSE
    #define USE_ADD0 FALSE
    #define USE_ADD1 FALSE
    #define USE_ADD2 FALSE
    #define USE_ADD3 FALSE
    #define USE_ADD4 FALSE
    #define USE_ADD5 FALSE
    #define USE_ADD6 FALSE
    #define USE_ADD7 FALSE
    #define USE_ADE0 FALSE
    #define USE_ADE1 FALSE
    #define USE_ADE2 FALSE</screen>
<simpara><emphasis role="strong">2. Adapt the ADC configuration</emphasis></simpara>
<simpara>The following example will set the specific register bits.  The instruction will be added to the compiled code.</simpara>
<screen>    #define ADReadPreReadCommand  ADCON.2=0:ANSELA.0=1</screen>
<simpara>The constant <emphasis role="strong">ADReadPreReadCommand</emphasis> can be used to adapt the ADC methods. The constant can enable registers or register bit(s) that are required to managed for a specfic solution.</simpara>
<simpara>In the example above the following ASM will be added to your code.  This WILL be added just before the ADC is enabled and the setting of the acquisition delay.</simpara>
<screen>  ;ADReadPreReadCommand
  banksel ADCON
  bcf ADCON,2
  banksel ANSELA
  bsf ANSELA,0</screen>
</section>
</section>
<section xml:id="_bitwise">
<title>Bitwise</title>
<simpara>This is the Bitwise section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_bitwise_operations_overview">
<title>Bitwise Operations Overview</title>
<simpara><emphasis role="strong">About Bitwise Operations</emphasis></simpara>
<simpara>Great Cow BASIC (as with most other microcontroller programming languages) supports bitwise operations.</simpara>
<simpara>Bitwise operations are performed on one or more bit patterns at the level of their individual bits.</simpara>
<simpara>Great Cow BASIC supports the following methods.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Meaning</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Set</simpara></entry>
<entry align="left" valign="top"><simpara>Assigns a Bit value of On or Off</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SetWith</simpara></entry>
<entry align="left" valign="top"><simpara>Evaluates an expression and assigns the result</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FnLSL</simpara></entry>
<entry align="left" valign="top"><simpara>Performs a Bitwise LEFT shift</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>FnLSR</simpara></entry>
<entry align="left" valign="top"><simpara>Performs a Bitwise RIGHT shift</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate</simpara></entry>
<entry align="left" valign="top"><simpara>Performs a rotation of a variable of one bit in a specified direction</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">For more help, see: <link linkend="_set">Set</link>, <link linkend="_setwith">SetWith</link>, <link linkend="_fnlsl">FnLSL</link>, <link linkend="_fnlsr">FnLSR</link> and <link linkend="_rotate">Rotate</link></emphasis></simpara>
</section>
<section xml:id="_fnlsl">
<title>FnLSL</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    BitsOut = FnLSL(BitsIn, NumBits)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>FnLSL</literal> (Logical Shift Left) will perform a Bitwise left shift.
<literal>FnLSL</literal> will return BitsIn shifted NumBits to the left, it is equivalent to the 'C' operation:</simpara>
<screen>    BitsOut = BitsIn &lt;&lt; NumBits</screen>
<simpara>Each left shift is the equivalent of multiplying BitsIn by 2.
BitsIn and NumBits may be may be a variable and of  type: Bit, Byte, Word, Long, Constant or another Function.
Zeros are shifted in from the right, Bits that are shifted out are lost.</simpara>
<simpara>It is useful for mathematical and logical operations, as well as creating serial data streams or manipulating I/O ports.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This program will shift the LEDs on the Microchip PIC Low Pin
    ' Count Demo Board from Right to Left, that is DS1(RC0) to
    ' DS4(RC3) and repeat

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b0001       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
        LEDMask = FnLSL(LEDMask, 1) &amp; 0x0F    ' Mask the lower 4 bits
        if LEDPORT.3 then LEDMask.0 = 1       ' Restart the sequence
        LEDPORT = LEDMask                     ' Display the Pattern
        wait 500 ms
    Loop
    End</screen>
<simpara><emphasis role="strong">See Also <link linkend="_bitwise_operations_overview">Bitwise Operations Overview</link></emphasis> and <emphasis role="strong"><link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_fnlsr">
<title>FnLSR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    BitsOut = FnLSR(BitsIn, NumBits)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>FnLSR</literal> (Logical Shift Right) will perform a Bitwise right shift. <literal>FnLSR</literal> will return BitsIn shifted NumBits to the right, it is equivalent to the 'C' operation:</simpara>
<screen>    BitsOut = BitsIn &gt;&gt; NumBits</screen>
<simpara>Each right shift is the equivalent of dividing BitsIn by 2.</simpara>
<simpara>BitsIn and NumBits may be may be a variable and of  type: Bit, Byte, Word, Long, Constant or another Function.</simpara>
<simpara>Zeros are shifted in from the left, Bits that are shifted out are lost.</simpara>
<simpara>It is useful for mathematical and logical operations, as well as creating serial data streams or manipulating I/O ports.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This program will shift the LEDs on the Microchip PIC Low Pin Count Demo Board
    ' from Right to Left, that is DS4(RC3) to DS1(RC0) and repeat.

    #chip    16f690        ' declare the target Device

    #define  LEDPORT PORTC ' LEDs on pins 16, 15, 14 and 7

    Dim LEDMask as Byte    ' Pattern to be displayed
    LEDMask = 0b1000       ' Initialise the Patten
    Dir LEDPORT Out        ' Enable the LED Port.

    Do
      LEDPORT = LEDMask    ' Display the Pattern
      wait 500 ms
      LEDMask = FnLSR(LEDMask, 1) &amp; 0x0F ' Mask the lower 4 bits
      if LEDPORT.0 then LEDMask.3 = 1    ' Restart the sequence
    Loop
    End</screen>
<simpara><emphasis role="strong">See Also <link linkend="_bitwise_operations_overview">Bitwise Operations Overview</link></emphasis> and <emphasis role="strong"><link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_setwith">
<title>SetWith</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SetWith(TargetBit, Source)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>SetWith</literal> is an extended version of SET, it allows a Bit Field to be set or cleared by evaluating the content of Source. <literal>SetWith</literal> should always be used when TargetBit is an I/O Bit and Source is a Function, in order to avoid the possibility of I/O jitter.</simpara>
<simpara>Source may be a variable and of  type: Bit, Byte, Word or Long, a Constant, an expression or a Function.</simpara>
<simpara>It will SET  TargetBit  to 1 if Source evaluates to anything other than zero. TargetBit  will always be a 1 or a 0 regardless of the variable type of TargetBit.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This program will reflect the state of SW1(RA3) on LED DS1(RC0) of the Microchip
    ' Low Pin Count Demo Board. Notice that because SW1 is normally High the state has to
    ' be inverted to turn on the LED (DS1) when SW1 is pressed.

    #chip   16f690    ' declare the target Device

    #Define SW1 PORTA.3
    #Define DS1 PORTC.0

    DIR DS1 Out
    DIR SW1 In

    Do
      ' set the Bit DS1 to equal the Bit SW1
      SetWith( DS1, !SW1 )
    Loop
    END</screen>
<simpara><emphasis role="strong">See Also <link linkend="_bitwise_operations_overview">Bitwise Operations Overview</link></emphasis> and <emphasis role="strong"><link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
</section>
<section xml:id="_memory_devices">
<title>Memory Devices</title>
<simpara>This is the Memory section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_eeprom">
<title>Eeprom</title>
<simpara>This is the Eeprom section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_epread">
<title>EPRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    EPRead <emphasis>location, store</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with EEPROM data memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>EPRead</literal> is used to read information from the EEPROM data storage that
many microcontroller chips are equipped with. <literal><emphasis>location</emphasis></literal> represents the
location to read data from, and varies from one chip to another. <literal><emphasis>store</emphasis></literal>
is the variable in which to store the data after it has been read from
EEPROM.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Program to turn a light on and off
    'Will remember the last status

    #chip tiny2313, 1
    #define Button PORTB.0
    #define Light PORTB.1

    Dir Button In
    Dir Light Out

    'Load saved status
    EPRead 0, LightStatus

    If LightStatus = 0 Then
      Set Light Off
    Else
      Set Light On
    End If

    Do
      'Wait for the button to be pressed
      Wait While Button = On
      Wait While Button = Off
      'Toggle value, record
      LightStatus = !LightStatus
      EPWrite 0, LightStatus

      'Update light
      If LightStatus = 0 Then
        Set Light Off
      Else
        Set Light On
      End If
    Loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_epwrite">EPWrite</link></emphasis></simpara>
</section>
<section xml:id="_epwrite">
<title>EPWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    EPWrite <emphasis>location</emphasis>, <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with EEPROM data memory.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>EPWrite</literal> is used to write information to the EEPROM data storage, so that
it can be accessed later by a programmer on the PC, or by the <literal>EPRead</literal>
command. <literal><emphasis>location</emphasis></literal> represents the location to read data from, and varies
from one chip to another. <literal><emphasis>data</emphasis></literal> is the data that is to be written to the
EEPROM, and can be a value or a variable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16F819, 8
    #config osc = int

    'Set the input pin direction
    Dir PORTA.0 In

    'Loop to take readings until the EEPROM is full
    For CurrentAddress = 0 to 255

    'Take a reading and log it
    EPWrite CurrentAddress, ReadAD(AN0)

    'Wait 10 minutes before getting another reading
    Wait 10 min

    Next</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_epread">EPRead</link></emphasis></simpara>
</section>
<section xml:id="_programerase">
<title>ProgramErase</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ProgramErase (<emphasis>location</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ProgramErase</literal> erases information from the program memory on chips that
support this feature. The largest value possible for <literal><emphasis>location</emphasis></literal> depends
on the amount of program memory on the Microchip PIC microcontroller, which is given on the
datasheet.</simpara>
<simpara>This command must be called before writing to a block of memory. It is
slow in comparison to other Great Cow BASIC commands. Note that it erases memory
in 32-byte blocks - see the relevant Microchip PIC microcontroller datasheet for more information.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers. Care must be taken with this command, as it can easily erase
the program that is running on the microcontroller.</simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_programread">ProgramRead</link></emphasis> and <emphasis role="strong"><link linkend="_programwrite">ProgramWrite</link></emphasis></simpara>
</section>
<section xml:id="_programread">
<title>ProgramRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ProgramRead (<emphasis>location, store</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ProgramRead</literal> reads information from the program memory on chips that
support this feature. <literal><emphasis>location</emphasis></literal> and <literal><emphasis>store</emphasis></literal> are both word variables,
meaning that they can store values over 255.</simpara>
<simpara>The largest value possible for <literal><emphasis>location</emphasis></literal> depends on the amount of
program memory on the Microchip PIC microcontroller, which is given on the datasheet. <literal><emphasis>store</emphasis></literal> is
14 bits wide, and thus can store values up to <literal>16383</literal>.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_programerase">ProgramErase</link></emphasis> and <emphasis role="strong"><link linkend="_programwrite">ProgramWrite</link></emphasis></simpara>
</section>
<section xml:id="_programwrite">
<title>ProgramWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ProgramWrite (<emphasis>location</emphasis>, <emphasis>value</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC microcontrollers with self write capability. Not available on
Atmel AVR at present.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ProgramWrite</literal> writes information to the program memory on chips that
support this feature. <literal><emphasis>location</emphasis></literal> and <literal><emphasis>value</emphasis></literal> are both word variables.</simpara>
<simpara>The largest value possible for <literal><emphasis>location</emphasis></literal> depends on the amount of
program memory on the microcontroller , which is given on the datasheet. <literal><emphasis>value</emphasis></literal> is
14 bits wide, and thus can store values up to 16383.</simpara>
<simpara>This is an advanced command which should only be used by advanced
developers. ProgramErase must be used to clear a block of memory BEFORE
<literal>ProgramWrite</literal> is called.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_programerase">ProgramErase</link></emphasis> and <emphasis role="strong"><link linkend="_programread">ProgramRead</link></emphasis></simpara>
</section>
</section>
<section xml:id="_hefm">
<title>Hefm</title>
<simpara>This is the Hefm section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_hefm_overview">
<title>HEFM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>Several members of the Microchip PIC microcontroller family, including the 16F14xx, 16F15xx and 16F17xx have replaced the
data EEPROM present on older models with a block of Flash memory that is designed to provide the same high
endurance (100K erase/write cycles).</simpara>
<simpara>This high endurance flash memory (HEFM) is a block of 128 locations found at the top of the Flash program memory.
Each location can only be used to hold a byte variable (whereas the standard Flash memory for a mid-range Microchip PIC microcontroller
will typically hold 14 bits of information).</simpara>
<simpara>The main difference between EEPROM and HEFM is that the former does allow byte-by-byte erase whereas the latter
does not. With HEFM data must be erased before a write and this can only be performed in blocks
(also referred to as rows) of a fixed size associated with the chip design.</simpara>
<simpara>The <literal>heflash.h</literal> library uses as an input the following variables which are available from the chips *.dat files supporting HEFM.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="54*"/>
<colspec colname="col_3" colwidth="170*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Variable Name</simpara></entry>
<entry align="center" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Content</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFLASH_ROWSIZE</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Byte</simpara></entry>
<entry align="left" valign="top"><simpara>Size of an HEFM block in words</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFLASH_START</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Starting address of HEFM</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HEFLASH_END</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Word</simpara></entry>
<entry align="left" valign="top"><simpara>Ending address of HEFM</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Caution</emphasis></simpara>
<simpara>Whenever you update the hex file of your Microchip PIC microcontroller with your programmer you will erase the data that are stored in HEFM.
If you want to avoid that you will have to flash your Microchip PIC microcontroller with software that allows memory exclusion when flashing.
This is the case with Microchip PIC MPLAB IPE (Go to <literal>Advanced Mode/Enter password/Select Memory/Tick “Preserve Flash on Program”/
Enter Start and End address</literal> of your HEFM).</simpara>
</section>
<section xml:id="_hefreadblock">
<title>HEFreadBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFreadBlock(<emphasis>buffer()</emphasis>, <emphasis>Flash_row</emphasis>, <emphasis>count</emphasis>)</screen>
<simpara><emphasis role="strong">Command availability:</emphasis></simpara>
<simpara>Available on specific Microchip PIC microcontrollers only. Check your datasheet.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal><emphasis>Buffer()</emphasis></literal> is the destination byte array (must be sufficiently large)<?asciidoc-br?>
<literal><emphasis>Flash_row</emphasis></literal> is the HEFM relative location (i.e. the row number)<?asciidoc-br?>
<literal><emphasis>Count</emphasis></literal> is the number of bytes to be retrieved</simpara>
<simpara>HEFreadBlock reads information from the HEFM on chips that support this feature. <literal>buffer</literal> is a byte array of length equal to <literal>count</literal>.
Reading starts at the beginning of given row number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16F1509, 8
    'The following example reads a byte vector
    'from row 0 of the HEFM of the 16F1509
    dim data(32)
    HEFreadBlock(data,0,HEFLASH_ROWSIZE)</screen>
</section>
<section xml:id="_hefread">
<title>HEFRead</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFRead(<emphasis>HEFaddress</emphasis>, <emphasis>HEFDataValue</emphasis>)</screen>
<simpara><emphasis role="strong">Command availability:</emphasis></simpara>
<simpara>Available on specific Microchip PIC microcontrollers only. Check your datasheet.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal><emphasis>HEFaddress</emphasis></literal> is the HEFM relative location in the whole HEFM area (i.e. a number generally comprised between 0 and 127)<?asciidoc-br?>
<literal><emphasis>HEFDataValue</emphasis></literal> is the byte data being retrieved</simpara>
<simpara>This subroutine reads information from the HEFM given its relative number in the whole HEFM area.
It is the equivalent of the <link linkend="_epread">EPRead</link> subroutine for EEPROM.
The subroutine will compute the row number and the offset in the row from HEFaddress and HEFLASH_ROWSIZE.
It will then call the HEFreadBlock subroutine to retrieve the byte data.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16F1509, 8
    'The following example stores in the byte variable “value” the
    'HEFM byte variable located in row 1 at offset 2
    HEFRead(34,value)</screen>
</section>
<section xml:id="_hefwriteblock">
<title>HEFwriteBlock</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFwriteBlock(<emphasis>Flash_row</emphasis>, <emphasis>buffer()</emphasis>, <emphasis>count</emphasis>)</screen>
<simpara><emphasis role="strong">Command availability:</emphasis></simpara>
<simpara>Available on specific Microchip PIC microcontrollers only. Check your datasheet.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal><emphasis>Flash_row</emphasis></literal> is the HEFM relative location (i.e. the row number)<?asciidoc-br?>
<literal><emphasis>Buffer()</emphasis></literal> is the source byte array<?asciidoc-br?>
<literal><emphasis>Count</emphasis></literal> is the number of bytes to be copied</simpara>
<simpara>HEFwriteBlock writes information to the HEFM on chips that support this feature. <literal>buffer</literal> is a byte array of length equal to <literal>count</literal>.
Writing starts at the beginning of the given row number.</simpara>
<simpara><emphasis role="strong">WARNING:</emphasis></simpara>
<simpara>Be aware that this subroutine will first erase whatever data are present on the destination row.
If you want to preserve them check the HEFwrite subroutine.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16F1509, 8
    'The following example generates a byte vector and stores it
    'in row 0 of the HEFM of the 16F1509
    dim data(32)
    for index = 1 to 32
      data(index)=index
    next
    HEFwriteBlock(0,data,HEFLASH_ROWSIZE)

    'Now we store a string in row 1
    Dim Hello as String
    Hello="Hello GCB World!"
    HEFwriteBlock(1,Hello,len(Hello))</screen>
</section>
<section xml:id="_hefwrite">
<title>HEFWrite</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HEFWrite(<emphasis>HEFaddress</emphasis>, <emphasis>HEFDataValue</emphasis>)</screen>
<simpara><emphasis role="strong">Command availability:</emphasis></simpara>
<simpara>Available on specific Microchip PIC microcontrollers only. Check your datasheet.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal><emphasis>HEFaddress</emphasis></literal> is the HEFM relative location in the whole HEFM area (i.e. a number generally comprised between 0 and 127)<?asciidoc-br?>
<literal><emphasis>HEFDataValue</emphasis></literal> is the byte data being retrieved</simpara>
<simpara>This subroutine writes information to the HEFM given its relative number in the whole HEFM area.
It is the equivalent of the <link linkend="_epwrite">EPWrite</link> subroutine for EEPROM.
The subroutine will compute the row number and the offset in the row from <literal>HEFaddress</literal> and HEFLASH_ROWSIZE.
It will then call the HEFWriteBlock subroutine to store the byte data.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16F1509, 8
    'The following example stores in the byte variable “value” the
    'HEFM byte variable located in row 1 at offset 2
    HEFWrite(34,value)</screen>
</section>
</section>
<section xml:id="_eeram">
<title>EERAM</title>
<simpara>This is the EERAM section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_47xxx_eeram_devices">
<title>47xxx EERam Devices</title>
<simpara>This section covers the 47xxx EERam devices.</simpara>
<simpara>The 47xxx EERam device is a memory device is organized as 512 x 8 bits or 2,048 x 8 bits of memory and utilizes the I2C serial interface.</simpara>
<simpara>The 47xxx provides infinite read and write cycles to the SRAM while EEPROM cells provide
high-endurance nonvolatile storage of data with more than one million store cycles to EEPROM &amp; a Data retention of &gt; 200 years.</simpara>
<simpara>With an external capacitor (~10uF), SRAM data is automatically transferred to the EEPROM upon loss of power, giving the advantages of NVRAM whilst eliminating the need for backup batteries.</simpara>
<simpara>Data can also be backed up manually by using either the Hardware Store pin (HS) or software control.</simpara>
<simpara>On power-up, the EEPROM data is automatically recalled to the SRAM.   EEPROM data Recall can also be initiated through software control.</simpara>
<simpara>Connectivity is shown below:</simpara>
<screen>            __ __
    Vcap--&gt;|  U  |&lt;-- Vcc
     A1 --&gt;|     |&lt;-- HS
     A2 --&gt;|     |&lt;-&gt; SCL
    Vss --&gt;|_____|&lt;-&gt; SDA</screen>
<simpara><emphasis role="strong">Modes of Operation</emphasis></simpara>
<simpara>The SRAM allows for fast reads and writes and unlimited
endurance. As long as power is present, the data
stored in the SRAM can be updated as often as
desired.</simpara>
<simpara>To preserve the SRAM image, the AutoStore function
copies the entire SRAM image to an EEPROM array
whenever it detects that the voltage drops below a predetermined
level. The power for the AutoStore process
is provided by the externally connected VCAP capacitor.
Upon power-up, the entire memory contents are
restored by copying the EEPROM image to the SRAM.
This automatic restore operation is completed in milliseconds
after power-up, at the same time as when
other devices would be initializing.</simpara>
<simpara>There is no latency in writing to the SRAM. The SRAM
can be written to starting at any random address, and
can be written continuously throughout the array, wrapping
back to the beginning after the end is reached.
There is a small delay, specified as TWC in the data
sheet, when writing to the nonvolatile configuration bits
of the STATUS Register (SR).</simpara>
<simpara>Besides the AutoStore function, there are two other
methods to store the SRAM data to EEPROM:</simpara>
<simpara>• One method is the Hardware Store, initiated by a
rising edge on the HS pin.</simpara>
<simpara>• The other method is the Software Store, initiated
by writing the correct instruction to the
command register via I2C.</simpara>
<simpara><subscript>The_paragraph_above_is_copyright_Microchip:_AN2047</subscript><?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation</emphasis></simpara>
<simpara>The Great Cow BASIC constants and commands shown below control the configuration of the 47xxx EE-RAM device. &#160;&#160;&#160;Great Cow BASIC supports I2C hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the 47xxx driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;47xxx_EERAM.H&gt;

    ; ----- Define Hardware settings for EERAM Module
    #define I2C_Adr_EERAM 0x30 		; EERAM base Address
    #define EERAM_HS PortB.1   		; Optional hardware Store Pin

    Dir EERAM_HS Out           		; Rising edge initiates Backup

    EERAM_AutoStore(ON) 			; Enable Automatic Storage on power loss


    'EERAM_AutoStore(OFF) 			; Disable Automatic Storage on power loss</screen>
<simpara>The device parameters for the device are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="6">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="16*"/>
<colspec colname="col_3" colwidth="16*"/>
<colspec colname="col_4" colwidth="16*"/>
<colspec colname="col_5" colwidth="16*"/>
<colspec colname="col_6" colwidth="16*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Part Number</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Density (bits)</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">VCC Range</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Max. I2C Frequency</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Tstore Delay</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Trecall Delay</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>47L04</simpara></entry>
<entry align="left" valign="top"><simpara>4K</simpara></entry>
<entry align="left" valign="top"><simpara>2.7-3.6V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>8ms</simpara></entry>
<entry align="left" valign="top"><simpara>25ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47C04</simpara></entry>
<entry align="left" valign="top"><simpara>4K</simpara></entry>
<entry align="left" valign="top"><simpara>4.5-5.5V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>8ms</simpara></entry>
<entry align="left" valign="top"><simpara>2ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47L16</simpara></entry>
<entry align="left" valign="top"><simpara>16K</simpara></entry>
<entry align="left" valign="top"><simpara>2.7-3.6V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>25ms</simpara></entry>
<entry align="left" valign="top"><simpara>5ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47C16</simpara></entry>
<entry align="left" valign="top"><simpara>16K</simpara></entry>
<entry align="left" valign="top"><simpara>4.5-5.5V</simpara></entry>
<entry align="left" valign="top"><simpara>1 MHz</simpara></entry>
<entry align="left" valign="top"><simpara>25ms</simpara></entry>
<entry align="left" valign="top"><simpara>5ms</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control of the device are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Context</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>EERAM_I2C_Adr</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit I2C Address of device</simpara></entry>
<entry align="left" valign="top"><simpara>#define I2C_Adr_EERAM 0x30</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0x30. This is mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_HS</simpara></entry>
<entry align="left" valign="top"><simpara>Optional hardware Store Pin</simpara></entry>
<entry align="left" valign="top"><simpara>#define EERAM_HS portb.1</simpara></entry>
<entry align="left" valign="top"><simpara>No default - this is not mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Tstore</simpara></entry>
<entry align="left" valign="top"><simpara>Delay period for write to device</simpara></entry>
<entry align="left" valign="top"><simpara>#define EERAM_Tstore 25</simpara></entry>
<entry align="left" valign="top"><simpara>25 (ms)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Trecall</simpara></entry>
<entry align="left" valign="top"><simpara>Delay period to read from device</simpara></entry>
<entry align="left" valign="top"><simpara>#define EERAM_Trecall  5</simpara></entry>
<entry align="left" valign="top"><simpara>5 (ms)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands for control of the device are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Context</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>EERAM_AutoStore</simpara></entry>
<entry align="left" valign="top"><simpara>Enable Automatic Storage on power loss or Disable Automatic Storage on power loss</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_AutoStore(ON), or EERAM_AutoStore(OFF)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Status</simpara></entry>
<entry align="left" valign="top"><simpara>Read the Status Register</simpara></entry>
<entry align="left" valign="top"><simpara>User_byte_variable = EERAM_Status()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Backup</simpara></entry>
<entry align="left" valign="top"><simpara>Backup / Store Now</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_Backup()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Recall</simpara></entry>
<entry align="left" valign="top"><simpara>Restore Now</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_Recall()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_HWStore</simpara></entry>
<entry align="left" valign="top"><simpara>Force Backup with HS Pin</simpara></entry>
<entry align="left" valign="top"><simpara>EERAM_HWStore()</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Write</simpara></entry>
<entry align="left" valign="top"><simpara>Write a Byte of Data to address at the specified address.  The address must be a word value and the data is byte value.</simpara></entry>
<entry align="left" valign="top"><simpara>ERAM_Write( EERAM_Address_word, EERAM_Data_byte)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>EERAM_Read</simpara></entry>
<entry align="left" valign="top"><simpara>Read a Byte of Data from address.  The address must be a word value and returned data is byte value.</simpara></entry>
<entry align="left" valign="top"><simpara>User_byte_variable = EERAM_Read(EERAM_Address_word)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This example shows how to use the device.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    '
    #chip 16f18855,32
    #option explicit

    #include &lt;47xxx_EERAM.H&gt;

    #startup InitPPS, 85

    Sub InitPPS
      UNLOCKPPS

          'Module: EUSART
              RC0PPS = 0x0010 'TX &gt; RC0
              TXPPS  = 0x0008 'RC0 &gt; TX (bi-directional)
          'Module: MSSP1
              SSP1DATPPS = 0x0013 'RC3 &gt; SDA1
              RC3PPS = 0x0015 'SDA1 &gt; RC3 (bi-directional)
              RC4PPS = 0x0014 'SCL1 &gt; RC4
              SSP1CLKPPS = 0x0014 'RC4 &gt; SCL1 (bi-directional)

      LOCKPPS
    End Sub

    ; ----- Define Hardware Serial Print

    #define USART_BAUD_RATE 115200
    #define USART_TX_BLOCKING

    ; ----- Define Hardware settings for hwi2c

    #define hi2c_BAUD_RATE 1024
    #define hi2c_DATA  PORTC.3
    #define hi2c_CLOCK PORTC.4

    'I2C pins need to be input for I2C module
    Dir hi2c_DATA  in
    Dir hi2c_CLOCK in

    'Initialise I2C Master
    hi2cMode Master

    ; ----- Define Hardware settings for EERAM Module

    #define EERAM_I2C_Adr 0x30     ; EERAM base Address
    #define EERAM_HS PortB.1       ; Optional hardware Store Pin

    Dir EERAM_HS Out           ; Rising edge initiates Backup

    EERAM_AutoStore(ON) ; Enable Automatic Storage on power loss

    ; ----- Main body of program commences here.

    dim Idx as Byte

    HserPrintCRLF 2

    HserPrint "Hardware I2C EERAM Read Test at I2C Adr 0x"
    HserPrint  Hex(EERAM_I2C_Adr)
    HserPrint  " Reading RAM addresses 0x0 to 0xF" : HserPrintCRLF 2

    for Idx = 0x0 to 0xF

    HserPrint hex(Idx) + " = " : HserPrint Hex(EERAM_Read(Idx))

    if Idx = 7 or Idx = 0xf then
      HserPrintCRLF
    Else
      HserPrint " : "
    end if

    next Idx

    HserPrintCRLF : HserPrint "Control Byte = " Hex(EERAM_Status()) : HserPrintCRLF 2

    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_i2c_overview">Software I2C</link> or <link linkend="_hi2c_overview">Hardware I2C</link></simpara>
</section>
</section>
</section>
<section xml:id="_flow_control">
<title>Flow control</title>
<simpara>This is the Flow control section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_do">
<title>Do</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Do [{While | Until} <emphasis>condition</emphasis>]
    ...
    <emphasis>program code</emphasis>
    ...
    <emphasis>&lt;condition&gt;</emphasis> Exit Do
    ...
    Loop [{While | Until} <emphasis>condition</emphasis>]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Do</literal> command will cause the code between the <literal>Do</literal> and the <literal>Loop</literal> to run
repeatedly while <literal><emphasis>condition</emphasis></literal> is true or until <literal><emphasis>condition</emphasis></literal> is true,
depending on whether <literal>While</literal> or <literal>Until</literal> has been specified.</simpara>
<simpara>Note that the <literal>While</literal> or <literal>Until</literal> and the condition can only be specified
once, or not at all. If they are not specified, then the code will
repeat endlessly.</simpara>
<simpara>Optionally, you can specify a condition to <literal>EXIT</literal> the <literal>Do-Loop</literal> immediately.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This code will flash a light until the button is pressed
    #chip 12F629, 4
    #config osc = int

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do Until BUTTON = 1
    	PulseOut LIGHT, 1 s
    	Wait 1 s
    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This code will also flash a light until the button is pressed. This
example uses <literal>EXIT DO</literal> within a continuous loop.</simpara>
<screen>    #chip 12F629, 4
    #config osc = int

    #define BUTTON GPIO.3
    #define LIGHT GPIO.5

    Dir BUTTON In
    Dir LIGHT Out

    Do
    	PulseOut LIGHT, 1 s
    	Wait 1 s
    	if BUTTON = 1 then EXIT DO
    Loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_end">
<title>End</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    End</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>When the <literal>End</literal> command is used, the program will immediately stop running.
There are very few cases where this command is needed - generally, the
program should be an endless loop.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will turn on the red light, but not the green light
    Set RED On
    End
    Set GREEN On</screen>
</section>
<section xml:id="_exit">
<title>Exit</title>
<simpara><emphasis role="strong">Syntax options:</emphasis></simpara>
<screen>    Exit Sub | Exit Function | Exit Do | Exit For | Exit Repeat</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will make the program exit the routine it is currently in,
as it would if it came to the end of the routine.</simpara>
<simpara>Applies to Subroutines, Functions, For-Next loops, Do-Loop loops and
Repeat loops.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip tiny13, 1

    #define SENSOR PORTB.0
    #define BUZZER PORTB.1
    #define LIGHT PORTB.2
    Dir SENSOR In
    Dir BUZZER Out
    Dir LIGHT Out

    Do
      Burglar
    Loop

    'Burglar Alarm subroutine
    Sub Burglar
      If SENSOR = 0 Then
        Set BUZZER Off
        Set LIGHT Off
        Exit Sub
      End If
      Set BUZZER On
      Set LIGHT On
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_do">Do</link>, <link linkend="_for">For</link>, <link linkend="_subroutines">Sub</link>,
<link linkend="_functions">Functions</link></emphasis> and <emphasis role="strong"><link linkend="_repeat">Repeat</link></emphasis></simpara>
</section>
<section xml:id="_for">
<title>For</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    For <emphasis>counter</emphasis> = <emphasis>start</emphasis> To <emphasis>end</emphasis> [Step <emphasis>increment</emphasis>]
    ...
    <emphasis>program code</emphasis>
    ...
    &lt;<emphasis>condition</emphasis>&gt; Exit For
    ...
    Next</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The For command is ideal for situations where a piece of code needs to
be run a set number of times, and where it is necessary to keep track of
how many times the code has run. When the For command is first executed,
<literal><emphasis>counter</emphasis></literal> is set to <literal><emphasis>start</emphasis></literal>. Then, each successive time the program
loops, <literal><emphasis>increment</emphasis></literal> is added to <literal><emphasis>counter</emphasis></literal>, until <literal><emphasis>counter</emphasis></literal> is equal to
<literal><emphasis>end</emphasis></literal>. Then, the program continues beyond the Next.</simpara>
<simpara><literal><emphasis>Step</emphasis></literal> and <literal><emphasis>increment</emphasis></literal> are optionals. If Step is not specified, Great Cow BASIC
will increment <literal><emphasis>counter</emphasis></literal> by 1 each time the code is run.</simpara>
<simpara>The <literal>Exit For</literal> is optional and can be used to exit the loop upon a specific
condition.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This code will flash a green light 6 times.

    #chip 16F88, 8
    #config Osc = Int

    #define LED PORTB.0
    Dir LED Out

    For LoopCounter = 1 to 6
    	PulseOut Led, 1 s
    	Wait 1 s
    Next</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>'This code will flash alternate LEDS until the switch is pressed.

    #chip 16F88, 8
    #config Osc = Int

    #define LED1 PORTB.0
    Dir LED1 Out
    #define LED2 PORTB.2
    Dir LED2 Out

    #define SWITCH1 PORTA.0
    Dir SWITCH1 In
    main:
    PulseOut LED1, 1 s
    For LoopCounterOut = 1 to 250
    	PulseOut LED2, 4 Ms
    	if switch = On then Exit For
    Next
    Set LED2 OFF
    goto main</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_repeat">Repeat</link></emphasis></simpara>
</section>
<section xml:id="_gosub">
<title>Gosub</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Gosub <emphasis>label</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Gosub</literal> command is used to jump to a label as a subroutine, in a
similar way to <literal>Goto</literal>. The difference is that <literal>Return</literal> can then be used to
return to the line of code after the <literal>Goto</literal>.</simpara>
<simpara><emphasis role="strong">NOTE</emphasis></simpara>
<simpara><literal>Gosub</literal> should NOT be used if it can be avoided. It is not
required to call a subroutine that has been defined using
<link linkend="_subroutines">Sub</link>, just write the name of the subroutine.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will flash an LED on portb bit 0 and play a beep on
    'porta bit 4. until the robot is turned off.

    #chip 16F628A, 4 'Change this to suit your circuit

    #define SOUNDOUT PORTA.4
    #define LIGHT PORTB.0
    Dir LIGHT Out

    Do
    	'Flash Light
    	PulseOut LIGHT, 1 s
    	Wait 1 s
    	'Beep
    	Gosub PlayBeep
    Loop

    PlayBeep:
    Tone 200, 10
    Tone 100, 10
    Return</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_goto">Goto</link></emphasis> and <emphasis role="strong"><link linkend="_labels">Labels</link></emphasis></simpara>
</section>
<section xml:id="_goto">
<title>Goto</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Goto <emphasis>label</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Goto</literal> command will make the robot jump to the line specified, and
continue running the program from there. The <literal>Goto</literal> command is mainly
useful for exiting out of loops - if you need to create an infinite
loop, use the <literal>Do</literal> command instead.</simpara>
<simpara>Be careful how you use <literal>Goto</literal>. If used too much, it can make programs very
hard to read.</simpara>
<simpara>To define a label, put the name of the label alone on a line, with just
a colon (:) after it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will flash the light until the button is pressed
    'off. Notice the label named SWITCH_OFF.

    #chip 16F628A, 4 'Change this line to suit your circuit

    #define BUTTON PORTB.0
    #define LIGHT PORTB.1
    Dir BUTTON In
    Dir BUTTON Out

    Do
    	PulseOut LIGHT, 500 ms
    	If BUTTON = 1 Then Goto SWITCH_OFF
    	Wait 500 ms
    	If BUTTON = 1 Then Goto SWITCH_OFF
    Loop

    SWITCH_OFF:
    Set LIGHT Off
    'Chip will enter low power mode when program ends</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_gosub">Gosub</link></emphasis> and <emphasis role="strong"><link linkend="_labels">Labels</link></emphasis></simpara>
</section>
<section xml:id="_if">
<title>If</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen><emphasis role="strong"><emphasis>Short form:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then <emphasis>command</emphasis>

<emphasis role="strong"><emphasis>Long form:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then
    ...
    <emphasis>program code</emphasis>
    ...
    End If

<emphasis role="strong"><emphasis>Using Else:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then
      <emphasis>code to run if true</emphasis>
    Else
      <emphasis>code to run if false</emphasis>
    End If

<emphasis role="strong"><emphasis>Using If Else:</emphasis></emphasis>

    If <emphasis>condition</emphasis> Then
      <emphasis>code to run if true</emphasis>
    Else if <emphasis>nextcondition</emphasis> then
      <emphasis>code to run if nextcondition true</emphasis>
    Else
      <emphasis>code to run if false</emphasis>
    End If</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>If</literal> command is the most common command used to make decisions. If
<literal><emphasis>condition</emphasis></literal> is <literal>true</literal>, then <literal><emphasis>command</emphasis></literal> (short) or <literal><emphasis>program code</emphasis></literal> (long)
will be run. If it is <literal>false</literal>, then the robot will skip to the code
located on the next line (short) or after the <literal>End If</literal> (long form).</simpara>
<simpara>If <literal>Else</literal> is used, then the condition between <literal>If</literal> and <literal>Else</literal> will run if the
condition is <literal>true</literal>, and the code between <literal>Else</literal> and <literal>End If</literal> will run if the
condition is <literal>false</literal>.</simpara>
<simpara>If <literal>Else if</literal> is used, then the condition after the  <literal>Else if</literal> will run if the
condition is <literal>true</literal>.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
<literal>Else</literal> must be on a separate line in the source code.</simpara>
<simpara>Supported:</simpara>
<screen>    &lt;instruction&gt; 'is supported
    Else
    &lt;instruction&gt;</screen>
<screen>    &lt;instruction&gt; Else 'Not Supported, but will compile
    &lt;instruction&gt;</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Turn a light on or off depending on a light sensor

    #chip 12F683, 8
    #config osc = int

    #define LIGHT GPIO.1
    #define SENSOR AN3
    #define SENSOR_PORT GPIO.4

    Dir LIGHT Out
    Dir SENSOR_PORT In

    Do
    	If ReadAD(SENSOR) &gt; 128 Then
    		Set LIGHT Off
    	Else
    		Set LIGHT On
    	End If
    Loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
<section xml:id="_indcall">
<title>IndCall</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    IndCall <emphasis>Address</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>IndCall</literal> provides a basic implementation of function pointers. <literal><emphasis>Address</emphasis></literal>
is the program memory location of the subroutine that is to be called.
There are two ways to specify this - either by providing a direct
reference to the subroutine using the @ operator, or by specifying a
word variable that contains the address.</simpara>
<simpara>This command is useful for callbacks. For example, a particular
subroutine might read bytes from a serial connection, but different
actions may need to be taken at different times. A different subroutine
could be created for each action, and then the subroutine for the
appropriate action could be passed to the serial connection reading
routine each time it is called.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Calling subroutines that have parameters using <literal>IndCall</literal> is not
supported. Errors may occur. If data needs to be passed, use a variable
instead.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Flash an LED using an indirect call
    #chip 12F683

    'Create a word variable, and set it to the memory location of the
    'Blink subroutine.
    Dim FlashingSub As Word
    FlashingSub = @Blink

    'Main loop
    Do
    'Indirect call to subroutine at location FlashingSub
    	IndCall FlashingSub
    Loop

    'LED flashing subroutine
    Sub Blink
    	PulseOut GPIO.0, 500 ms
    	Wait 500 ms
    End Sub</screen>
</section>
<section xml:id="_pause">
<title>Pause</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen><emphasis role="strong"><emphasis>Fixed Length Delay:</emphasis></emphasis>
    Pause time_ms</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Pause command will cause the program to pause for a specified time in milliseconds.
The only unit of time permitted is milliseconds.</simpara>
<simpara>Please use the <literal>wait</literal> command to use other units of time.</simpara>
<simpara><emphasis role="strong">For more help, see <link linkend="_wait">Wait</link></emphasis></simpara>
</section>
<section xml:id="_repeat">
<title>Repeat</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Repeat <emphasis>times</emphasis>
    ...
    <emphasis>program code</emphasis>
    ...
    &lt;<emphasis>condition</emphasis>&gt; Exit Repeat
    ...
    End Repeat</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Repeat</literal> command is ideal for situations where a piece of code needs
to be run a set number of times. It uses less memory and runs faster
than the <literal>For</literal> command, and should be used wherever it is not necessary to
count how many times the code has run.</simpara>
<simpara>Optionally, you can specify a condition to <literal>Exit</literal> the Repeat-Loop
immediately.</simpara>
<simpara>Repeat has a maximum repeat value of 65535.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This code will flash a green light 6 times.

    #chip 16F88, 20

    #define LED PORTB.0
    dir LED out

    Repeat 6
    PulseOut LED, 1 s
    Wait 1 s
    End Repeat</screen>
<simpara><emphasis role="strong">See Also <link linkend="_for">For</link></emphasis></simpara>
</section>
<section xml:id="_select">
<title>Select</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Select Case <emphasis>var</emphasis>

    Case <emphasis>value1</emphasis>
    	<emphasis>code1</emphasis>

    Case <emphasis>value2</emphasis>
    	<emphasis>code2</emphasis>

    Case Else
    	<emphasis>code3</emphasis>

    End Select</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Select Case control structure is used to select and run a particular
section of code, based on the value of <literal><emphasis>var</emphasis></literal>. If <literal><emphasis>var</emphasis></literal> equals <literal><emphasis>value1</emphasis></literal>
then <literal><emphasis>code1</emphasis></literal> will be run. Once <literal><emphasis>code1</emphasis></literal> has run, the chip will jump to
the <literal>End Select</literal> command and continue running the program. If none of the
other conditions are true, then the code under the <literal>Case Else</literal> section
will be run.</simpara>
<simpara><literal>Case Else</literal> is optional, and the program will function correctly without
it.</simpara>
<simpara>If there is only one line of code after the <literal>Case</literal>, the code may look
neater if the line is placed after the <literal>Case</literal>. This is shown below in the
example, for cases 3, 4 and 5.</simpara>
<simpara>It is important to note that <emphasis role="strong">only one section of code will be run</emphasis> when
using <literal>Select Case</literal>.</simpara>
<simpara>There are two examples shown below.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'Program to read a value from a potentiometer, and display a
    'different word based on the result

    #chip 18F4550, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    DIR PORTA.0 IN
    Do
    	Temp = ReadAD(AN0) / 20
    	CLS
    	Select Case Temp
    		Case 0
    			Print "None!"
    		Case 1
    			Print "One"
    		Case 2
    			Print "Two"
    		Case 3: Print "Three"
    		Case 4: Print "Four"
    		Case 5: Print "Five"
    		Case Else
    			Print "A lot!"
    	End Select
    	Wait 250 ms
    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This code demonstrates how to receive codes from a handheld remote
control unit. This has been tested and supports a Sony TV remote and
also a universal remote set to Sony TV mode.</simpara>
<simpara>The program gets both the device number and the key number, and also
translates the key number to English. The received results are displayed
on an LCD.</simpara>
<simpara>The circuit for the IR receiver and the chip is shown below.</simpara>
<screen>    'A program to receive IR codes sent by a Sony
    'compatible handheld remote control.

    #chip 16F88, 8                    'PIC16F88 running at 8 MHz
    #config mclr=off                  'reset handled internally
    #config osc=int                   'use internal clock

    '----- Constants

    #define LCD_IO      4             '4-bit mode
    #define LCD_RS      PortB.2       'pin 8 is Register Select
    #define LCD_Enable  PortB.3       'pin 9 is Enable
    #define LCD_DB4     PortB.4       'DB4 on pin 10
    #define LCD_DB5     PortB.5       'DB5 on pin 11
    #define LCD_DB6     PortB.6       'DB6 on pin 12
    #define LCD_DB7     PortB.7       'DB7 on pin 13
    #define LCD_NO_RW   1             'ground RW line on LCD
    #define IR          PortA.0       'sensor on pin 17

    '----- Variables

    dim device, cmd, count, i as byte
    dim pulse(12)                     'pulse count array
    dim button as string              'ASCII for button label

    '----- Program

    dir PortA in                      'A.0 is IR input
    dir PortB out                     'B.2 - B.6 for LCD

    cls                               'clear the LCD
    print "Dev:    Cmd:"              'logo for top line
    locate 1,0
    print "Button:"                   'logo for second line

    do
      getIR, cmd                      'wait for IR signal
      printCmd                        'show device and command
      printKey                        'show key label
      wait 10 mS                      'ignore any repeats
    loop                              'repeat forever

    '----- Subroutines

    sub getIR
      tarry1:
        count = 0                     'wait for start bit
        do while IR = 0               'measure width (active low)
          wait 100 uS                 '24 X 100 uS = 2.4 mS
          count += 1
        loop
      if count &lt; 20 then goto tarry1  'less than this so wait

      for i=1 to 12                   'read/store the 12 pulses
        tarry2:
          count = 0
          do while IR = 0             'zero = 6 units = 0.6 mS
            wait 100 uS               'one = 12 units = 1.2 mS
            count += 1
          loop
        if count &lt; 4 then goto tarry2 'too small to be legit
        pulse(i) = count              'else store pulse width
      next

      cmd = 0                         'command built up here
      for i = 1 to 7                  '1st seven bits are the cmd
        cmd = cmd / 2                 'shift into place
        if pulse(i) &gt; 10 then         'longer than 10 mS
           cmd = cmd + 64             'so call it a one
        end if
      next

      device = 0                      'device number built up here
      for i=8 to 12                   'next 5 bits are device number
        device = device / 2
        if pulse(i) &gt; 10 then
           device = device + 16
        end if
      next
    end sub

    sub printCmd            'print device number
      locate 0,5
      print "   "
      locate 0,5
      print device

      locate 0,13           'print raw command number
      print "   "
      locate 0,13
      print cmd
    end sub

    sub PrintKey            'print translated button
      locate 1,9
      print "       "
      locate 1,9

      select case cmd       'translate command code
        case 0
          button = "One"
        case 1
          button = "Two"
        case 2
          button = "Three"
        case 3
          button = "Four"
        case 4
          button = "Five"
        case 5
          button = "Six"
        case 6
          button = "Seven"
        case 7
          button = "Eight"
        case 8
          button = "Nine"
        case 9
          button = "Zero"
        case 10
          button = "#####"
        case 11
          button = "Enter"
        case 12
          button = "#####"
        case 13
          button = "#####"
        case 14
          button = "#####"
        case 15
          button = "#####"
        case 16
          button = "Chan+"
        case 17
          button = "Chan-"
        case 18
          button = "Vol+"
        case 19
          button = "Vol-"
        case 20
          button = "Mute"
        case 21
          button = "Power"
        case else
          button = "     "
      end select
      print button
    end sub</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/selectb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_wait">
<title>Wait</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara><emphasis role="strong"><emphasis>Fixed Length Delay:</emphasis></emphasis></simpara>
<screen>    Wait time units</screen>
<simpara><emphasis role="strong"><emphasis>Conditional Delay:</emphasis></emphasis></simpara>
<screen>    Wait {While | Until} condition</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Wait</literal> command will cause the program to wait for either a specified
amount of time (such as 1 second), or while/until a condition is true.</simpara>
<simpara>When using the fixed-length delay, there is a variety of units that are
available:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Unit</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Length of unit</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Delay range</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>us</simpara></entry>
<entry align="left" valign="top"><simpara>1 microsecond</simpara></entry>
<entry align="left" valign="top"><simpara>1 us - 65535 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10us</simpara></entry>
<entry align="left" valign="top"><simpara>10 microseconds</simpara></entry>
<entry align="left" valign="top"><simpara>10 us - 2.55 ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ms</simpara></entry>
<entry align="left" valign="top"><simpara>1 millisecond</simpara></entry>
<entry align="left" valign="top"><simpara>1 ms - 65535 ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10ms</simpara></entry>
<entry align="left" valign="top"><simpara>10 milliseconds</simpara></entry>
<entry align="left" valign="top"><simpara>10 ms - 2.55 s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>s</simpara></entry>
<entry align="left" valign="top"><simpara>1 second</simpara></entry>
<entry align="left" valign="top"><simpara>1 s - 255 s</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>m</simpara></entry>
<entry align="left" valign="top"><simpara>1 minute</simpara></entry>
<entry align="left" valign="top"><simpara>1 min - 255 min</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>h</simpara></entry>
<entry align="left" valign="top"><simpara>1 hour</simpara></entry>
<entry align="left" valign="top"><simpara>1 hour - 255 hours</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>At one stage, Great Cow BASIC variables could not hold more than 255. The <literal>10us</literal>
and <literal>10ms</literal> units were added as a way to work around this limit. There is
now no such limit (<literal>Wait 1000 ms</literal> will work for example), so these are not
really needed. However, you may see them in some older examples or
programs, and the <literal>10us</literal> units are sometimes the shortest delay that will
work accurately.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This code will wait until a button is pressed, then it will flash
    'a light every half a second and produce a 440 Hz tone.

    #chip 16F819, 8
    #config osc = int

    #define BUTTON PORTB.0
    #define SPEAKER PORTB.1
    #define LIGHT PORTB.2
    Dir BUTTON In
    Dir SPEAKER Out
    Dir LIGHT Out

    'Assumes Button switches on when pressed
    Wait Until BUTTON = 1
    Wait Until BUTTON = 0

    Do
      'Flash the light
      Set LIGHT On
      Wait 500 ms
      Set LIGHT Off

      'Produce the tone
      '440 Hz = 880 changes = tone on for 1.14 ms
      Repeat 440
        PulseOut SPEAKER, 1140 us
        Wait 114 10us 'Wait for 114 x 10 us (1.14 ms)
      End Repeat
    Loop</screen>
<simpara><emphasis role="strong">For more help, see <link linkend="_conditions">Conditions</link></emphasis></simpara>
</section>
</section>
<section xml:id="_fixed_voltage_reference">
<title>Fixed Voltage Reference</title>
<simpara>This is the  Fixed Voltage Reference section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_fvrinitialize">
<title>FVRInitialize</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    FVRInitialize ( FVR_OFF | FVR_1x | FVR_2x | FVR_4x  )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers with the  Fixed Voltage Reference (FVR) module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The method is a subroutine that sets the state of the FVR.&#160;&#160;&#160;</simpara>
<simpara><literal>FVR_Off</literal>&#160;=&#160;&#160;Fixed Voltage Reference is set to OFF</simpara>
<simpara><literal>FVR_1x</literal>&#160;&#160;=&#160; Fixed Voltage Reference is set to 1.024v</simpara>
<simpara><literal>FVR_2x</literal>&#160;&#160;=&#160; Fixed Voltage Reference is set to 2.048v</simpara>
<simpara><literal>FVR_4x</literal>&#160;&#160;=&#160; Fixed Voltage Reference is set to 4.096v</simpara>
<simpara>Using the the following device&#8217;s datasheet, as a general case, &#160;&#160;&#160;<link xlink:href="http://ww1.microchip.com/downloads/en/DeviceDoc/40001419F.pdf">http://ww1.microchip.com/downloads/en/DeviceDoc/40001419F.pdf</link> &#160;&#160;&#160;that can be downloaded from the device&#8217;s page,&#160;&#160;&#160;<link xlink:href="http://www.microchip.com/wwwproducts/en/pic16f1828">http://www.microchip.com/wwwproducts/en/pic16f1828</link>
parameter AD06 in table 30-8 at page 359, and the corresponding Note 4, tell us that the Vref voltage (Vref+ minus Vref-) should not be less than 1.8V, regardless of the reference voltage used, in order for the ADC module to work within the datasheet specifications.
&#160;&#160;Also, as Vref- cannot be a negative voltage (voltages below GND) the lowest voltage on it is 0V. &#160;&#160;Then an FVR of 1.024V cannot be used as VREF+ for the ADC, but only 2.048 and 4.098 values.</simpara>
<simpara>The 1.024V FVR value exists for usage with other modules not just the ADC module.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)

    '// Turn off FVR
    FVRInitialize ( FVR_Off )</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_fvrisoutputready">FVRIsOutputReady</link></simpara>
</section>
<section xml:id="_fvrisoutputready">
<title>FVRIsOutputReady</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    user_var = FVRIsOutputReady()</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers with the  Fixed Voltage Reference (FVR) module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The method is a function that return the state of the FVR.&#160;&#160;&#160;The returned value can be assigned to a variable to used as function.</simpara>
<simpara>The method returns 0 or 1.&#160;&#160;&#160;As follows:</simpara>
<simpara>0 = Fixed Voltage Reference output is not ready or not enabled</simpara>
<simpara>1 = Fixed Voltage Reference output is ready for use</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    '// use FVR 4096 as Reference
    FVRInitialize ( FVR_4x )
    wait while FVRIsOutputReady = false
    ADVal = ReadAd(AN0)</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_fvrinitialize">FVRInitialize</link></simpara>
</section>
</section>
<section xml:id="_interrupts">
<title>Interrupts</title>
<simpara>This is the Interrupt section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_interrupts_overview">
<title>Interrupts overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>Interrupts are a feature of many microcontrollers. They allow the
microcontroller to temporarily pause (interrupt) the code it is running
and then start running another piece of code when some event occurs.
Once it has dealt with the event, it will return to where it was and
continue running the program.</simpara>
<simpara>Many events can trigger an interrupt, such as a timer reaching its
limit, a serial message being received, or a special pin on the
microcontroller receiving a signal.</simpara>
<simpara><emphasis role="strong">Using Interrupts</emphasis></simpara>
<simpara>There are two ways to use interrupts in Great Cow BASIC. The first way is to use
the On Interrupt command. This will automatically enable a given
interrupt, and run a particular subroutine when the interrupt occurs.</simpara>
<simpara>The other way to deal with interrupts is to create a subroutine called
Interrupt. Great Cow BASIC will call this subroutine whenever an interrupt
occurs, and then your code can check the "flag" bits to determine which
interrupt has occured, and what should be done about it. If you use this
approach, then you&#8217;ll need to enable the desired interrupts manually. It
is also essential that your code clears the flag bits, or else the
interrupt routine will be called repeatedly.</simpara>
<simpara>Some combination of these two methods is also possible - the code
generated by On Interrupt with check to see if the interrupt is one it
recognises. If the interrupt is recognised, On Interrupt will deal with
it - if not, the Interrupt subroutine will be called to deal with the
interrupt.</simpara>
<simpara>The recommended way is to use On Interrupt, as it is both more efficient
and easier to set up.</simpara>
<simpara>During some sections of code, it is desirable not to have any interrupts
occur. If this is the case, then use the IntOff command to disable
interrupts at the start of the section, and IntOn to re-enable them at
the end. If any interrupt events occur while interrupts are disabled,
then they will be processed as soon as interrupts are re-enabled. If the
program does not use interrupts, IntOn and IntOff will be removed
automatically by Great Cow BASIC.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_intoff">IntOff</link>, <link linkend="_inton">IntOn</link>,
<link linkend="_on_interrupt">On Interrupt</link></simpara>
</section>
<section xml:id="_intoff">
<title>IntOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    IntOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support. Will
be automatically removed on chips without interrupts.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>IntOff</literal> is used to disable interrupts on the microcontroller. It should
be used at the start of code which is timing-sensitive, and which would
not function correctly if paused and restarted.</simpara>
<simpara>It is essential that <literal>IntOn</literal> is used to turn interrupts on again after the
timing-sensitive code has finished running. If not, no interrupts will
be handled.</simpara>
<simpara>It is recommended that IntOff be placed before all code that is timing
sensitive, in case interrupts are implemented later.</simpara>
<simpara><literal>IntOff</literal> will be removed from the assembler if no interrupts are used.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_inton">IntOn</link>, <link linkend="_interrupts">Interrupts</link></simpara>
</section>
<section xml:id="_inton">
<title>IntOn</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    IntOn</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support. Will
be automatically removed on chips without interrupts.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>IntOn</literal> is used to enable interrupts on the microcontroller after <literal>IntOff</literal>
has disabled them. It should be used at the end of code which is
timing-sensitive.</simpara>
<simpara><literal>IntOn</literal> will be removed from the assembler if no interrupts are used.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_intoff">IntOff</link>, <link linkend="_interrupts_overview">Interrupts</link></simpara>
</section>
<section xml:id="_on_interrupt">
<title>On Interrupt</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    On Interrupt event Call handler
    On Interrupt event Ignore</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC and Atmel AVR microcontrollers with interrupt support.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>On Interrupt will add code to call the subroutine <emphasis>handler</emphasis> whenever the
interrupt <emphasis>event</emphasis> occurs. When Call is specified, Great Cow BASIC will enable
the interrupt, and call the interrupt handler when it occurs. When
Ignore is specified, Great Cow BASIC will disable the interrupt handler and
prevent it from being called when the event occurs. If the event occurs
while the handler is disabled, then the handler will be called as soon
as it is re-enabled. The only way to prevent this from happening is to
manually clear the flag bit for the interrupt.</simpara>
<simpara>There are many possible interrupt events that can occur, and the events
vary greatly from chip to chip. Great Cow BASIC will display an error if a given
chip cannot support the specified event.</simpara>
<simpara>In some cases, On Interrupt will not be able to set or clear the
interrupt flag and/or enable bits. If this is the case, Great Cow BASIC will
display a warning. You will need to consult the chip datasheet and use
the Set command to manually set/clear the flag and enable bits, both at
the start of the program and inside the interrupt handler subroutine.
If On Interrupt is used to handle an event, then the Interrupt
subroutine will not be called for that event. However, it will still be
called for any events not dealt with by On Interrupt.</simpara>
<simpara><emphasis role="strong">Events:</emphasis></simpara>
<simpara>Great Cow BASIC supports the events shown on the table below. Some events are
only implemented on a few specialised chips. Events in <phrase role="gray"><emphasis role="strong">grey</emphasis></phrase> are
supported by Microchip PIC and Atmel AVR microcontrollers, events in <phrase role="blue"><emphasis role="strong">blue</emphasis></phrase> are only supported by some
Microchip PIC microcontrollers, and events in <phrase role="red"><emphasis role="strong">red</emphasis></phrase> are only supported by Atmel AVR microcontrollers.</simpara>
<simpara>Note that Great Cow BASIC doesn&#8217;t fully support all of the hardware which can
generate interrupts - some work may be required with various system
variables to control the unsupported peripherals.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Event Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Supported</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ADCReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The analog/digital converter has finished a conversion</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">BatteryFail</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The battery has failed in some way. This is only implemented on the ATmega406</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANActivity</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CAN bus activity is taking place</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANBadMessage</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A bad CAN message has been received</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">CANError</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Some CAN error has occured</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANHighWatermark</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CAN high watermark reached</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRx0Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present in buffer 0</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRx1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present in buffer 1</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRx2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present in buffer 2</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANRxReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>New message present</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CANTransferComplete</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Transfer of data has been completed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTx0Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Buffer 0 has been sent</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTx1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Buffer 1 has been sent</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTx2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Buffer 2 has been sent</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CANTxReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Sending has completed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CCADCAccReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CC ADC accumulate conversion finished (ATmega406 only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CCADCReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CC ADC instantaneous conversion finished (ATmega406 only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">CCADCRegular</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>CC ADC regular conversion finished (ATmega406 only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP1 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP2 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP3 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP4 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">CCP5</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The CCP5 module has captured an event</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Comp0Change</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The output of comparator 0 has changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Comp1Change</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The output of comparator 1 has changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Comp2Change</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The output of comparator 2 has changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Crypto</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The KEELOQ module has generated an interrupt</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">EEPROMReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An EEPROM write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Ethernet</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Ethernet module has generated an interrupt. This must be dealt within the handler.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt0</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 0 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 1 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 2 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">ExtInt3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 3 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 4 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt5</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 5 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt6</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 6 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">ExtInt7</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>External Interrupt pin 7 has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">GPIOChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port GPIO have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">LCDReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The LCD is about to draw a segment</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">LPWU</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Low Power Wake Up has been detected</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">OscillatorFail</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The external oscillator has failed, and the microcontroller is running from an internal oscillator.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange0</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT0 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT1 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT2 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT3 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT4 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange5</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT5 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange6</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT6 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PinChange7</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Logic level of PCINT7 pin has changed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PMPReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A Parallel Master Port read or write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PORTChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on ports ABCEDEF have changed.  This is generic port change interrupt.  You must inspect the source to ensure you are handlign the correct interrupt.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PORTAChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port A have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PORTABChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port A and/or B have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">PORTBChange</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The pins on port B have changed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC0Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The counter for Power Stage Controller 0 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC0EndCycle</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Power Stage Controller 0 has reached the end of its cycle</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC1Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The counter for Power Stage Controller 1 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC1EndCycle</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Power Stage Controller 1 has reached the end of its cycle</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC2Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The counter for Power Stage Controller 2 matches the value in a compare
register, the value of the counter has been captured, or a
synchronisation error has occurred</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">PSC2EndCycle</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Power Stage Controller 2 has reached the end of its cycle</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PSPReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A Parallel Slave Port read or write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">PWMTimeBase</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The PWM time base matches the PWM Time Base Period register (PTPER)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">SPIReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The SPI module has finished the previous transfer</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">SPMReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A write to program memory by the spm instruction has finished</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SPPReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A SPP read or write has finished</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP1Collision</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>SSP1 has detected a bus collision</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The SSP/SSP1/MSSP1 module has finished sending or receiving</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP2Collision</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>SSP2 has detected a bus collision</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">SSP2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The SSP2/MSSP2 module has finished sending or receiving</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer0Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP0 has caused the value of Timer 0 to be
captured in the ICR0 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer0Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 0 matches the Timer 0 output compare register A (OCR0A)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer0Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 0 matches the Timer 0 output compare register B (OCR0B)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer0Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 0 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP1 has caused the value of Timer 1 to be
captured in the ICR1 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Error</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Timer 1 Fault Protection unit has been detected by an input on the INT0
pin</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register A (OCR1A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register B (OCR1B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register C (OCR1C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer1Match4</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 matches the Timer 1 output compare register D (OCR1D)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer1Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 1 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer2Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 matches the Timer 2 output compare register (PR2)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer2Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 matches the Timer 2 output compare register A (OCR2A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer2Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 matches the Timer 2 output compare register B (OCR2B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer2Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 2 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP3 has caused the value of Timer 3 to be
captured in the ICR3 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 matches the Timer 3 output compare register A (OCR3A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 matches the Timer 3 output compare register B (OCR3B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer3Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 matches the Timer 3 output compare register C (OCR3C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer3Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 3 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP4 has caused the value of Timer 4 to be
captured in the ICR4 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer4Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register (PR4)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register A (OCR4A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register B (OCR4B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 matches the Timer 4 output compare register C (OCR4C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer4Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 4 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer5CAP1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input on the CAP1 pin has caused the value of Timer 5 to be captured
in CAP1BUF</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer5CAP2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input on the CAP2 pin has caused the value of Timer 5 to be captured
in CAP2BUF</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer5CAP3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input on the CAP3 pin has caused the value of Timer 5 to be captured
in CAP3BUF</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Capture</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An input event on the pin ICP5 has caused the value of Timer 5 to be
captured in the ICR5 register</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Match1</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 matches the Timer 5 output compare register A (OCR5A)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Match2</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 matches the Timer 5 output compare register B (OCR5B)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">Timer5Match3</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 matches the Timer 5 output compare register C (OCR5C)<?asciidoc-br?>
Within the Interrupt handling sub routine ensure the timer reset and cleartimer is set appropriately.</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">Timer5Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 5 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer6Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 6 matches the Timer 6 output compare register (PR6)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer7Overflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 7 has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer8Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 8 matches the Timer 8 output compare register (PR8)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer10Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 10 matches the Timer 10 output compare register (PR10)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">Timer12Match</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>Timer 12 matches the Timer 12 output compare register (PR12)</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">TWIConnect</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Atmel AVR has been connected to or disconnected from the TWI (I2C) bus</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">TWIReady</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The TWI has finished the previous transmission and is ready to send or
receive more data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartRX1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 1 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartRX2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 2 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartRX3Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 3 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartRX4Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 4 has received data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartTX1Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 1 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX1Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 1 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">UsartTX2Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 2 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX2Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 2 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX3Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 3 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX3Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 3 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX4Ready</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 4 is ready to send data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">UsartTX4Sent</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>UART/USART 4 has finished sending data</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">USBEndpoint</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>A USB endpoint has generated an interrupt</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="gray"><emphasis role="strong">USB</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The USB module has generated an interrupt. This must be dealt with in
the handler.</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip&amp;AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">USIOverflow</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The USI counter has overflowed from 15 to 0</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">USIStart</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The USI module has detected a start condition</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="blue"><emphasis role="strong">VoltageFail</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The input voltage has dropped too low</simpara></entry>
<entry align="left" valign="top"><simpara>Microchip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">VoltageRegulator</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An interrupt has been generated by the voltage regulator (ATmega16HVA only)</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">WakeUp</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>The Wake-Up timer has overflowed</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><phrase role="red"><emphasis role="strong">WDT</emphasis></phrase></simpara></entry>
<entry align="left" valign="top"><simpara>An interrupt has been generated by the Watchdog Timer</simpara></entry>
<entry align="left" valign="top"><simpara>AVR</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program increments a counter every time Timer1 overflows
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    InitTimer1 Osc, PS1_1/8
    StartTimer 1
    CounterValue = 0

    Wait 100 ms
    Print "Int Test"

    On Interrupt Timer1Overflow Call IncCounter

    Do
        CLS
        Print CounterValue
        Wait 100 ms
    Loop

    Sub IncCounter
        CounterValue ++
    End Sub</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    'This example reflects the input signal on the output port.
    #chip mega328p, 16
    #option explicit

    'set out SOURCE interrupt port as an output
    dir portb.0 in

    'set/enable the mask for the specific input port
    'this is crutial - for a lot of the On Interrupt methods you will need to specify the interrupt source via a mask.bit.
    PCINT0 = 1

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method
    On Interrupt PinChange0 Call TogglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 3:</emphasis></simpara>
<screen>    'This example reflects the input signal on the output port from the external interrupt port.
    #Chip mega328p, 16
    #option explicit

    'Set external interrupt INTO input pin as an input
    dir portd.2 in

    'set out signal port as an output
    dir portB.5 out

    'hardware interrupt on Port D2
    INT0 = 1

    'set interrupt to a failing or rising edge
    'interrupt on falling edge
    EICRA = b'00000010'
        'or, alternatively you can set to a rising edge
    'EICRA = b'00000011'

    'set out signal port as an output
    dir portB.5 out

    'setup the On Interrupt method on external interrupt 0
    On Interrupt EXTINT0 Call togglePin

    'maintain a loop
    do

    loop

    'handle the output signal
    'Note. The AVR automatically clears the Interrupt. Please study the datasheet for each specific microcontroller

    sub togglePin
        portb.5 =  !pinb.5
    end sub</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_inittimer0">InitTimer0</link> article contains
an example of using Timer 0 and On Interrupt to generate a Pulse Width
Modulation signal to control a motor.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_intoff">IntOff</link>, <link linkend="_inton">IntOn</link></simpara>
</section>
<section xml:id="_on_interrupt_the_default_handler">
<title>On Interrupt: The default handler</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>Great Cow BASIC supports a default interrupt handler in two modes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>You can define the interrupt flags and the default handler (a sub routine) will executed</simpara>
</listitem>
<listitem>
<simpara>You can define an On Interrupt  event Call handler  where the handler is executed that matches the event
and where all other define/valid events are handled by the default handler (a sub routine),
The easiest way to write an interrupt handler is to write it in Great Cow BASIC in conjunction with the On Interrupt statement.
On Interrupt tells microcontroller to activate its internal interrupt handling and to jump to a predetermined interrupt
handler (a sub routine that has been defined) when the interrupt handler (the sub routine) has completed processing returns
to correct address in the program.  See <link linkend="_on_interrupt">On Interrupt</link>.</simpara>
</listitem>
</orderedlist>
<simpara>This method of supports the handling interrupts by enabling a default interrupt subroutine.</simpara>
<simpara><emphasis role="strong">Example 1</emphasis></simpara>
<simpara>This example shows if an event occurs the microcontroller will be program to jump to the interrupt vector and the program will not know the event type, it will simple execute the Interrupt subroutine.
This code is not intended as a meaningful solution and intended to show the functionality only.
An LED is attached to PORTB.1 via a suitable resistor.  It will light up when the Interrupt event has occurred.</simpara>
<screen>    #chip 16f877a, 4
    dir PORTB.1 out
    Set PORTB.1 Off

    'Note: there is NO On Interrupt handler
    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1
    'Manually set Timer1Overflow to the overflow event
    'this will event will be handled by the Interrupt sub routine
    TMR1IE = 1
    end

    Sub Interrupt
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</screen>
<simpara><emphasis role="strong">Example 2</emphasis></simpara>
<simpara>Any events that are not dealt with by On Interrupt will result in the code in the Interrupt subroutine executing.
This example shows the operation of two interrupt handlers - is not intended as a meaningful solution.</simpara>
<simpara>LEDs are attached to PORTB.1 and PORTB.2 via suitable resistors.  They will light up when the Interrupt events occur.</simpara>
<screen>    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed

    dir PORTB.1 out
    Set PORTB.1 Off

    dir PORTB.2 out
    Set PORTB.2 Off

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</screen>
</section>
</section>
<section xml:id="_keypad">
<title>Keypad</title>
<simpara>This is the Keypad section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_keypad_overview">
<title>Keypad Overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The keypad routines allow for a program to read from a 4 x 4 matrix
keypad.</simpara>
<simpara>There are two ways that the keypad routines can be set up. One option is
to connect the wires from the keypad in a particular order, and then to
set the KeypadPort constant. The other option is to connect the keypad
in whatever way is easiest, and then set the <literal>KEYPAD_ROW_x</literal> and
<literal>KEYPAD_COL_x</literal> constants. The option (setting <literal>KeypadPort</literal>) will
generate slightly more efficient code.</simpara>
<simpara><emphasis role="strong">Configuration using</emphasis> <literal>KEYPAD_ROW_x</literal> <emphasis role="strong">and</emphasis> <literal>KEYPAD_COL_x</literal>:</simpara>
<simpara>These constants must be set:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 1 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 2 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 3 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_ROW_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Row 4 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 1 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 2 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 3 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_COL_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The pin on the microcontroller that connects to the Col 4 pin on the
keypad</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If using a 3 x 3 keypad, do not set the <literal>KEYPAD_ROW_4</literal> or <literal>KEYPAD_COL_4</literal>
constants.</simpara>
<simpara><emphasis role="strong">Configuration using</emphasis> <literal>KeypadPort</literal>:</simpara>
<simpara>When setting up the keypad code using the <literal>KeypadPort</literal> constant, only
<literal>KeypadPort</literal> needs to be set.</simpara>
<simpara>Pull-ups or pull-downs go on the columns only, and are typically 4.7k to
10k in value.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>KeypadPort</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The port on the microcontroller chip that the keypad is connected to.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Configuration when using Pull down resistors</emphasis></simpara>
<simpara>The keypad routine has a feature when using pull-down resistors, simply
add the constant to your program and the and the scan logic will be
inverted appropriately.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>KEYPAD_PULLDOWN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Support pull down resistors.</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For this to work, the keypad must be connected as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Microcontroller port pin</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Keypad connector</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>Row 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Row 2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Row 3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Row 4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>Column 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>Column 2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>Column 3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>Column 4</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note: To use a 3 x 3 keypad in this mode, the pins on the
microcontroller for any unused columns must be pulled up.</simpara>
</section>
<section xml:id="_keypaddata">
<title>KeypadData</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>var</emphasis> = KeypadData</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function will return a value corresponding to the key that is
pressed on the keypad. Note that if two or more keys are pressed, then
only one value will be returned.
<literal><emphasis>var</emphasis></literal> can have one of the following values:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Key Pressed</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>0</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>5</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>6</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>7</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>9</simpara></entry>
<entry align="center" valign="top"></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_A</simpara></entry>
<entry align="center" valign="top"><simpara>A</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>11</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_B</simpara></entry>
<entry align="center" valign="top"><simpara>B</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_C</simpara></entry>
<entry align="center" valign="top"><simpara>C</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>13</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_D</simpara></entry>
<entry align="center" valign="top"><simpara>D</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_STAR</simpara></entry>
<entry align="center" valign="top"><simpara>Asterisk/Star (*)</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>15</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_HASH</simpara></entry>
<entry align="center" valign="top"><simpara>Hash (#)</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>255</simpara></entry>
<entry align="center" valign="top"><simpara>KEY_NONE</simpara></entry>
<entry align="center" valign="top"><simpara>None</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Program to show the value of the last pressed key on the LCD
    #chip 18F4550, 20

    'LCD connection settings
    #define LCD_IO 4
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Keypad connection settings
    #define KeypadPort PORTB

    'Main loop
    Do
        'Get key
        Temp = KeypadData

        'If a key is pressed, then display it
        If Temp &lt;&gt; KEY_NONE Then
            CLS
            Print Temp
            Wait 100 ms
        End If
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_keypad_overview">Keypad Overview</link></simpara>
</section>
<section xml:id="_keypadraw">
<title>KeypadRaw</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>largevar</emphasis> = KeypadRaw</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function will return a 16 bit value, in which each bit corresponds
to a key on the keypad. If the key is pressed its bit will hold 1, and
if it is released its bit will contain a 0.</simpara>
<simpara>This table shows the key that each bit corresponds to:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Bit</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Key Position (row, col)</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Common Key Symbol</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>15</simpara></entry>
<entry align="center" valign="top"><simpara>1,1</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>1,2</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>13</simpara></entry>
<entry align="center" valign="top"><simpara>1,3</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>1,4</simpara></entry>
<entry align="center" valign="top"><simpara>A</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>11</simpara></entry>
<entry align="center" valign="top"><simpara>2,1</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="center" valign="top"><simpara>2,2</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>9</simpara></entry>
<entry align="center" valign="top"><simpara>2,3</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="center" valign="top"><simpara>2,4</simpara></entry>
<entry align="center" valign="top"><simpara>B</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>7</simpara></entry>
<entry align="center" valign="top"><simpara>3,1</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>6</simpara></entry>
<entry align="center" valign="top"><simpara>3,2</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>5</simpara></entry>
<entry align="center" valign="top"><simpara>3,3</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="center" valign="top"><simpara>3,4</simpara></entry>
<entry align="center" valign="top"><simpara>C</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>3</simpara></entry>
<entry align="center" valign="top"><simpara>4,1</simpara></entry>
<entry align="center" valign="top"><simpara>*</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"><simpara>4,2</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>4,3</simpara></entry>
<entry align="center" valign="top"><simpara>#</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>0</simpara></entry>
<entry align="center" valign="top"><simpara>4,4</simpara></entry>
<entry align="center" valign="top"><simpara>D</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Program to show the keypad status using LEDs
    #chip 16F877A, 20

    'Keypad connection settings
    #define KeypadPort PORTB

    'LEDs
    #define LED1 PORTC
    #define LED2 PORTD
    Dir LED1 Out
    Dir LED2 Out

    'Declare a 16 bit variable for the key value
    Dim KeyStatus As Word

    'Main loop
    Do
        'Get key
        KeyStatus = KeypadRaw

        'Display
        LED1 = KeyStatus_H 'High Byte
        LED2 = KeyStatus 'Low Byte
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_keypad_overview">Keypad Overview</link></simpara>
</section>
</section>
<section xml:id="_graphical_lcd">
<title>Graphical LCD</title>
<simpara>This is the GLCD section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_glcd_overview">
<title>GLCD Overview</title>
<simpara>The GLCD commands are used to control a Graphical Liquid Crystal Display (GLCD)
based on the a number of GLCD chipsets. These are often 128x64 pixel displays but the size can vary.
GLCD devices draw graphical elements by enabling or disabling pixels.</simpara>
<simpara>A GLCD is an upgrade from the
popular 16x2 LCDs (see <link linkend="_lcd_overview">Liquid Crystal
Display Overview</link> ) but the GLCD allows full graphical control of the
display.</simpara>
<simpara>Typical displays are</simpara>
<itemizedlist>
<listitem>
<simpara>Color or mono displays</simpara>
</listitem>
<listitem>
<simpara>Low power white LED, OLED with or without back-light</simpara>
</listitem>
<listitem>
<simpara>Driven by on-board interface chipsets or SPI interface controllers</simpara>
</listitem>
<listitem>
<simpara>The GLCDs are very common and well documente</simpara>
</listitem>
<listitem>
<simpara>Typically with viewing area is 71mmx39mm (2.8" x 1.5")</simpara>
</listitem>
<listitem>
<simpara>Typically requires a 36-pin 0.1" header and 10K contrast pot</simpara>
</listitem>
<listitem>
<simpara>Typically have back-lit pixels</simpara>
</listitem>
<listitem>
<simpara>Require memory in the microcontroller to support graphial operations or can be used in text and jpg mode only.</simpara>
</listitem>
</itemizedlist>
<simpara>Great Cow BASIC makes this type of device easier to control with the
commands for the GLCD.</simpara>
<simpara><emphasis role="strong">Microcontroller Requirements:</emphasis>
Specific GLCDs require different configurations of a microcontroller.  Parameters include</simpara>
<itemizedlist>
<listitem>
<simpara>Communications protocol: These incldue 8 wire bus, I2C, SPI etc</simpara>
</listitem>
<listitem>
<simpara>Operating votlage: These are typically 3.3v or 5.v</simpara>
</listitem>
<listitem>
<simpara>Memory required: For full GLCD capabilites you will require 1k or more, for text only and JPG mode low memory devices are supported</simpara>
</listitem>
</itemizedlist>
<simpara>Review your choice of microcontroller and GLCD carefully before commencing your project.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="13">
<colspec colname="col_1" colwidth="7*"/>
<colspec colname="col_2" colwidth="7*"/>
<colspec colname="col_3" colwidth="7*"/>
<colspec colname="col_4" colwidth="7*"/>
<colspec colname="col_5" colwidth="7*"/>
<colspec colname="col_6" colwidth="7*"/>
<colspec colname="col_7" colwidth="7*"/>
<colspec colname="col_8" colwidth="7*"/>
<colspec colname="col_9" colwidth="7*"/>
<colspec colname="col_10" colwidth="7*"/>
<colspec colname="col_11" colwidth="7*"/>
<colspec colname="col_12" colwidth="7*"/>
<colspec colname="col_13" colwidth="7*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">#</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">ChipSet</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Docs</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Size</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Pixels</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Depth</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">I/O</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Support</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Operating</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comments</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Requirements</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Assessment</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>KS0108</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>2.9 inch and less.. various sizes</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD typically with backlight</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit parallel	PIC and AVR: Software device specific protocol</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications	8-bit bus required.</simpara></entry>
<entry align="left" valign="top"><simpara>Bit 7 of the bus is read/write – this could cause potential lockup – this is low risk.</simpara></entry>
<entry align="left" valign="top"><simpara>Requires 12 ports/connections.</simpara></entry>
<entry align="left" valign="top"><simpara>These are low cost mono devices..</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9481</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>3.2inch</simpara></entry>
<entry align="left" valign="top"><simpara>320 * 240</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD	8-bit parallel</simpara></entry>
<entry align="left" valign="top"><simpara>PIC: Set per bit. AVR: via Shield set via AND PORT command</simpara></entry>
<entry align="left" valign="top"><simpara>+VCC from 2.7 to  5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>UNO shield is excellent. Very fast display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good GLCD with very good GLCD performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>PCD8544</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>1.77inch</simpara></entry>
<entry align="left" valign="top"><simpara>Nokia 3310 or 5110</simpara></entry>
<entry align="left" valign="top"><simpara>160 * 128</simpara></entry>
<entry align="left" valign="top"><simpara>Small	Mono	LCD with LED</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Device specific SPI command, all in software.</simpara></entry>
<entry align="left" valign="top"><simpara>Display can operate in text mode only for low RAM microcontrollers as full GLCD capabilities requires 512bytes of RAM.	+VCC 3.3.  Always check voltage specifications	Nice display.
Sensitive to operating voltages.</simpara></entry>
<entry align="left" valign="top"><simpara>Minimum RAM required is 512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9341</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>2.8 Inch or 3.2 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>320 * 240</simpara></entry>
<entry align="left" valign="top"><simpara>Medium</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI	PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good  for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>SSD1289</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>3.2inch</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>16-bit parallel	AVR: Software device specific protocol.</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>Mega2560 shield required.</simpara></entry>
<entry align="left" valign="top"><simpara>Connectivity requires 20 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for Mega2560 type shields</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>ST7735</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>1.8 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications	Very nice display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9340</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>2.2 Inch</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Medium</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>Good for cost and performance</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>ILI9486L</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>4inch</simpara></entry>
<entry align="left" valign="top"><simpara>RPI	 240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications	Great pixel display.</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.</simpara></entry>
<entry align="left" valign="top"><simpara>An expensive option</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>Nexion</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
<entry align="left" valign="top"><simpara>ITEAD Nexion</simpara></entry>
<entry align="left" valign="top"><simpara>240 * 320</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>Serial</simpara></entry>
<entry align="left" valign="top"><simpara>Special command set</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5 with external power supply. Always check voltage specifications	Great command set, you need to learn the GUI and then interface to Great Cow BASIC.</simpara></entry>
<entry align="left" valign="top"><simpara>2 ports for the read/write serial operations.</simpara></entry>
<entry align="left" valign="top"><simpara>An expensive option but if you need flexibility then the best!</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>SH1106</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>1.3 inch or 0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Small</simpara></entry>
<entry align="left" valign="top"><simpara>Mono	OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C</simpara></entry>
<entry align="left" valign="top"><simpara>Always at 3.3v. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1306</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Small</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C and SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 1024 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications	Very good OLED display. Driver supports gaming.	Minimum RAM required is  1024 bytes then add user variables for graphics mode.
</simpara><simpara>Display can operate in text mode only for low RAM microcontrollers</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</simpara><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1306_32</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 32</simpara></entry>
<entry align="left" valign="top"><simpara>Very small</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>OLED</simpara></entry>
<entry align="left" valign="top"><simpara>I2C and SPI</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR: Hardware and software I2C, and software SPI</simpara></entry>
<entry align="left" valign="top"><simpara>RAM for Full Mode GLCD is 512 bytes or Low Memory GLCD is 128 bytes or 0 bytes for Text GLCD Mode then add user variables for graphics mode.
Typically operates at VCC 5. Always check voltage specifications	Best small OLED display. Driver supports gaming.	Minimum RAM required is  512 bytes then add user variables for graphics mode, this display can operate in text mode only for low RAM microcontrollers</simpara></entry>
<entry align="left" valign="top"><simpara>SPI requires 4 ports plus 2 ports. Typically 6 in total.
</simpara><simpara>I2C requires 2 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>Good OLED display, excellent value for money</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>ST7920</simpara></entry>
<entry align="left" valign="top"><simpara>Help</simpara></entry>
<entry align="left" valign="top"><simpara>2.9inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 64</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Mono</simpara></entry>
<entry align="left" valign="top"><simpara>LCD typically with backlight	8-bit parallel</simpara></entry>
<entry align="left" valign="top"><simpara>PIC and AVR:  Software device specific protocol.</simpara></entry>
<entry align="left" valign="top"><simpara>Typically operates at VCC 5. Always check voltage specifications</simpara></entry>
<entry align="left" valign="top"><simpara>8-bit bus required.  Bit 7 of the bus is read/write – this could cause potential lockup – this is low risk.
</simpara><simpara>This looks like a KS0108 but it is NOT! Supports Chinese font set.</simpara></entry>
<entry align="left" valign="top"><simpara>Requires 12 ports.</simpara></entry>
<entry align="left" valign="top"><simpara>A very slow device.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>SDD1331</simpara></entry>
<entry align="left" valign="top"><simpara>0.96inch</simpara></entry>
<entry align="left" valign="top"><simpara>128 * 32</simpara></entry>
<entry align="left" valign="top"><simpara>Large</simpara></entry>
<entry align="left" valign="top"><simpara>Color</simpara></entry>
<entry align="left" valign="top"><simpara>TFT LCD</simpara></entry>
<entry align="left" valign="top"><simpara>TBD</simpara></entry>
<entry align="left" valign="top"><simpara>TBD</simpara></entry>
<entry align="left" valign="top"><simpara>TBD</simpara></entry>
<entry align="left" valign="top"><simpara>TBD</simpara></entry>
<entry align="left" valign="top"><simpara>TBD</simpara></entry>
<entry align="left" valign="top"><simpara>TBD</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Setup:</emphasis></simpara>
<simpara>You <emphasis role="strong">must</emphasis> include the <literal>glcd.h</literal> file at the top of your program. The file
needs to be in brackets as shown below.</simpara>
<screen>    #include &lt;GLCD.h&gt;</screen>
<simpara><emphasis role="strong">Defines:</emphasis></simpara>
<simpara>There are several connections that must be defined to use the GLCD
commands with a GLCD display. The <emphasis>I/O pin</emphasis> is the pin on the Microchip PIC or the Atmel AVR microcontroller
that is connected to that specific pin on the graphical LCD.</simpara>
<simpara><emphasis role="strong">Example: KS0108 connectivity</emphasis></simpara>
<screen>    #define GLCD_RW   _I/O pin_ ‘Read/Write pin connection
    #define GLCD_RESET  _I/O pin_ ‘Reset pin connection
    #define GLCD_CS1  _I/O pin_ ‘CS1 pin connection
    #define GLCD_CS2  _I/O pin_ ‘CS2 pin connection
    #define GLCD_RS   _I/O pin_ ‘RS pin connection
    #define GLCD_ENABLE _I/O pin_ ‘Enable pin Connection
    #define GLCD_DB0  _I/O pin_ ‘Data pin 0 Connection
    #define GLCD_DB1  _I/O pin_ ‘Data pin 1 Connection
    #define GLCD_DB2  _I/O pin_ ‘Data pin 2 Connection
    #define GLCD_DB3  _I/O pin_ ‘Data pin 3 Connection
    #define GLCD_DB4  _I/O pin_ ‘Data pin 4 Connection
    #define GLCD_DB5  _I/O pin_ ‘Data pin 5 Connection
    #define GLCD_DB6  _I/O pin_ ‘Data pin 6 Connection
    #define GLCD_DB7  _I/O pin_ ‘Data pin 7 Connection
    #define GLCD_PROTECTOVERRUN 'prevent screen overdrawing     'SSD1306 GLCD only
    #define GLCDDirection       'Invert GLCD Y axis             'KS0108 GCD only</screen>
<simpara>Common commands supported across the range of supported GLCDs are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable</literal> )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Public variable supported across the range of supported GLCDs are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDBackground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD background.</simpara></entry>
<entry align="left" valign="top"><simpara>Can be monochrome or color.<?asciidoc-br?>
For mono GLCDs the default is White or 0x0001.
For color GLCDs the default is White or 0xFFFF.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDForeground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD foreground.</simpara></entry>
<entry align="left" valign="top"><simpara>Can be monochrome or color.<?asciidoc-br?>
For mono GLCDs the default is non-white or 0x0000.
For color GLCDs the default is Black or 0x0000.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0.+
This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 1.+
This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_ks0108_controllers">KS 0108 controllers</link>,
<link linkend="_st7735_controllers">ST7735 Controllers</link> and
<link linkend="_st7920_controllers">ST7920 Controllers</link></simpara>
<simpara>This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of Great Cow BASIC. See
<link xlink:href="http://www.greatcowbasic.com/sample-projects.html">Graphic LCD</link> for
details, this is an external web site.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include &lt;GLCD.h&gt;

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be inverted
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be inverted
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Start:
    GLCDCLS
    GLCDPrint 0,10,"Hello"        'Print Hello
    wait 5 s
    GLCDPrint 0,10, "ASCII #:"    'Print ASCII #:
    Box 18,30,28,40               'Draw Box Around ASCII Character
    for char = 15 to 129          'Print 0 through 9
      GLCDPrint 17, 20 , Str(char)+"  "
      GLCDdrawCHAR 20,30, char
      wait 125 ms
    next
    line 0,50,127,50               'Draw Line using line command
    for xvar = 0 to 80             'Draw line using Pset command
        pset xvar,63,on                    '
    next                                        '
    Wait 1 s
    GLCDPrint 0,10,"End  "          'Print Hello
    wait 1 s
    Goto Start</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_graphical_lcd_demonstration">Graphical LCD Demonstration</link>,
<link linkend="_glcdcls">GLCDCLS</link>,
<link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>,
<link linkend="_glcdreadbyte">GLCDReadByte</link>,
<link linkend="_glcdwritebyte">GLCDWriteByte</link>, <link linkend="_pset">Pset</link></simpara>
<section xml:id="_ili9340_controllers">
<title>ILI9340 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9340 graphics controller.  The ILI9340 is a TFT LCD Single Chip Driver with 240RGBx320 Resolution and 262K colors.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the ILI9340 controller. &#160;&#160;&#160;Great Cow BASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the ILI9340 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting</screen>
<simpara>The Great Cow BASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9340</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.
#define GLCD_SCK    porta.5           'example port setting</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal>+
Cannot be changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>240</literal>+
Cannot be changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9340_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    ILI9340_BLACK   'hexidecimal value 0x0000
    ILI9340_RED     'hexidecimal value 0xF800
    ILI9340_GREEN   'hexidecimal value 0x07E0
    ILI9340_BLUE    'hexidecimal value 0x001F
    ILI9340_WHITE   'hexidecimal value 0xFFFF
    ILI9340_PURPLE  'hexidecimal value 0xF11F
    ILI9340_YELLOW  'hexidecimal value 0xFFE0
    ILI9340_CYAN    'hexidecimal value 0x07FF
    ILI9340_D_GRAY  'hexidecimal value 0x528A
    ILI9340_L_GRAY  'hexidecimal value 0x7997
    ILI9340_SILVER  'hexidecimal value 0xC618
    ILI9340_MAROON  'hexidecimal value 0x8000
    ILI9340_OLIVE   'hexidecimal value 0x8400
    ILI9340_LIME    'hexidecimal value 0x07E0
    ILI9340_AQUA    'hexidecimal value 0x07FF
    ILI9340_TEAL    'hexidecimal value 0x0410
    ILI9340_NAVY    'hexidecimal value 0x0010
    ILI9340_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a ILI9340 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9340.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a ILI9340 based Graphic LCD module with the built in commands of Great Cow BASIC.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config Osc = INT, VCAPEN_OFF, MCLRE_ON, PLLEN_ON, CLKOUTEN_OFF      'microcontroller specific configuration

    #include &lt;glcd.h&gt;

    'Defines for ILI9340
    #define GLCD_TYPE GLCD_TYPE_ILI9340

    'Pin mappings for ILI9340
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9340 Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9341_controllers">
<title>ILI9341 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9341 graphics controller.  The ILI9341 is a TFT LCD Single Chip Driver with 240RGBx320 Resolution and 262K colors.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the ILI9341 controller. &#160;&#160;&#160;Great Cow BASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the ILI9341 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341 - these MUST be specified
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</screen>
<simpara>The Great Cow BASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9341</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>240</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9341_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    ILI9341_BLACK   'hexidecimal value 0x0000
    ILI9341_RED     'hexidecimal value 0xF800
    ILI9341_GREEN   'hexidecimal value 0x07E0
    ILI9341_BLUE    'hexidecimal value 0x001F
    ILI9341_WHITE   'hexidecimal value 0xFFFF
    ILI9341_PURPLE  'hexidecimal value 0xF11F
    ILI9341_YELLOW  'hexidecimal value 0xFFE0
    ILI9341_CYAN    'hexidecimal value 0x07FF
    ILI9341_D_GRAY  'hexidecimal value 0x528A
    ILI9341_L_GRAY  'hexidecimal value 0x7997
    ILI9341_SILVER  'hexidecimal value 0xC618
    ILI9341_MAROON  'hexidecimal value 0x8000
    ILI9341_OLIVE   'hexidecimal value 0x8400
    ILI9341_LIME    'hexidecimal value 0x07E0
    ILI9341_AQUA    'hexidecimal value 0x07FF
    ILI9341_TEAL    'hexidecimal value 0x0410
    ILI9341_NAVY    'hexidecimal value 0x0010
    ILI9341_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a ILI9341 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/ILI9341.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a ILI9341 based Graphic LCD module with the built in commands of Great Cow BASIC.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config Osc = INT, VCAPEN_OFF, MCLRE_ON, PLLEN_ON, CLKOUTEN_OFF      'microcontroller specific configuration

    #include &lt;glcd.h&gt;

    'Defines for ILI9341
    #define GLCD_TYPE GLCD_TYPE_ILI9341

    'Pin mappings for ILI9341
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ILI9341 Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9481_controllers">
<title>ILI9481 Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9481 graphics controller.</simpara>
<simpara>ILI9481 is a 262,144-color single-chip SoC driver for a-TFT liquid crystal display with resolution of 320&#160;RGB&#160;x&#160;480&#160;
dots, comprising a 960-channel source driver, a 480-channel gate driver, 345,600 bytes GRAM for graphic data.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the ILI9481controller.
&#160;&#160;&#160;The Great Cow BASIC constants for control and data line connections are shown
in the table below. Two options are available for connectivity:</simpara>
<simpara>1)  The 8-bit mode where 8 pins are connected between the microcontroller and the GLCD to control the
data bus.</simpara>
<simpara>2)  The 16-bit mode where two data ports (8 pins each) are connected between  the microcontroller and the GLCD to control the data bus.</simpara>
<simpara>To use the ILI9481 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">8-bit mode</emphasis></simpara>
<screen>    'Pin mappings for Data Bus Interface (DBI)
    'this GLCD driver supports 8 bit and 16 bit parallel data lines

    '8 bit DBI
    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9481

    '8 bit control and parallel data lines (UNO Board)
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8        'Data port'
    #define GLCD_DB1       DIGITAL_9        'Data port'
    #define GLCD_DB2       DIGITAL_2        'Data port'
    #define GLCD_DB3       DIGITAL_3        'Data port'
    #define GLCD_DB4       DIGITAL_4        'Data port'
    #define GLCD_DB5       DIGITAL_5        'Data port'
    #define GLCD_DB6       DIGITAL_6        'Data port'
    #define GLCD_DB7       DIGITAL_7        'Data port'</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">16-bit mode</emphasis></simpara>
<screen>    '16 bit DBI
    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    '16 bit control and dual data port lines (Mega2560 Board)
    #define ILI9481_GLCD_CS PortG.1    'Chip Select line
    #define ILI9481_GLCD_RS PortD.7    'DC data command line
    #define ILI9481_GLCD_WR PortG.2    'Write command line
    #define ILI9481_GLCD_RST PortG.0    'Reset line

    #define ILI9481_DataPortH PortA    'DB[15:8]
    #define ILI9481_DataPortL PortC    'DB[7:0]</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The Great Cow BASIC constants for the interface to the controller are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9481</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_ILI9481_16bit</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies 16 bit DBI mode</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB0..7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the  pin that is connected to DB0..7 IO pin on the GLCD (8 bit DBI).</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9481_DataPortH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the  port DB[15:8] pins on the GLCD (16 bit DBI).</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9481_DataPortL</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the  port DB[7:0] pins on the GLCD (16 bit DBI).</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RST</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (RW or WDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (RD or RDR) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
The Great Cow BASIC constants for control display characteristics are shown in the table below.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>480</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS  [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2  [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9481_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    ILI9481_BLACK   'hexidecimal value 0x0000
    ILI9481_RED     'hexidecimal value 0xF800
    ILI9481_GREEN   'hexidecimal value 0x0400
    ILI9481_BLUE    'hexidecimal value 0x001F
    ILI9481_WHITE   'hexidecimal value 0xFFFF
    ILI9481_PURPLE  'hexidecimal value 0xF11F
    ILI9481_YELLOW  'hexidecimal value 0xFFE0
    ILI9481_CYAN    'hexidecimal value 0x07FF
    ILI9481_D_GRAY  'hexidecimal value 0x528A
    ILI9481_L_GRAY  'hexidecimal value 0x7997
    ILI9481_SILVER  'hexidecimal value 0xC618
    ILI9481_MAROON  'hexidecimal value 0x8000
    ILI9481_OLIVE   'hexidecimal value 0x8400
    ILI9481_LIME    'hexidecimal value 0x07E0
    ILI9481_AQUA    'hexidecimal value 0x07FF
    ILI9481_TEAL    'hexidecimal value 0x0410
    ILI9481_NAVY    'hexidecimal value 0x0010
    ILI9481_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>These examples show how to drive a ILI9481 based Graphic LCD module with the built in commands of Great Cow BASIC.  The 8 bit DBI example uses a UNO shield, this can easily adapted to Microchip architecture.  The 16 bit DBI
example uses a Mega2560 board.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Examples:</emphasis></simpara>
<screen>    '8 bit DBI
    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9481

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_RD       ANALOG_0          ' read command line
    #define GLCD_WR       ANALOG_1          ' write command line
    #define GLCD_RS       ANALOG_2          ' Command/Data line
    #define GLCD_CS       ANALOG_3          ' Chip select line
    #define GLCD_RST      ANALOG_4          ' Reset line

    #define GLCD_DB0       DIGITAL_8
    #define GLCD_DB1       DIGITAL_9
    #define GLCD_DB2       DIGITAL_2
    #define GLCD_DB3       DIGITAL_3
    #define GLCD_DB4       DIGITAL_4
    #define GLCD_DB5       DIGITAL_5
    #define GLCD_DB6       DIGITAL_6
    #define GLCD_DB7       DIGITAL_7

    GLCDPrint(0, 0, "Test of the ILI9481 Device")
    end</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<screen>    '16 bit DBI
    #chip mega2560, 16
    #include &lt;glcd.h&gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9481
    #define GLCD_ILI9481_16bit

    #define ILI9481_GLCD_CS PortG.1
    #define ILI9481_GLCD_RS PortD.7
    #define ILI9481_GLCD_WR PortG.2
    #define ILI9481_GLCD_RST PortG.0
    #define ILI9481_DataPortH PortA
    #define ILI9481_DataPortL PortC

    #define ILI9481_YELLOW1   0xFFC1
    #define ILI9481_BlueViolet  0x895C

    GLCDCLS_ILI9481 ILI9481_Black
    wait 1 s
    GLCDCLS_ILI9481 ILI9481_White
    wait 1 s

    GLCDfntDefaultsize = 3
    GLCDBackground = ILI9481_BlueViolet
    GLCDForeground = ILI9481_Yellow1
    GLCDCLS
    wait 1 s

    Start:

    'demonstrate screen rotation
    GLCDRotate (Portrait)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 -24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Portrait_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    GLCDRotate (Landscape_REV)
    GLCDCLS
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 24, ILI9481_GLCD_HEIGHT/2 - 62, "GCB")
    GLCDDrawString ( ILI9481_GLCD_WIDTH/2 - 120, ILI9481_GLCD_HEIGHT/2 - 24, "ILI9481 Driver")
    wait 5 s

    goto Start</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>,  <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link>
<?asciidoc-br?>
<?asciidoc-br?>
Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ili9486l_controllers">
<title>ILI9486L Controllers</title>
<simpara>This section covers GLCD devices that use the ILI9486L graphics controller.</simpara>
<simpara>The ILI9486L is a 262,144-color single-chip SoC driver for a-Si TFT liquid crystal display with resolution of
320RGBx480 dots, comprising a 960-channel source driver, a 480-channel gate driver, 345,600bytes GRAM for
graphic data of 320RGBx480 dots.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the ILI9486L controller. &#160;&#160;&#160;Great Cow BASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the ILI9486L driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ILI9486L</screen>
<simpara>The Great Cow BASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Options</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ILI9486L</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SLK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>320</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>480</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2 [,Optional LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2  [,Optional In LineColour] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDRotate</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Rotate the display</simpara></entry>
<entry align="left" valign="top"><simpara><literal>LANDSCAPE</literal>, <literal>PORTRAIT_REV</literal>, <literal>LANDSCAPE_REV</literal> and <literal>PORTRAIT</literal> are supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ILI9486L_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>    ILI9486L_BLACK   'hexidecimal value 0x0000
    ILI9486L_RED     'hexidecimal value 0xF800
    ILI9486L_GREEN   'hexidecimal value 0x07E0
    ILI9486L_BLUE    'hexidecimal value 0x001F
    ILI9486L_WHITE   'hexidecimal value 0xFFFF
    ILI9486L_PURPLE  'hexidecimal value 0xF11F
    ILI9486L_YELLOW  'hexidecimal value 0xFFE0
    ILI9486L_CYAN    'hexidecimal value 0x07FF
    ILI9486L_D_GRAY  'hexidecimal value 0x528A
    ILI9486L_L_GRAY  'hexidecimal value 0x7997
    ILI9486L_SILVER  'hexidecimal value 0xC618
    ILI9486L_MAROON  'hexidecimal value 0x8000
    ILI9486L_OLIVE   'hexidecimal value 0x8400
    ILI9486L_LIME    'hexidecimal value 0x07E0
    ILI9486L_AQUA    'hexidecimal value 0x07FF
    ILI9486L_TEAL    'hexidecimal value 0x0410
    ILI9486L_NAVY    'hexidecimal value 0x0010
    ILI9486L_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a ILI9486L datasheet, please refer to Google.</simpara>
<simpara>This example shows how to drive a ILI9486L based Graphic LCD module with the built in commands of Great Cow BASIC.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip mega328p, 16
    #option explicit

    #include &lt;glcd.h&gt;
    #include &lt;UNO_mega328p.h &gt;

    #define GLCD_TYPE GLCD_TYPE_ILI9486L

    'Pin mappings for SPI - this GLCD driver supports Hardware SPI and Software SPI
    #define GLCD_DC       DIGITAL_8           ' Data command line
    #define GLCD_CS       DIGITAL_10          ' Chip select line
    #define GLCD_RESET    DIGITAL_9           ' Reset line

    #define GLCD_DI       DIGITAL_12          ' Data in | MISO
    #define GLCD_DO       DIGITAL_11          ' Data out | MOSI
    #define GLCD_SCK      DIGITAL_13          ' Clock Line

    #define ILI9486L_HardwareSPI              ' Remove/comment out if you want to use software SPI.


    GLCDPrint(0, 0, "Test of the ILI9486L Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ks0108_controllers">
<title>KS0108 Controllers</title>
<simpara>This section covers GLCD devices that use the KS0108 graphics controller.</simpara>
<simpara>The KS0108 is an LCD is driven by on-board 5V parallel interface chipset KS0108 and KS0107. They are extremely common and well documented</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the KS0108 controller. &#160;&#160;&#160;The only connectivity option is the 8-bit mode where 8 connections (for the data) are required between the microcontroller and the GLCD to control the data bus.</simpara>
<simpara>The SH1106 is a monochrome device.</simpara>
<simpara>To use the KS0108 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_KS0108


    #define GLCD_RW       PORTB.1            'chip specific configuration
    #define GLCD_RESET    PORTB.5            'chip specific configuration
    #define GLCD_CS1      PORTB.3            'chip specific configuration
    #define GLCD_CS2      PORTB.4            'chip specific configuration
    #define GLCD_RS       PORTB.0            'chip specific configuration
    #define GLCD_ENABLE   PORTB.2            'chip specific configuration
    #define GLCD_DB0      PORTC.7            'chip specific configuration
    #define GLCD_DB1      PORTC.6            'chip specific configuration
    #define GLCD_DB2      PORTC.5            'chip specific configuration
    #define GLCD_DB3      PORTC.4            'chip specific configuration
    #define GLCD_DB4      PORTC.3            'chip specific configuration
    #define GLCD_DB5      PORTC.2            'chip specific configuration
    #define GLCD_DB6      PORTC.1            'chip specific configuration
    #define GLCD_DB7      PORTC.0            'chip specific configuration</screen>
<simpara>The Great Cow BASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_KS0108</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the GLCD.
The R/W pin can be disabled.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis> <emphasis>(unless R/W is disabled)<?asciidoc-br?>
see</emphasis> <literal>GLCD_NO_RW</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>CS1</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>CS2</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_ENABLE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>Enable</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB0</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB1</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB2</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB3</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB4</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB5</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB5</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB6</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB6</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DB7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to <literal>DB7</literal> on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_NO_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disables read/write inspection of the device during read/write
operations</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, but recommend NOT to set.
The R/W pin can be disabled by setting the <literal>GLCD_NO_RW</literal> constant. If this
is done, there is no need for the R/W to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the R/W line on
the LCD is connected to ground if not used.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not Available for this controller.</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants defined for the controller type are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal>
This constant cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>64</literal>
This constant cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDirection</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Defining this will invert the Y Axis</simpara></entry>
<entry align="center" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KS0108ReadDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is   9
</simpara><simpara>Can be set to improve overall performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KS0108WriteDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Write delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is   1
</simpara><simpara>Can be set to improve performance.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>KS0108ClockDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clock Delay</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 1
</simpara><simpara>Can be set to improve performance.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variables</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 0.
</simpara><simpara>This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="center" valign="top"><simpara>Default is 1.
</simpara><simpara>This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the
table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a KS0108 datasheet, please refer
<link xlink:href="http://www.vishay.com/docs/37329/37329.pdf">here.</link></simpara>
<simpara>This example shows how to drive a KS0108 based Graphic LCD module with
the built in commands of Great Cow BASIC. See
<link xlink:href="http://www.greatcowbasic.com/sample-projects.html">Graphic LCD</link> for
details, this is an external web site.</simpara>
<screen>    ;Chip Settings
    #chip 16F886,16
    '#config MCLRE = on 'enable reset switch on CHIPINO
    #include &lt;GLCD.h&gt;

    ;Defines (Constants)
    #define GLCD_RW PORTB.1  'D9 to pin 5 of LCD
    #define GLCD_RESET PORTB.5 'D13 to pin 17 of LCD
    #define GLCD_CS1 PORTB.3 'D12 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_CS2 PORTB.4 'D11 to actually since CS1, CS2 can be reversed on some devices
    #define GLCD_RS PORTB.0  'D8 to pin 4 D/I pin on LCD
    #define GLCD_ENABLE PORTB.2 'D10 to Pin 6 on LCD
    #define GLCD_DB0 PORTC.7 'D0 to pin 7 on LCD
    #define GLCD_DB1 PORTC.6 'D1 to pin 8 on LCD
    #define GLCD_DB2 PORTC.5 'D2 to pin 9 on LCD
    #define GLCD_DB3 PORTC.4 'D3 to pin 10 on LCD
    #define GLCD_DB4 PORTC.3 'D4 to pin 11 on LCD
    #define GLCD_DB5 PORTC.2 'D5 to pin 12 on LCD
    #define GLCD_DB6 PORTC.1 'D6 to pin 13 on LCD
    #define GLCD_DB7 PORTC.0 'D7 to pin 14 on LCD

    Do forever
        GLCDCLS
        GLCDPrint 0,10,"Hello" 'Print Hello
        wait 5 s
        GLCDPrint 0,10, "ASCII #:" 'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 15 to 129            'Print 0 through 9
          GLCDPrint 17, 20 , Str(char)+"  "
          GLCDdrawCHAR 20,30, char
          wait 125 ms
        next
        line 0,50,127,50                'Draw Line using line command
        for xvar = 0 to 80            'draw line using Pset command
            pset xvar,63,on                    '
        next                                        '
        Wait 1 s
        GLCDPrint 0,10,"End  " 'Print Hello
        wait 1 s
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_pcd8544_controllers">
<title>PCD8544 Controllers</title>
<simpara>This section covers GLCD devices that use the PCD844 graphics controller.<?asciidoc-br?></simpara>
<simpara>The PCD8544 is a low power CMOS LCD controller/driver,
designed to drive a graphic display of 48 rows and
84 columns.  All necessary functions for the display are
provided in a single chip, including on-chip generation of
LCD supply and bias voltages, resulting in a minimum of
external components and low power consumption.
The PCD8544 interfaces to microcontrollers through a
serial bus interface.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the PCD844 controller. &#160;&#160;&#160;Great Cow BASIC supports SPI software connectivity only - this is shown in the tables below.</simpara>
<simpara>The PCD8544 is a monochrome device.</simpara>
<simpara>The PCD844can operate in two modes. Full GLCD mode and Text/JPG mode the full GLCD mode requires a minimum of 512 bytes.  For microcontrollers with limited memory the text only can be selected by setting the correct constant.</simpara>
<simpara>To use the PCD844 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #define GLCD_TYPE GLCD_TYPE_PCD8544

    ' Pin mappings for software SPI for Nokia 3310 Device
    #define GLCD_DO     portc.5              'example port setting
    #define GLCD_SCK    portc.3              'example port setting
    #define GLCD_DC     portc.2              'example port setting
    #define GLCD_CS     portc.1              'example port setting
    #define GLCD_RESET  portc.0              'example port setting</screen>
<simpara>The Great Cow BASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_PCD8544</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_D0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_PCD8544_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with less then 1kb of RAM this will be set be
default.</simpara></entry>
<entry align="center" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PCD8544ClockDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the clock delay, if required for slower microcontroller,</simpara></entry>
<entry align="center" valign="top"><simpara>Optional. Set to 0 as the default value</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PCD8544WriteDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the write delay, if required for slower microcontroller,</simpara></entry>
<entry align="center" valign="top"><simpara>Optional. Set to 0 as the default value</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara>160<?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara>128<?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>*For a PCD8544 datasheet, please refer
<link xlink:href="https://www.google.co.uk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0CCMQFjAA&amp;url=https%3A%2F%2Fwww.sparkfun.com%2Fdatasheets%2FLCD%2FMonochrome%2FNokia5110.pdf&amp;ei=bmjDVKePM83datDIgYgH&amp;usg=AFQjCNFa7N9WMhSg849oXejlfP3FRvQqpA&amp;sig2=ZFpG-ubTxvrBRAV4dRvhVw">here</link><?asciidoc-br?></simpara>
<simpara>This example shows how to drive a PCD8544 based Graphic LCD module with the built in commands of Great Cow BASIC.</simpara>
<simpara>Example:</simpara>
<screen>    #chip 16lf1939,32
    #config Osc = INT, MCLRE_ON, PLLEN_Off, CLKOUTEN_OFF

        #include &lt;glcd.h&gt;

        #DEFINE GLCD_TYPE GLCD_TYPE_PCD8544

          ' Pin mappings for software SPI for Nokia 3310 Device
              #define GLCD_DO portc.5
              #define GLCD_SCK portc.3
              #define GLCD_DC portc.2
              #define GLCD_CS portc.1
              #define GLCD_RESET portc.0


          GLCDCLS

          DO forever
             for CCount = 31 to 127
                  GLCDPrint (0, 0, "PrintStr")
                  GLCDDrawString (0, 9, "DrawStr")
                  GLCDPrint ( 44 ,  21, "     ")
                  GLCDPrint ( 44 ,  29, "     ") ' word value
                  GLCDPrint ( 44 ,  37, "   ") ' Byte value

                  outstring = hex( longNumber_U)
                  GLCDPrint ( 44 , 21,outstring )
                  outstring = hex( longNumber_H)
                  GLCDPrint ( 55 , 21, outstring)
                  outstring = hex( longNumber)
                  GLCDPrint ( 67 , 21,  outstring )
                  GLCDPrint ( 44 , 29, mid( str(wordNumber),1, 6))
                  GLCDPrint ( 44 , 37, byteNumber)

                  box 46,9,57,19
                  GLCDDrawChar(48, 9, CCount )
                  outString = str( CCount )
                  ' draw a box to overwrite existing strings
                  FilledBox(58,9,GLCD_WIDTH-1,17,GLCDBackground )
                  GLCDDrawString(58, 9, outString )

                   box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1
                   box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH- 1, GLCD_HEIGHT-1
                   filledbox 2,30,6,38, wordNumber
                   Circle( 25,30,8,1)            ;center
                   FilledCircle( 25,30,4,longNumber xor 1) ;center

                   line 0,  GLCD_HEIGHT-1 , GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1
                   line  GLCD_WIDTH/2, (GLCD_HEIGHT /2) +1 ,0, (GLCD_HEIGHT /2) +1


                  longNumber = longNumber + 7
                  wordNumber = wordNumber + 3
                  byteNumber++
              NEXT
          LOOP

      end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt; and &lt;glcd_PCD8544.h&gt;</simpara>
</section>
<section xml:id="_sdd1289_controllers">
<title>SDD1289 Controllers</title>
<simpara>This section covers GLCD devices that use the SDD1289 graphics controller.  The SDD1289 is a 240 x 320 single chip controller driver IC for 262k color (RGB) amorphous TFT LCD.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the SDD1289 controller. &#160;&#160;&#160;Great Cow BASIC supports SPI hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the SDD1289 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</screen>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Constants</entry>
<entry align="left" valign="top">Controls</entry>
<entry align="left" valign="top">Default</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SDD1289</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS)  on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><literal>GLCD_WIDTH</literal></entry>
<entry align="left" valign="top">The width parameter of the GLCD</entry>
<entry align="left" valign="top"></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
<entry align="left" valign="top">Example</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour as 0 or 1]</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2,  [Optional In LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte ( LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SDD1289_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>      SSD1289_BLACK   'hexidecimal value 0x0000
      SSD1289_RED     'hexidecimal value 0xF800
      SSD1289_GREEN   'hexidecimal value 0x07E0
      SSD1289_BLUE    'hexidecimal value 0x001F
      SSD1289_WHITE   'hexidecimal value 0xFFFF
      SSD1289_PURPLE  'hexidecimal value 0xF11F
      SSD1289_YELLOW  'hexidecimal value 0xFFE0
      SSD1289_CYAN    'hexidecimal value 0x07FF
      SSD1289_D_GRAY  'hexidecimal value 0x528A
      SSD1289_L_GRAY  'hexidecimal value 0x7997
      SSD1289_SILVER  'hexidecimal value 0xC618
      SSD1289_MAROON  'hexidecimal value 0x8000
      SSD1289_OLIVE   'hexidecimal value 0x8400
      SSD1289_LIME    'hexidecimal value 0x07E0
      SSD1289_AQUA    'hexidecimal value 0x07FF
      SSD1289_TEAL    'hexidecimal value 0x0410
      SSD1289_NAVY    'hexidecimal value 0x0010
      SSD1289_FUCHSIA 'hexidecimal value 0xF81F</screen>
<simpara>For a SDD1289 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/SDD1289.pdf">here</link>.<?asciidoc-br?></simpara>
<simpara>This example shows how to drive a SDD1289 based Graphic LCD module with the built in commands of Great Cow BASIC.<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config Osc = INT, VCAPEN_OFF, MCLRE_ON, PLLEN_ON, CLKOUTEN_OFF

    #include &lt;glcd.h&gt;

    'Defines for SDD1289
    #define GLCD_TYPE GLCD_TYPE_SDD1289
    'Pin mappings for SDD1289
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the SDD1289 Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> OR <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_sh1106_controllers">
<title>SH1106 Controllers</title>
<simpara>This section covers GLCD devices that use the SH1106 graphics controller.  THe SH1106 is a single-chip CMOS OLED/PLED driver with controller for organic/polymer light emitting diode dot-matrix graphic display system.  SH1106 consists of 132 segments, 64 commons that can support a maximum display resolution of 132 X 64. It is designed for Common Cathode type OLED panel.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the SH1106 controller. &#160;&#160;&#160;Great Cow BASIC supports i2C hardware and software connectivity  - this is shown in the tables below.</simpara>
<simpara>The SH1106 is a monochrome device.</simpara>
<simpara>To use the SH1106 driver simply include the following in your user code.  This will initialise the driver.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 byte GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</simpara>
<screen>    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE        'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY        'select Text mode of operation

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master</screen>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="40*"/>
<colspec colname="col_3" colwidth="40*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SH1106</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_I2C_Address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I2C address of the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2C_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>400 or 100</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_DATA</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2C_DATA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Mandated, plus<?asciidoc-br?>
<literal>HI2CMode Master</literal> is required.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>64</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with low RAM this will be set be
default.<?asciidoc-br?>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <literal>GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="center" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in Low Memory mode.</simpara></entry>
<entry align="center" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <literal>GLCD_Close_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction 0, 7</literal> where 0 and 7 are the range of pages to be updated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must follow a <literal>GLCD_Open_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The additional Great Cow BASIC commands for this GLCD are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetDisplayInvertMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Inverts the display</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDSetDisplayNormalMode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the display to normal mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetContrast ( dim_state )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the constrast between 0 and 255. The contrast increases as the value increases.<?asciidoc-br?>
Parameter is dim value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a SH1106 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/SH1106.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a SH1106 based Graphic LCD module with the built in commands of Great Cow BASIC.</simpara>
<screen>; ----- Configuration
    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "Great Cow BASIC"
    GLCDPrint (0, 16, "Anobium 2016")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end</screen>
<simpara>This example shows how to drive a SH1106 based Graphic I2C LCD module with the built in commands of Great Cow BASIC using Low Memory Mode GLCD.</simpara>
<simpara>Note the use of <literal>GLCD_Open_PageTransaction</literal> and <literal>GLCD_Close_PageTransaction</literal> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <literal>GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE</literal> and <literal>GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY</literal> are included in the user program.</simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SH1106  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "Great Cow BASIC"
       GLCDPrint (0, 16, "Anobium 2017")
    GLCD_Close_PageTransaction
    wait 3 s
    GLCDCLS

    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_ssd1306_controllers">
<title>SSD1306 Controllers</title>
<simpara>This section covers GLCD devices that use the SSD1306 graphics controller.</simpara>
<simpara>The SSD1306 is a single-chip CMOS OLED/PLED driver with controller for organic / polymer light emitting diode dot-matrix graphic display system. It consists of 128 segments and 64 commons. This IC is designed for Common Cathode type OLED panel.</simpara>
<simpara>The SSD1306 embeds with contrast control, display RAM and oscillator, which reduces the number of external components and power consumption. It has 256-step brightness control. Data/Commands are sent from general MCU through the hardware selectable 6800/8000 series compatible Parallel Interface, I2C interface or Serial Peripheral Interface. It is suitable for many compact portable applications, such as mobile phone sub-display, MP3 player and calculator, etc.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the SSD1306 controller. &#160;&#160;&#160;Great Cow BASIC supports SPI and I2C hardware &amp; software connectivity  - this is shown in the tables below.</simpara>
<simpara>To use the SSD1306 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<simpara>The SSD1306 library supports 128 * 64 pixels or 128 * 32 pixels.  The default is 128 * 64 pixels.</simpara>
<simpara>The SSD1306 is a monochrome device.</simpara>
<simpara>The SSD1306 can operate in three modes. Full GLCD mode, Low Memory GLCD mode or Text/JPG mode the full GLCD mode requires a minimum of 1k bytes or 512 bytes for the 128x64 and the 128x32 devices respectively in Full GLCD mode.  For microcontrollers with limited memory the third mode of operation - Text mode.  These can be selected by setting the correct constant.</simpara>
<simpara>To use the SSD1306 drivers simply include one of the following configuration.  You can select Full Mode GLCD, Low Memory Mode GLCD or Text mode these require 1024, 128 or 0 byte GLCD buffer respectively - you microcontroller requires sufficient RAM to support the selected mode of GLCD operation.</simpara>
<screen>    'An I2C configuration
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306
    #define GLCD_I2C_Address 0x78
    '#define GLCD_TYPE_SH1106_LOWMEMORY_GLCD_MODE       'select Low Memory mode of operation
    '#define GLCD_TYPE_SH1106_CHARACTER_MODE_ONLY       'select Text mode of operation


    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master</screen>
<simpara>or,</simpara>
<screen>    'An SPI configuration'
    #include &lt;glcd.h&gt;

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306

    ; ----- Define Hardware settings
    #define S4Wire_DATA

    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306  PortB.2
    #define DC_SSD1306   PortB.3
    #define CS_SSD1306   PortB.4
    #define RES_SSD1306  PortB.5</screen>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_I2C_Address</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I2C address of the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for SPI/S4Wire control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required to support 128 * 64 pixels.  Mutualy exclusive to GLCD_TYPE_SSD1306_32</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306_32</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required to support 128 * 32 pixels.  Mutualy exclusive to GLCD_TYPE_SSD1306</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>S4Wire_Data</literal></simpara></entry>
<entry align="left" valign="top"><simpara>4 wire SPI Mode</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MOSI_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to serial data in D1 pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SCK_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to serial clock D0 pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>DC_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to data control DC pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>CS_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to chip select CS pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RES_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies output pin connected to reset RES pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>128</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>64</literal> or <literal>32</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_PROTECTOVERRUN</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Define this constant to restrict pixel operations with the pixel limits</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in text mode and BMP
draw mode only.<?asciidoc-br?>
For microcontrollers with low RAM this will be set be
default.<?asciidoc-br?>
When selected ONLY text related commands are suppored. For grapical commands you must have sufficient memory to use Full GLCD mode or use <literal>GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies that the display controller will operate in Low Memory mode.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC variables for control display characteristics are shown in the table below.
These variables control the user definable parameters of a specific GLCD.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Variable</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Type</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDBackground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>GLCD background state.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is White or 0x0001.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDForeground</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Color of GLCD foreground.</simpara></entry>
<entry align="left" valign="top"><simpara>A monochrome value.<?asciidoc-br?>
For mono GLCDs the default is non-white or 0x0000.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Width of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 6 pixels.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefault</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 0.
</simpara><simpara></simpara><simpara>This equates to the standard GCB font set.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDfntDefaultsize</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Size of the current GLCD font.</simpara></entry>
<entry align="left" valign="top"><simpara>Default is 1.
</simpara><simpara></simpara><simpara>This equates to the 8 pixel high.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the
table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Open_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must be followed a  <literal>GLCD_Close_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction 0, 7</literal> where 0 and 7 are the range of pages to be updated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Close_PageTransaction</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Commence a series of GLCD commands when in low memory mode.  Must follow a <literal>GLCD_Open_PageTransaction</literal> command.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC specific commands for this GLCD are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Purpose</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Stopscroll_SSD1306</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Stops all scrolling</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrollright_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a right handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrollright_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>, <literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrollleft_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a left handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrollleft_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>, <literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrolldiagright_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a diagright handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrolldiagright_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>, <literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Startscrolldiagleft_SSD1306 ( start , stop [,scrollspeed] )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Activate a diagleft handed scroll for rows start through stop
Hint, the display is 16 rows tall. To scroll the whole display, execute:<?asciidoc-br?>
<literal>startscrolldiagleft_SSD1306(0x00, 0x0F)</literal><?asciidoc-br?>
Parameters are <literal>Start row</literal>,<literal>End row</literal>, optionally <literal>Scrollspeed</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetContrast ( dim_state )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the constrast between 0 and 255. The contrast increases as the value increases.<?asciidoc-br?>
Parameter is dim value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a SSD1306 datasheet, please refer <link xlink:href="http://gcbasic.sourceforge.net/library/DISPLAY/SSD1306.pdf">here</link>.</simpara>
<simpara>This example shows how to drive a SSD1306 based Graphic I2C LCD module with the built in commands of Great Cow BASIC using Full Mode GLCD</simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78

    dim outString as string * 21

    GLCDCLS
    GLCDPrint 0, 0, "Great Cow BASIC"
    GLCDPrint (0, 16, "Anobium 2015")

    wait 3 s
    GLCDCLS

    ' Prepare the static components of the screen
    GLCDPrint ( 0,   0, "PrintStr") ; Print some text
    GLCDPrint ( 64,  0, "@")
    ; Print some more text
    GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
    GLCDPrint ( 86, 0, "Mhz") ; Print some text
    GLCDDrawString( 0,8,"DrawStr") ; Draw some text
    box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
    Circle( 44,41,15) ; Draw a circle
    line 64,31,0,31 ; Draw a line

    DO forever
       for CCount = 31 to 127
            GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
            GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
            GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
            GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
            GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

            GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
            GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

            box (46,9,56,19) ; Draw a Box
            GLCDDrawChar(48, 9, CCount ) ; Draw a character
            outString = str( CCount ) ; Prepare a string
            GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

            filledbox 3,43,11,51, wordNumber ; Draw a filled box

            FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
            line 0,63,64,31 ; Draw a line

            ; Do some simple maths
            longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
        NEXT
    LOOP
    end</screen>
<simpara>This example shows how to drive a SSD1306 based Graphic I2C LCD module with the built in commands of Great Cow BASIC using Low Memory Mode GLCD.</simpara>
<simpara>Note the use of <literal>GLCD_Open_PageTransaction</literal> and <literal>GLCD_Close_PageTransaction</literal> to support the Low Memory Mode of operation and the contraining of all GLCD commands with the transaction commands.  The use Low Memory Mode GLCD the two defines <literal>GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE</literal> and <literal>GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY</literal> are included in the user program.</simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306  'for 128 * 64 pixels support
    #define GLCD_I2C_Address 0x78
    #define GLCD_TYPE_SSD1306_LOWMEMORY_GLCD_MODE
    #define GLCD_TYPE_SSD1306_CHARACTER_MODE_ONLY

    dim outString as string * 21

    GLCDCLS
    GLCD_Open_PageTransaction 0,7
       GLCDPrint 0, 0, "Great Cow BASIC"
       GLCDPrint (0, 16, "Anobium 2017")
    GLCD_Close_PageTransaction
    wait 3 s
    GLCDCLS

    DO forever

      for CCount = 31 to 127

        outString = str( CCount ) ; Prepare a string

        GLCD_Open_PageTransaction 0,7

           ' Prepare the static components of the screen
           GLCDPrint ( 0,   0, "PrintStr") ; Print some text
           GLCDPrint ( 64,  0, "@")
           ; Print some more text
           GLCDPrint ( 72,  0, ChipMhz) ; Print chip speed
           GLCDPrint ( 86, 0, "Mhz") ; Print some text
           GLCDDrawString( 0,8,"DrawStr") ; Draw some text
           box 0,0,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           box GLCD_WIDTH-5, GLCD_HEIGHT-5,GLCD_WIDTH-1, GLCD_HEIGHT-1 ; Draw a box
           Circle( 44,41,15) ; Draw a circle
           line 64,31,0,31 ; Draw a line

           GLCDPrint ( 64 ,  36,  hex(longNumber_E ) ) ; Print a HEX string
           GLCDPrint ( 76 ,  36,  hex(longNumber_U ) ) ; Print a HEX string
           GLCDPrint ( 88 ,  36,  hex(longNumber_H ) ) ; Print a HEX string
           GLCDPrint ( 100 ,  36, hex(longNumber   ) ) ; Print a HEX string
           GLCDPrint ( 112 ,  36, "h" ) ; Print a HEX string

           GLCDPrint ( 64 ,  44, pad(str(wordNumber), 5 ) ) ; Print a padded string
           GLCDPrint ( 64 ,  52, pad(str(byteNumber), 3 ) ) ; Print a padded string

           box (46,8,56,19) ; Draw a Box
           GLCDDrawChar(48, 9, CCount ) ; Draw a character

           GLCDDrawString(64, 9, pad(outString,3) ) ; Draw a string

           filledbox 3,43,11,51, wordNumber ; Draw a filled box

           FilledCircle( 44,41,9, longNumber xor 1) ; Draw a filled box
           line 0,63,64,31 ; Draw a line

        GLCD_Close_PageTransaction

        ; Do some simple maths
        longNumber = longNumber + 7 : wordNumber = wordNumber + 3 : byteNumber++
       NEXT
    LOOP
    end</screen>
<simpara>This example shows how to drive a SSD1306 based Graphic SPI LCD module with the built in commands of Great Cow BASIC.</simpara>
<screen>    'Chip model
    #chip mega328p, 16
    #include &lt;glcd.h&gt;

    'Defines for a 7 pin SPI module
    'RES pin is pulsed low in glcd_SSD1306.h for proper startup
    #define MOSI_SSD1306 PortB.1
    #define SCK_SSD1306 PortB.2
    #define DC_SSD1306 PortB.3
    #define CS_SSD1306 PortB.4
    #define RES_SSD1306 PortB.5
    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306   'for 128 * 64 pixels support
    #define S4Wire_DATA

    dim longnumber as Long
    longnumber = 123456
    dim wordnumber as word
    wordnumber = 62535
    dim bytenumber as Byte
    bytenumber =255

    #define led PortB.0
    dir led out


    Do
         SET led ON
         wait 1 s
         SET led OFF

        GLCDCLS
        GLCDPrint (30, 0, "Hello World!")
        Circle (18,24,10)
        FilledCircle (48,24,10)
        Box (70,14,90,34)
        FilledBox (106,14,126,34)
        GLCDDrawString (32,35,"Draw String")
        GLCDPrint (0,46,longnumber)
        GLCDPrint (94,46,wordnumber)
        GLCDPrint (52,55,bytenumber)
        Line (0,40,127,63)
        Line (0,63,127,40)
        wait 3 s

    Loop</screen>
<simpara>This example shows how to drive a SSD1306 based Graphic I2C LCD module with 128 * 32 pixel support.</simpara>
<screen>    #chip mega328p,16
    #include &lt;glcd.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA
    HI2CMode Master

    ; ----- Define GLCD Hardware settings
    #define GLCD_TYPE GLCD_TYPE_SSD1306_32  'for 128 * 32 pixels support
    #define GLCD_I2C_Address 0x78

    GLCDCLS
    GLCDPrint 0, 0, "Great Cow BASIC"
    GLCDPrint (0, 16, "Anobium 2017")</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_st7735_controllers">
<title>ST7735 Controllers</title>
<simpara>This section covers GLCD devices that use the ST7735 graphics controller.  The ST7735 is a single-chip controller/driver for 262K-color, graphic type TFT-LCD.</simpara>
<simpara>The Great Cow BASIC constants shown below control the configuration of the ILI9340 controller. &#160;&#160;&#160;Great Cow BASIC supports an 8 bit bus connectivity. The 8 bit must be a single port of consective bits  - this is shown in the tables below.</simpara>
<simpara>To use the ST7735 driver simply include the following in your user code.  This will initialise the driver.</simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7735

    'Pin mappings for ST7735
    #define GLCD_DC     porta.0           'example port setting
    #define GLCD_CS     porta.1           'example port setting
    #define GLCD_RESET  porta.2           'example port setting
    #define GLCD_DI     porta.3           'example port setting
    #define GLCD_DO     porta.4           'example port setting
    #define GLCD_SCK    porta.5           'example port setting</screen>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7735</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Not Available for this controller.</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data/Command IO pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_CS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Chip Select (CS) on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_Reset</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset pin on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DI</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data In (GLCD out) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_D0</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Data Out (GLCD in) pin on
the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_SLK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Clock (CLK) pin on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below.<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>160</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal><?asciidoc-br?>
This cannot be changed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the table below.&#160;&#160;&#160;Always review the appropiate library for the latest full set of supported commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7735_[color]</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specify color as a parameter for many GLCD commands</simpara></entry>
<entry align="left" valign="top"><simpara>Color constants for this device are shown in the list below.<?asciidoc-br?>
</simpara><simpara></simpara><simpara> Any color can be defined using a valid hexidecimal word value between 0x0000 to 0xFFFF.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<screen>   ST7735_BLACK   'hexidecimal value 0x0000
   ST7735_BLUE    'hexidecimal value 0xF800
   ST7735_RED     'hexidecimal value 0x001F
   ST7735_GREEN   'hexidecimal value 0x07E0
   ST7735_CYAN    'hexidecimal value 0xFFE0
   ST7735_MAGENTA 'hexidecimal value 0xF81F
   ST7735_YELLOW  'hexidecimal value 0x07FF
   ST7735_WHITE   'hexidecimal value 0xFFFF</screen>
<simpara>For a ST7735 datasheet, please refer
<link xlink:href="http://www.crystalfontz.com/controllers/ST7735_V2.1_20100505.pdf">here.</link></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config Osc = INT, VCAPEN_OFF, MCLRE_ON, PLLEN_ON, CLKOUTEN_OFF

    #include &lt;glcd.h&gt;

    'Defines for ST7735
    #define GLCD_TYPE GLCD_TYPE_ST7735
    'Pin mappings for ST7735
    #define GLCD_DC porta.0
    #define GLCD_CS porta.1
    #define GLCD_RESET porta.2
    #define GLCD_DI porta.3
    #define GLCD_DO porta.4
    #define GLCD_SCK porta.5

    GLCDPrint(0, 0, "Test of the ST7735 Device")
    end</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
</section>
<section xml:id="_st7920_controllers">
<title>ST7920 Controllers</title>
<simpara>This section covers GLCD devices that use the ST7920 graphics controller.</simpara>
<simpara>The Great Cow BASIC constants for control of the connectivity are shown
in the table below. The only connectivity option the 8-bit mode where 8
pins are connected between the microcontroller and the GLCD to control the
data bus.<?asciidoc-br?></simpara>
<simpara>The ST7920 GLCD is graphica and character mixed mode display.<?asciidoc-br?></simpara>
<simpara>ST7920 LCD controller/driver IC can display alphabets, numbers, Chinese
fonts and self-defined characters.&#160;&#160;&#160;It supports 3 kinds of bus interface,
namely 8-bit, 4-bit and serial.&#160;&#160;&#160;Great Cow BASIC is currently supports
8-bit only. For LCD only operations (text characters only) you can use
the Great Cow BASIC LCD routines.<?asciidoc-br?></simpara>
<simpara>All functions, including display RAM, Character Generation ROM, LCD
display drivers and control circuits are all in a one-chip solution.
With a minimum system configuration, a Chinese character display system
can be easily achieved.<?asciidoc-br?></simpara>
<simpara>The ST7920 includes character ROM with 8192 16x16 dots Chinese fonts and
126 16x8 dots half-width alphanumerical fonts.&#160;&#160;&#160;It supports 64x256 dots
graphic display area for graphic display (GDRAM).&#160;&#160;&#160;Mix-mode display with
both character and graphic data is possible.&#160;&#160;&#160;ST7920 has built-in CGRAM
and provide 4 sets software programmable 16x16 fonts.<?asciidoc-br?></simpara>
<simpara>To use the ST7920 driver simply include the following in your user code.  This will initialise the driver.<?asciidoc-br?></simpara>
<screen>    #include &lt;glcd.h&gt;
    #DEFINE GLCD_TYPE GLCD_TYPE_ST7920

    #define GLCD_Enable     PORTA.1           'example port setting
    #define GLCD_RS         PORTa.0           'example port setting
    #define GLCD_RW         PORTA.2           'example port setting
    #define GLCD_RESET      PORTA.3           'example port setting
    #define GLCD_DATA_PORT  PORTD             'example port setting</screen>
<simpara>The Great Cow BASIC constants for the interface to the controller are shown in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCD_TYPE_ST7920</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output port that is connected between the microcontroller
and the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the GLCD.
The R/W pin can be disabled*.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis> <emphasis>unless R/W is disabled), see</emphasis> <literal>GLCD_NO_RW</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_RESET</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Reset on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_ENABLE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Enable on the GLCD.</simpara></entry>
<entry align="left" valign="top"><simpara>Required</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ST7920WriteDelay</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set the time delay between data transmissions.</simpara></entry>
<entry align="left" valign="top"><simpara>Required, set to <literal>20 us</literal> for <literal>32Mhz</literal> support. Can be reduced for slower chip
speeds.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_NO_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Disables read/write inspection of the device during read/write
operations</simpara></entry>
<entry align="left" valign="top"><simpara>Optional, but recommend NOT to set.
The R/W pin can be disabled by setting the <literal>GLCD_NO_RW</literal> constant. If this
is done, there is no need for the <literal>R/W</literal> to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the <literal>R/W</literal> line on
the LCD is connected to ground if not used.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC constants for control display characteristics are shown in the table below. <?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Default</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_WIDTH</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The width parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>128</literal><?asciidoc-br?>
 Cannot be changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCD_HEIGHT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The height parameter of the GLCD</simpara></entry>
<entry align="center" valign="top"><simpara><literal>64</literal><?asciidoc-br?>
Cannot be changed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDFontWidth</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the font width of the Great Cow BASIC font set.</simpara></entry>
<entry align="center" valign="top"><simpara><literal>6</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC commands supported for this GLCD are shown in the
table below. For device specific see the commands with the prefix of
ST7920*.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clear screen of GLCD</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDCLS</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print string of characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDPrint( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print character on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawChar( Xposition, Yposition, CharCode )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Print characters on GLCD using GCB font set</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDDrawString( Xposition, Yposition, Stringvariable )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Box</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Box ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour as 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>FilledBox</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a box on the GLCD to a specific size that is filled with the
foreground colour.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>FilledBox (Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Line</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Draw a line on the GLCD to a specific length that is filled with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Line ( Xposition1, Yposition1, Xposition2, Yposition2, [Optional In
LineColour 0 or 1] )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PSet</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a pixel on the GLCD at a specific position that is set with the
specific attribute.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PSet(Xposition, Yposition, Pixel Colour 0 or 1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Set a byte value to the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>GLCDWriteByte (LCDByte)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>GLCDReadByte</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Read a byte value from the controller, see the datasheet for usage.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>bytevariable = GLCDReadByte</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a TS7920 datasheet, please refer
<link xlink:href="http://www.crystalfontz.com/controllers/ST7920.pdf">here.</link></simpara>
<simpara>This example shows how to drive a ST7920 based Graphic LCD module with
the built in commands of Great Cow BASIC. See
<link xlink:href="http://www.greatcowbasic.com/sample-projects.html">Graphic LCD</link> for
details, this is an external web site.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config Osc = INT, VCAPEN_OFF, MCLRE_ON, PLLEN_ON, CLKOUTEN_OFF

    #include &lt;glcd.h&gt;

    #define GLCD_TYPE GLCD_TYPE_ST7920
    #define GLCD_IO 8
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 160
    #define GLCDFontWidth 6

    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #define ST7920ReadDelay 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #define ST7920WriteDelay 2

    #define GLCD_RS PORTa.0
    #define GLCD_Enable PORTA.1
    #define GLCD_RW PORTA.2
    #define GLCD_RESET PORTA.3
    #define GLCD_DATA_PORT PORTD

    ST7920GLCDEnableGraphics
    ST7920GLCDClearGraphics
    GLCDPrint 0, 1, "Great Cow BASIC "
    wait 1 s

    GLCDCLS
    ST7920GLCDClearGraphics

    rrun = 0
    dim msg1 as string * 16

    dim  xradius, yordinate , radiusErr, incrementalxradius, orginalxradius, orginalyordinate as Integer


    Do forever
        GLCDCLS
        ST7920GLCDClearGraphics          ;clear screen
        GLCDDrawString 30,0,"ChipMhz@"    ;print string
        GLCDDrawString 78,0, str(ChipMhz) ;print string
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F1937" ;print string
        wait 1 s                  ;wait
        FilledBox( 0,0,128,63)          ;create box
        for ypos = 0 to 63              ;draw row by row
             ST7920lineh 0,ypos,128, 0      ;draw line
        next
        wait 1 s                  ;wait
        ST7920GLCDClearGraphics          ;clear
    loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config Osc = INT, VCAPEN_OFF, MCLRE_ON, PLLEN_ON, CLKOUTEN_OFF

    #include &lt;glcd.h&gt;

    #define GLCD_TYPE GLCD_TYPE_ST7920
    #define GLCD_IO 8
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 160
    #define GLCDFontWidth 6

    ' read delay of 25 is required at 32mhz, this can be reduced to 0 for slower clock speeds
    #define ST7920ReadDelay 25
    ' write delay of 2 is required at 32mhz.  this can be reduced to 1 for slower clock speeds
    #define ST7920WriteDelay 2

    #define GLCD_RS PORTa.0
    #define GLCD_Enable PORTA.1
    #define GLCD_RW PORTA.2
    #define GLCD_RESET PORTA.3
    #define GLCD_DATA_PORT PORTD

    WAIT 1 S
    ST7920GLCDEnableGraphics
    ST7920GLCDClearGraphics
    ST7920Tile "A"
    GLCDPrint 0, 1, "Great Cow BASIC "

    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

    ST7920GLCDEnableGraphics
    ST7920GLCDClearGraphics
    ST7920gTile 0x55, 0x55
    wait 1 s

    ST7920GLCDClearGraphics
    ST7920Lineh(0, 0, GLCD_WIDTH)
    ST7920Lineh(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    ST7920LineV(0, 0, GLCD_HEIGHT)
    ST7920LineV(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    Box 18,30,28,40

    WAIT 2 S

    FilledBox 18,30,28,40

    ST7920GLCDClearGraphics

    Start:

    GLCDDrawString 0,10,"Hello" 'Print Hello
    wait 1 s
    GLCDDrawString 0,10, "ASCII #:" 'Print ASCII #:
    Box 18,30,28,40 'Draw Box Around ASCII Character
    for char = 0x30 to 0x39        'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
    next
    line 0,50,127,50    'Draw Line using line command
    for xvar = 0 to 80  'draw line using Pset command
            pset xvar,63,on                    '
    next
    FilledBox 18,30,28,40 'Draw Box Around ASCII Character
    Wait 1 s
    ST7920GLCDClearGraphics
    GLCDDrawString 0,10,"End  "
    wait 1 s
    ST7920GLCDClearGraphics

    workingGLCDDrawChar:
    ST7920GLCDEnableGraphics
    dim gtext as string
    gtext = "ST7920 @QC12864B"

    for xchar = 1 to gtext(0)  'Print 0 through 9
          xxpos = (1+(xchar*6)-6)
          GLCDDrawChar xxpos , 0 , gtext(xchar)
    next

    GLCDDrawString  1, 9, "Great Cow BASIC @2014"
    GLCDDrawString  1, 18,"GLCD 128*64"
    GLCDDrawString  1, 27,"Using GLCD.H from GCB"
    GLCDDrawString  1, 37,"Using GLCD.H GCB@2014"
    GLCDDrawString  1, 45,"GLCDDrawChar method"
    'GLCDDrawString  1, 54,"ST7920 @QC12864B"
    GLCDDrawString  1, 54,"Test Routines"
    wait 1 s

    ST7920GLCDClearGraphics
    ST7920GLCDDisableGraphics
    GLCDCLS

    msg1 = "Run = " +str(rrun)
    rrun++
    GLCDPrint 0, 0, "ST7920 @QC12864B"
    GLCDPrint 0, 1, "Great Cow BASIC "
    GLCDPrint 0, 2, "GLCD 128*64"
    GLCDPrint 0, 3, msg1
    wait 5 s
    GLCDCLS

    ' show all chars... takes some time!
    ST7920CallBuiltinChar

    ST7920Tile ( 0xa9  )
    wait 1 s
    GLCDCLS

    ' See http://www.khngai.com/chinese/charmap/tblbig.php?page=0
    ' and see https://sourceforge.net/projects/vietunicode/files/hannom/hannom%20v2005/ for the FONTS!!

    dim BIG5code as word

    'ST7920 can display half-width HCGROM fonts, user- defined CGRAM fonts and full 16x16 CGROM fonts. The
    'character codes in 0000H~0006H will use user- defined fonts in CGRAM. The character codes in 02H~7FH will use
    'half-width alpha numeric fonts. The character code larger than A1H will be treated as 16x16 fonts and will be
    'combined with the next byte automatically. The 16x16 BIG5 fonts are stored in A140H~D75FH while the 16x16 GB
    'fonts are stored in A1A0H~F7FFH. In short:
    '1. To display HCGROM fonts:
    'Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    'The data is among 02H~7FH.
    '2. To display CGRAM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'Only 0000H, 0002H, 0004H and 0006H are acceptable.
    '3. To display CGROM fonts:
    'Write 2 bytes of data into DDRAM to display one 16x16 font.
    'A140H~D75FH are BIG5 code, A1A0H~F7FFH are GB code.

    for BIG5code = 0xA140 to 0xA1CF
        ST7920cTile ( BIG5code  )
        wait 5 ms
      next
    GLCDCLS

    'To display HCGROM fonts
    ' Write 2 bytes of data into DDRAM to display two 8x16 fonts. Each byte represents 1 character.
    ' The data is among 02H~7FH.
    ' The english characters set...
    for HCGROM = 0x2h to 0x7f
        ST7920Tile ( HCGROM  )
        ST7920Tile ( HCGROM  )
        wait 5 ms
    next
    GLCDCLS

    linetest1:

      ST7920GLCDEnableGraphics

      ST7920gTile(0x55, 0x55)
      wait 1 s
      ST7920GLCDClearGraphics

    'linehtest:
    '
    ST7920LineH(0, 0, GLCD_WIDTH)
    ST7920LineH(0, GLCD_HEIGHT - 1, GLCD_WIDTH)
    ST7920LineV(0, 0, GLCD_HEIGHT)
    ST7920LineV(GLCD_WIDTH - 1, 0, GLCD_HEIGHT)

    box test
    ST7920LineH(10 ,0 , 118 )
    ST7920LineH(0 ,8 , 128)
    ST7920LineH(16 ,16 , 96 )
    ST7920LineH(10 ,32 , 108 )
    ST7920LineH(0, 16, GLCD_WIDTH)
    ST7920LineH(0, 24, GLCD_WIDTH)
    ST7920LineH(0, 32, GLCD_WIDTH)
    ST7920LineH(0, 40, GLCD_WIDTH)
    ST7920LineH(0, 48, GLCD_WIDTH)
    ST7920LineH(0, 56, GLCD_WIDTH)
    ST7920LineH(0, 63, GLCD_WIDTH)
    ST7920LineV(16, 0, GLCD_HEIGHT)
    ST7920LineV(17, 0, GLCD_HEIGHT)
    ST7920LineV(15, 0, GLCD_HEIGHT)

    ST7920LineV(46, 0, GLCD_HEIGHT)
    ST7920LineV(47, 0, GLCD_HEIGHT)
    ST7920LineV(48, 0, GLCD_HEIGHT)

    ST7920LineV(46, 0, GLCD_HEIGHT)
    ST7920LineV(47, 0, GLCD_HEIGHT)
    ST7920LineV(48, 0, GLCD_HEIGHT)

    ST7920LineV(96, 0, GLCD_HEIGHT)
    ST7920LineV(97, 0, GLCD_HEIGHT)
    ST7920LineV(98, 0, GLCD_HEIGHT

    for HCGROM = 0 to GLCD_WIDTH step 8
        ST7920LineV(HCGROM, 0, GLCD_HEIGHT)
    next

    GraphicTestPlace:

      ST7920GLCDClearGraphics
      ST7920GraphicTest
      ST7920GLCDClearGraphics

      ' Test draw a line
      for yrowpos = 0 to 63 step 4
        ST7920LineH(0, yrowpos, GLCD_WIDTH)
      next

      ST7920GLCDClearGraphics
      ST7920GLCDDisableGraphics
      GLCDCLS

      ST7920SetIcon( 1, 0x55 )

    loop

    sub ST7920CallBuiltinChar
        ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              ST7920WriteData( 0xA1)
              ST7920WriteData( 0x40 + ii)

          next

          wait 1 s

          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              ST7920WriteData( 0xA1)
              ST7920WriteData( 0xb0 + ii)

          next
          wait 1 s
          GLCDCLS

          ' 0xA140 ~ 0xA15F
          for ii = 0 to 31

              ST7920WriteData( 0xA4)
              ST7920WriteData( 0x40 + ii)

          next
          wait 1 s
          GLCDCLS
    end sub</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_glcdcls">GLCDCLS</link>, <link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>, <link linkend="_glcdreadbyte">GLCDReadByte</link>, <link linkend="_glcdwritebyte">GLCDWriteByte</link> or <link linkend="_pset">Pset</link></simpara>
<simpara>Supported in &lt;GLCD.H&gt;</simpara>
<section xml:id="_st7920glcdcleargraphics">
<title>ST7920GLCDClearGraphics</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDClearGraphics</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command clears the GCLD display.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GLCDClearGraphics 'clear the screen</screen>
</section>
<section xml:id="_st7920glcddisablegraphics">
<title>ST7920GLCDDisableGraphics</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDDisableGraphics</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets the GCLD display controller to text mode.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GLCDDisableGraphics 'Set to text mode</screen>
</section>
<section xml:id="_st7920glcdenablegraphics">
<title>ST7920GLCDEnableGraphics</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDEnableGraphics</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets the GCLD display controller to text mode.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GLCDEnableGraphics 'Set to text mode</screen>
</section>
<section xml:id="_st7920graphictest">
<title>ST7920GraphicTest</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GraphicTest</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command tests the graphics functionality of the GLCD display.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920GraphicTest ‘Test the display</screen>
</section>
<section xml:id="_st7920linehs">
<title>ST7920LineHs</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920LineHs ( Xpos, Ypos, XLength, Style)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command draws a line with a specific style. The style is based on
the bits value of the byte passed to the routine.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920LineHs ( 0, 31,128 , 0x55) ‘will draw a dashed line</screen>
</section>
<section xml:id="_st7920locate">
<title>ST7920Locate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920Locate ( Xpos, Ypos)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command locates the pixel at the specific X and Y location of the
text screen. Subsequent printing to the GLCD will place a character to
the GLCD controller on the specified row and column. Due to the design
of the ST7920 controller (to accomodate Mandarin and Cyrillic), you must
place the text on the column according to the numbers above the diagram
below. The addressing is handle by the command.</simpara>
<screen>|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|H |e |l |l |o |  ...                | &lt;- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|T |h |i |s |  |i ...                | &lt;- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|' |' |' |' |' |' ...                | &lt;- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|- |- |- |- |- |- ...                | &lt;- row 3 (address 0x98)

+--+--+--+--+--+---------------------+</screen>
<simpara>Writing 'a' onto the 1st column, and 1st row:</simpara>
<screen>|--0--|--1--|--2--|...      ...|--7--|

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | &lt;- row 0 (address 0x80)

+--+--+--+--+--+---------------------+

|  |  |a |  |  |  ...                | &lt;- row 1 (address 0x90)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                 | &lt;- row 2 (address 0x88)

+--+--+--+--+--+---------------------+

|  |  |  |  |  |  ...                | &lt;- row 3 (address 0x98)

+--+--+--+--+--+---------------------+</screen>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920Locate ( 64, 31) ‘the pixel at the mid screen point</screen>
</section>
<section xml:id="_st7920tile">
<title>ST7920Tile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920Tile ( word variable )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command tiles the screen with the word value provided.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    Dim tileValue as word
    tileValue = (0x55 * 256 ) + 0x55
    ST7920Tile (tileValue) ‘tile the screen with a nice cross hatch</screen>
</section>
<section xml:id="_st7920ctile">
<title>ST7920cTile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  ST7920cTile ( word variable )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Tiles screen with a Chinese Symbol.</simpara>
<simpara>This required 2 bytes of data into DDRAM to display one 16x16 font from
memory location A140H~D75FH are BIG5 code, A1A0H~F7FFH are GB code.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    Dim CTileValue as word
    cTileValue = (0xA140H * 256 ) + 0xA140H
    ST7920Tile (CTileValue) ‘tile the screen with a nice cross hatch</screen>
</section>
<section xml:id="_st7920glocate">
<title>ST7920gLocate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920gLocate ( Xpos, Ypos)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command locates the pixel at the specific X and Y location of the
graphical screen.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920gLocate ( 64, 31) ‘the pixel at the mid screen point</screen>
</section>
<section xml:id="_st7920gtile">
<title>ST7920gTile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920gTile ( byte variable , byte variable)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Tile LCD screen with two bytes in Graphic Mode.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920gTile (0x55, 0x85) ‘tile the screen with an odd cross hatch</screen>
</section>
<section xml:id="_st7920lineh">
<title>ST7920lineh</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command draws a horizontal line with the specific style. The style
can be ON or OFF. Default is ON.</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920lineh ( 0, 31,128 , ON) ‘will draw a line</screen>
</section>
<section xml:id="_st7920linev">
<title>ST7920linev</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920lineh ( Xpos, Ypos, xUnitsStyle, )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command draws a vertical line with the specific style. The style
can be ON or OFF. Default is ON</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ST7920lineh ( 0, 31,128 , ON) ‘will draw a line</screen>
</section>
<section xml:id="_st7920glcdreadbyte">
<title>ST7920GLCDReadByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_variable = ST7920GLCDReadByte</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function return the word value (16 bits) of the GLCD display for
the current XY position.</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte</screen>
</section>
<section xml:id="_st7920writebyte">
<title>ST7920WriteByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GLCDWriteByte</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command write to the appropriate location as specified by the
current XY position.</simpara>
<simpara>This is called by the GLCD common routines.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...

    SET GLCD_RS OFF

    ST7920WriteByte( SysCalcPositionY )
    ST7920WriteByte( SysCalcPositionX )
    ' read data
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = ST7920GLCDReadByte
    GLCDDataTempWord = (GLCDDataTempWord*256) + ST7920GLCDReadByte
    ...</screen>
</section>
<section xml:id="_st7920writecommand">
<title>ST7920WriteCommand</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GWriteCommand ( byte_variable)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command writes a command to the controller.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...
    ST7920WriteCommand(0x36) ' set the graphics mode on
    GLCD_TYPE_ST7920_GRAPHICS_MODE = true
    ...</screen>
</section>
<section xml:id="_st7920writedata">
<title>ST7920WriteData</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ST7920GWriteData ( byte_variable)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command writes data to the controller.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...
    for yy = 0 to ( GLCD_HEIGHT - 1 )
      ST7920gLocate(0, yy)
      for xx = 0 to ( GLCD_COLS -1 )
        ST7920WriteData( 0x55 )
        T7920WriteData( 0x55 )
      next
    next
    ...</screen>
</section>
<section xml:id="_st7920greaddata">
<title>ST7920gReaddata</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_variable = ST7920gReaddata</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function return the word value (16 bits) of the GLCD display for
the current XY position.</simpara>
<simpara>See the data sheet for more information.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    ...
    ' Read a word from the display device.
    word_variable = ST7920GLCDReadData</screen>
</section>
</section>
</section>
<section xml:id="_box">
<title>Box</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Box(LineX1,LineY1, LineX2, LineY2 [, LineColour ] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a box on a graphic LCD from the upper corner of pixel position X1, Y1 location to
pixel position X2,Y2 location.</simpara>
<simpara><literal>LineColour</literal> can be specified.  Typical the value is 0 or 1 for GLCDForeGround and GLCDBackGround respectively.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_filledbox">FilledBox</link></simpara>
</section>
<section xml:id="_circle">
<title>Circle</title>
<simpara><emphasis role="strong">Circle:</emphasis></simpara>
<screen>    Circle(XPixelPosition, YPixelPosition, Radius [ [,Optional LineColour] [,Optional Rounding] ] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a circle on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific <literal>Radius</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent circles from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    circle(10,10,10)  ;upper left
    circle(117,10,10) ;upper right
    circle(63,31,10)  ;center
    circle(63,31,20)  ;center
    circle(10,53,10)  ;lower left
    circle(117,53,10) ;lower right</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/circleb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_ellipse">
<title>Ellipse</title>
<simpara><emphasis role="strong">Ellipse:</emphasis></simpara>
<screen>    Ellipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a Ellipse on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific vertex of <literal>XRadius</literal> and <literal>YRadius</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent Ellipses from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    Ellipse(63, 31, 20, 10)</screen>
</section>
<section xml:id="_filledbox">
<title>FilledBox</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    FilledBox(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a filled box on a graphic LCD from the upper corner of pixel X1, Y1
location to pixel X2,Y2 location.<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_box">Box</link></simpara>
</section>
<section xml:id="_filledcircle">
<title>FilledCircle</title>
<simpara><emphasis role="strong">Circle:</emphasis></simpara>
<screen>    FilledCircle(XPixelPosition, YPixelPosition, Radius [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a circle on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific <literal>Radius</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    filledcircle(10,10,10)  ;upper left
    filledcircle(117,10,10) ;upper right
    filledcircle(63,31,10)  ;center
    filledcircle(63,31,20)  ;center
    filledcircle(10,53,10)  ;lower left
    filledcircle(117,53,10) ;lower right</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/filledcircleb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_filledellipse">
<title>FilledEllipse</title>
<simpara><emphasis role="strong">FilledEllipse:</emphasis></simpara>
<screen>    FilledEllipse(XPixelPosition, YPixelPosition, XRadius, YRadius [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a FilledEllipse on a GLCD at <literal>XPixelPosition</literal>, <literal>YPixelPosition</literal> with a specific vertex of <literal>XRadius</literal> and <literal>YRadius</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent FilledEllipses from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    FilledEllipse(63, 31, 20, 10)</screen>
</section>
<section xml:id="_filledtriangle">
<title>FilledTriangle</title>
<simpara><emphasis role="strong">FilledTriangle:</emphasis></simpara>
<screen>    FilledTriangle( XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a FilledTriangle on a GLCD at <literal>XPixelPositionN</literal>, <literal>YPixelPositionN</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent FilledTriangles from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    FilledTriangle(0, 0, 31, 63, 127, 0 )</screen>
</section>
<section xml:id="_glcdcls">
<title>GLCDCLS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDCLS</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Clears the screen of a Graphic LCD.</simpara>
<simpara>This command supports all GLCD displays.</simpara>
<simpara>Specific to the ST7920 GLCD devices. This command supports the clearing the GLCD in text mode and graphics mode.</simpara>
</section>
<section xml:id="_glcddrawchar">
<title>GLCDDrawChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDDrawChar(CharLocX, CharLocY, CharCode [, Optional Colour] )</screen>
<simpara><literal>CharLocX</literal> is the <literal>X</literal> coordinate location for the character<?asciidoc-br?>
<literal>CharLocY</literal> is the <literal>Y</literal> coordinate location for the character<?asciidoc-br?>
<literal>CharCode</literal> is the ASCII number of the character to display. Can be decimal
hex or binary.</simpara>
<simpara>Colour can be <literal>ON</literal> or <literal>OFF</literal>. For the ST7735 devices this an be any word
value that represents the color palette.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Displays an ASCII character at a specified X and Y location.
On a 128x64 Graphic LCD:</simpara>
<simpara>X = 1 to 128<?asciidoc-br?>
Y = 1 to 64<?asciidoc-br?></simpara>
</section>
<section xml:id="_glcddrawstring">
<title>GLCDDrawString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDDrawString(CharLocX, CharLocY, String [, Optional Colour] )</screen>
<simpara><literal>CharLocX</literal> is the X corrdinate location for the character<?asciidoc-br?>
<literal>CharLocY</literal> is the Y coordinate location for the character<?asciidoc-br?>
<literal>String</literal> is the string of characters to display<?asciidoc-br?>
<literal>Colour</literal> can be ON or OFF. For the ST7735 devices this an be any word
value that represents the color palette</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Displays an ASCII character at a specified X and Y location.<?asciidoc-br?>
On a 128x64 Graphic LCD :<?asciidoc-br?>
X = 1 to 128<?asciidoc-br?>
Y = 1 to 64<?asciidoc-br?></simpara>
</section>
<section xml:id="_glcdprint">
<title>GLCDPrint</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDPrint(PrintLocX, PrintLocY, PrintData)</screen>
<simpara><literal>PrintLocX</literal> is the X corrdinate location for the data<?asciidoc-br?>
<literal>PrintLocY</literal> is the Y coordinate location for the data<?asciidoc-br?>
<literal>PrintData</literal> is a String or String variable of the data to display</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Prints string character(s) at a specified location on the GLCD screen.</simpara>
<simpara>On a 128x64 GLCD display :<?asciidoc-br?>
X is typically 0 to 128<?asciidoc-br?>
Y is typically 0 to 64</simpara>
</section>
<section xml:id="_glcdrotate">
<title>GLCDRotate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDROTATE LANDSCOPE | PORTRAIT_REV | LANDSCAPE_REV  | PORTRAIT</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Rotate the GLCD display to a relative position.</simpara>
<simpara>GLCD rotation needs to be supported by the GLCD chipset. <emphasis role="strong">NOT</emphasis> all GLCD chipset support these commands.</simpara>
<simpara>The options are:</simpara>
<screen>    LANDSCAPE
    PORTRAIT_REV
    LANDSCAPE_REV
    PORTRAIT</screen>
<simpara>The command will rotate the screen and set the following variables using the global variables shown below.</simpara>
<screen>    GLCD_WIDTH
    GLCD_HEIGHT</screen>
<simpara>The command is supported by the following global constants.</simpara>
<screen>    #define LANDSCAPE       1
    #define PORTRAIT_REV    2
    #define LANDSCAPE_REV   3
    #define PORTRAIT        4</screen>
</section>
<section xml:id="_glcdreadbyte">
<title>GLCDReadByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_variable = GLCDReadByte</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Reads a byte of data from the Graphic LCD memory</simpara>
</section>
<section xml:id="_glcdtimedelay">
<title>GLCDTimeDelay</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDTime</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This will call the delay routine that delays data transmissions. By
default this is set to <literal>20</literal>, which equate to <literal>20 us</literal>. <literal>GLCDTimeDelay</literal> default
of <literal>20us</literal> is for 32Mhz support. The can be reduced for slower chip speeds
by change the constant <literal>ST7920WriteDelay</literal>.</simpara>
<simpara><emphasis role="strong">Example usage:</emphasis></simpara>
<screen>    GLCDTime                       'call the delay routine
    #define ST7920WriteDelay 1     'set the delay to 1 us</screen>
</section>
<section xml:id="_glcdwritebyte">
<title>GLCDWriteByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    GLCDWriteByte (LCDByte)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Writes a byte of data to the Graphic LCD memory</simpara>
</section>
<section xml:id="_line">
<title>Line</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Line(LineX1,LineY1, LineX2, LineY2, Optional LineColour = 1)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a line on a GLCD from pixel X1, Y1 location to pixel X2,Y2 location.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    line 0,0,127,63
    line 0,63,127,0
    line 40,0,87,63
    line 40,63,87,0</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lineb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_pset">
<title>Pset</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PSet(XPosition, YPosition, GLCDState)</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets or Clears a Pixel at the specified XPosition, YPosition.  Use
GLCDState set to 1 to set the pixel and a 0 clears the pixel.</simpara>
</section>
<section xml:id="_triangle">
<title>Triangle</title>
<simpara><emphasis role="strong">Triangle:</emphasis></simpara>
<screen>    Triangle(XPixelPosition1, YPixelPosition1, XPixelPosition2, YPixelPosition2, XPixelPosition3, YPixelPosition3 [,Optional LineColour] )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Draws a Triangle on a GLCD at <literal>XPixelPositionN</literal>, <literal>YPixelPositionN</literal>.</simpara>
<simpara>The constant <literal>GLCD_PROTECTOVERRUN</literal> can be added to prevent Triangles from
re-drawing at the screen edges. Ensure the <literal>GLCD_Width</literal> and <literal>GLCD_HEIGHT</literal>
constants are set correctly when using this additional constant.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #include &lt;glcd.h&gt;

    Triangle(0, 0, 31, 63, 127, 0 )</screen>
</section>
</section>
<section xml:id="_touch_screen">
<title>Touch Screen</title>
<simpara>This is the Touch Screen section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_ads_7843_serial_driver">
<title>ADS 7843 Serial Driver</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ADS7843_Init

    ADS7843_GetXY

    ADS7843_SetPrecision</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers. Requires the inclusion of the following:</simpara>
<screen>    #include &lt;ADS7843.h&gt;</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The ADS7843 device is a 12-bit sampling Analog-to-Digital Converter (ADC) with a synchronous serial interface and low on resistance switches for driving touch screens.</simpara>
<simpara>The Great Cow Basic driver is integrated with the SDD1289 GLCD driver.  To use the ADS7843 driver the following is required to added to the Great Cow BASIC source file.</simpara>
<simpara><literal>ADS7843_Init</literal> is required to initialise the touch screen. This is mandated.</simpara>
<simpara><literal>ADS7843_GetXY</literal> this sub-routine returns the X and Y coordinates of touched point.</simpara>
<simpara><literal>ADS7843_SetPrecision</literal> this sub-routine sets the level of precision of the touch screen.</simpara>
<simpara><emphasis role="strong">Required Constants:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls/Direction</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ADS7843_DOUT (IN)</simpara></entry>
<entry align="left" valign="top"><simpara>The chip output pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_IRQ (IN)</simpara></entry>
<entry align="left" valign="top"><simpara>The interrupt pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_CS (OUT)</simpara></entry>
<entry align="left" valign="top"><simpara>The chip select pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_CLK (OUT)</simpara></entry>
<entry align="left" valign="top"><simpara>The clock pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_DIN (OUT)</simpara></entry>
<entry align="left" valign="top"><simpara>The chip input pin</simpara></entry>
<entry align="left" valign="top"><simpara>Mandated</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow Basic commands supported for this chip are:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Purpose</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>ADS7843_Init</simpara></entry>
<entry align="left" valign="top"><simpara>Initialise the device.</simpara></entry>
<entry align="left" valign="top"><simpara>ADS7843_Init [Optional precision = PREC_EXTREME]</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_GetXY</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the X and Y coordinates of touched point.</simpara></entry>
<entry align="left" valign="top"><simpara>ADS7843_GetXY (TP_X, TP_Y )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ADS7843_SetPrecision</simpara></entry>
<entry align="left" valign="top"><simpara>Set the precision of the conversion result.</simpara></entry>
<entry align="left" valign="top"><simpara>ADS7843_SetPrecision(precision)<?asciidoc-br?>
(with PREC_EXTREME the conversion error is less than 3%)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Precision can be set to four values as shown in the table below.
Passing a parameter of ADS7843_SetPrecision changes the precision controls.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Defined  Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>#define PREC_LOW</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>#define PREC_MEDIUM</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>#define PREC_HI</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>3</literal></simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>#define  PREC_EXTREME</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Default Value</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>For more information see <link xlink:href="http://www.ti.com/product/ads7843">http://www.ti.com/product/ads7843</link>.</simpara>
<simpara>This example shows how to drive a SDD1289 based Graphic LCD module with ADS7843 touch controller.</simpara>
<screen>    'Chip Settings
    #chip mega2560, 16


    'Include
    #include &lt;glcd.h&gt;
    #include  &lt;ADS7843.h&gt;


    'GLCD Device Selection
    #define GLCD_TYPE GLCD_TYPE_SSD1289
    #define GLCD_EXTENDEDFONTSET1
    'Define ports for the SSD1289 display
    #define GLCD_WR   PORTG.2
    #define GLCD_CS   PORTG.1
    #define GLCD_RS   PORTD.7
    #define GLCD_RST  PORTG.0
    #define GLCD_DB0  PORTC.0
    #define GLCD_DB1  PORTC.1
    #define GLCD_DB2  PORTC.2
    #define GLCD_DB3  PORTC.3
    #define GLCD_DB4  PORTC.4
    #define GLCD_DB5  PORTC.5
    #define GLCD_DB6  PORTC.6
    #define GLCD_DB7  PORTC.7
    #define GLCD_DB8  PORTA.0
    #define GLCD_DB9  PORTA.1
    #define GLCD_DB10 PORTA.2
    #define GLCD_DB11 PORTA.3
    #define GLCD_DB12 PORTA.4
    #define GLCD_DB13 PORTA.5
    #define GLCD_DB14 PORTA.6
    #define GLCD_DB15 PORTA.7

    'Define ports for ADS7843
    #define ADS7843_DOUT   PORTE.5  ' Arduino Mega D3
    #define ADS7843_IRQ    PORTE.4  ' Arduino Mega D2
    #define ADS7843_CS     PORTE.3  ' Arduino Mega D5
    #define ADS7843_CLK    PORTH.3  ' Arduino Mega D6
    #define ADS7843_DIN    PORTG.5  ' Arduino Mega D4
    #define ADS7843_BUSY   PORTH.4  ' Arduino Mega D7

    Wait 100 ms
    num=0
    Pset 1,  1, SSD1289_YELLOW
    Do Forever

      if ADS7843_IRQ=0 then
         num++
         GLCDPrint  10, 15,  str(num),SSD1289_YELLOW, 2
         ADS7843_GetXY ( TP_X , TP_Y )
         if TP_X&gt;=100 then GLCDPrint  100, 50, Str(TP_X),SSD1289_YELLOW, 2
         if TP_X&gt;=10 and TP_X&lt;100 then GLCDPrint  100, 50, Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_X&lt;10 then GLCDPrint  100, 50,  Str(TP_X)+" ",SSD1289_YELLOW, 2
         if TP_Y&gt;=100 then GLCDPrint  100, 70, Str(TP_Y),SSD1289_YELLOW, 2
         if TP_Y&gt;=10 and TP_Y&lt;100 then GLCDPrint  100, 70, Str(TP_Y)+" ", SSD1289_YELLOW, 2
         if TP_Y&lt;10 then GLCDPrint  100, 70,  Str(TP_Y)+" ",SSD1289_YELLOW, 2
         Pset TP_X,  TP_Y, SSD1289_YELLOW
      end if
      Wait 1 ms

    Loop</screen>
</section>
</section>
<section xml:id="_liquid_crystal_display">
<title>Liquid Crystal Display</title>
<simpara>This is the LCD section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_lcd_overview">
<title>LCD Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The LCD routines in this section allow Great Cow BASIC programs to control an
alphanumeric Liquid Crystal Displays based on the <emphasis role="strong">HD44780</emphasis> IC. This
covers most 16 x 1, 16 x 2, 20 x 4 and 40 x 4 LCD displays.</simpara>
<simpara>These methods allow the displays to be connected to the microcontroller
in many different ways:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Connection Mode</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Required Connections</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>No configuration is required directly by this method. The LCD routines
<emphasis role="strong">must</emphasis> be provided with other subroutines which will handle the
communication. This is useful for communicating with LCDs connected
through RS232 or I2C.
<?asciidoc-br?>
This is an advanced method of driving an LCD.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Uses a combined data and clock line. This mode is used when the LCD is connected through a
shift register 74HC595, as detailed at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/"><emphasis role="strong">here</emphasis></link>.
<?asciidoc-br?>
This method of driving an LCD requires an additional integrated circuit and other passive components.
This is not recommended for the beginner.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Uses separated Data and Clock lines. This mode is used when the LCD is connected
through a 74LS174 shift register IC, as detailed at
<link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/"><emphasis role="strong">here</emphasis></link>
<?asciidoc-br?>
This method of driving an LCD requires additional integrated circuits
and other passive components. This is not recommended for the beginner.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>R/W</literal>, <literal>RS</literal>, <literal>Enable</literal> and the highest 4 data lines (<literal>DB4</literal> through <literal>DB7</literal>) are
connected to the microcontroller. The use of the R/W line is optional.
<?asciidoc-br?>
This a common method to connect a microcontroller to an LCD. This
requires 7(6) data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>R/W</literal>, <literal>RS</literal>, <literal>Enable</literal> and all 8 data lines. The data lines must all be
connected to the same I/O port, in sequential order. For example, <literal>DB0</literal> to
<literal>PORTB.0</literal>, <literal>DB1</literal> to <literal>PORTB.1</literal> and so on, with`DB7` going to <literal>PORTB.7</literal>.
<?asciidoc-br?>
This is a common method to connect a microcontroller to a LCD. This
requires 11(10) data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>The LCD is controlled via I2C. A type 10 LCD 12C adapter. Set <literal>LCD_10</literal> to
<literal>10</literal> for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
<?asciidoc-br?>
This is a common method and requires two data ports on the microcontroller.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>The LCD is controlled via I2C. A type 12 LCD 12C adapter. Set <literal>LCD_10</literal> to
`12`for the Ywmjkdz I2C adapter with a potentiometer (variable resistance) bent over top of chip.
<?asciidoc-br?>
This is a common method and requires two data ports on the microcontroller.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The support of the types of LCD displays is shown in the following table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Connection Mode</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Supported LCD Types:</emphasis><?asciidoc-br?>
number of characters x number of lines</entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>0,1,2,4,8,10 and 12</simpara></entry>
<entry align="left" valign="top"><simpara>16 x 1, 16 x 2, 20 x 2, 20 x 4 type LCD displays,<?asciidoc-br?>
also known as 1601, 1602, 2002, 2004 type LCD displays.</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>40 x 4 LCD displays,<?asciidoc-br?>
also known as 4004 type LCD displays.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO_2 74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO_2 74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
<section xml:id="_lcd_io_0">
<title>LCD_IO 0</title>
<simpara><emphasis role="strong">Using connection mode 0:</emphasis></simpara>
<simpara>To use connection mode 0, a subroutine to write a byte to the LCD <emphasis role="strong">must</emphasis> be provided.</simpara>
<simpara>Optionally, another subroutine to read a byte from the LCD can also be
defined.  If the LCD was to be read, the function <literal>LCDReadByte</literal> would be set to the name of a function that reads the LCD and returns the data byte from the LCD.
If there is no way (or no requirement) to read from the LCD, then the <literal>LCD_NO_RW</literal> constant must be set.</simpara>
<simpara>In connection mode 0, the <literal>LCD_RS</literal> constant will be set automatically to an unused bit variable.
The higher level LCD commands (such as <literal>Print</literal> and <literal>Locate</literal>) will set it, and the subroutine is responsible for writing to the LCD.
The subroutine should handle the process and then set the RS pin on the LCD appropriately.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with Great Cow BASIC.  To set these constants the main program should specific constants to support the connection mode using #define.</simpara>
<simpara>When using connection mode 0 only one constant must be set - all others are optional or can be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>0</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a code example of connection mode 0 program, download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%200.gcb">here</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>,<link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_1">
<title>LCD_IO 1</title>
<simpara><emphasis role="strong">Using connection mode 1:</emphasis></simpara>
<simpara>This approach uses a single connectivity line that supports a combined data
and clock signal between the microcontroller and the LCD display. This approach
is used when the LCD is connected through a shift register 74HC595, as detailed
at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/1-Wire%20LCD/1-wire%20LCD%2074HC595%20for%20GCB.jpg">here</link>.
This connection method is also called a 1-wire connection.</simpara>
<simpara>This solution approach recognises the original work provided in the Elektor Magazine.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with Great Cow BASIC. To set these constants the main program should specific constants to support the connection mode using #define.</simpara>
<simpara>When using connection mode 1, only two constants must be set - all others are optional or can be ignored.</simpara>
<simpara>How to connect and control the LCD background led: see <link linkend="_lcdbacklight">LCDBacklight</link>.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_CD</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock/data pin used in 1-bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>LCD.h supports in 1-wire mode the control of pin 4 of the 74HC595 for the background led.</simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%201.gcb">One Wire LCD Example</link>.</simpara>
<simpara>See for further code examples see <link xlink:href="http://sourceforge.net/projects/gcbasic/files/Demonstration%20Files/LCD%20Solutions/">0,1 and 2 Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_2_74xx164">
<title>LCD_IO 2_74xx164</title>
<simpara><emphasis role="strong">Using connection mode 2_74XX164:</emphasis></simpara>
<simpara>Use a Data and a Clock line. This manner is used when the LCD is
connected through a  shift register IC either using a 74HC164 or a 74LS164,
as detailed at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/">here</link>.
This connection method is also called a 2-wire connection.</simpara>
<simpara>This is the preferred two wire method to connect via a shift register to an LCD display.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with Great Cow BASIC.  To set these constants the main program should specific constants to support the connection mode using #define.</simpara>
<simpara>When using connection mode 2_74XX164 only three constants must be set - all others are optional or can be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The data pin used in 2-bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_CB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock pin used in 2- bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>LCD.h supports in connection mode 2_74XX164 via the control of pin 11 of the 74HC164 / 74LS164 to the background led/backlight.</simpara>
<simpara>How to connect and control the LCD background led: see <link xlink:href="http://gcbasic.sourceforge.net/help/_lcdbacklight.html">http://gcbasic.sourceforge.net/help/_lcdbacklight.html</link></simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%202.gcb">Two Wire LCD Example</link>.</simpara>
<simpara>See for further code examples see <link xlink:href="http://sourceforge.net/projects/gcbasic/files/Demonstration%20Files/LCD%20Solutions/">Two Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx74</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_2">
<title>LCD_IO 2</title>
<simpara><emphasis role="strong">Using connection mode 2:</emphasis></simpara>
<simpara>This method uses a Data and a Clock line via a shift register to control the LCD display.
This method is used when the LCD is connected through a shift register IC either using a 74HC164 or a 74LS174, as detailed at <link xlink:href="http://gcbasic.sourceforge.net/library/DIAGRAMS/2-Wire%20LCD/">here</link>.
This connection method is also called a 2-wire connection.</simpara>
<simpara>This is a <emphasis role="strong">deprecated</emphasis> method mode to connect an LCD display to a microcontroller via a shift registry either a 74LS174 (or a 74LS164 with diode connected to pin 11).   This method does not support backlight control and has no additional input/output pin.</simpara>
<simpara>If you have used the 2-wire mode prior to August 2015, please choose this method for your existing code.</simpara>
<simpara>See <link linkend="_lcd_io_2_74xx164">LCD_IO 2 74xx164</link> for the preferred method to connect an LCD display to a microcomputer via a shift register.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with Great Cow BASIC. To set these constants the main program should specific constants to support the connection mode using #define.
When using 2-bit mode only three constants must be set - all others are optional or can be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The data pin used in 2-bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_CB</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock pin used in 2- bit mode.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">Mandated</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/">Two Wire LCD Example</link>.</simpara>
<simpara>See for further code examples see <link xlink:href="http://sourceforge.net/projects/gcbasic/files/Demonstration%20Files/LCD%20Solutions/">Two Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_2_74xx174">
<title>LCD_IO 2_74xx174</title>
<simpara>LCD_IO 2_74xx174 has been deprecated as preferred method mode to connect an
LCD display to a microcontroller via a shift register either a 74LS174 (or a 74LS164 with
diode connected to pin 11). This method does not support backlight control and has no additional input/output pin.</simpara>
<simpara>See <link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>  for the preferred method to connect
an LCD display to a microcontroller via a shift register.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_4">
<title>LCD_IO 4</title>
<simpara><emphasis role="strong">Using connection mode 4:</emphasis></simpara>
<simpara>To use connection mode 4 the R/W, RS, Enable control lines and the highest 4 data lines (DB4 through DB7) must be connected to the microcontroller.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with Great Cow BASIC.  To set these constants the main program should specific constants to support the connection mode using #define.
Constants required for connection mode 4.</simpara>
<simpara>Constants are required for 4-bit mode as follows.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPEED</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FAST</literal>, <literal>MEDIUM</literal> or <literal>SLOW</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>MEDIUM</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must be <emphasis role="strong">4</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>4</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
LCD.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD. The
R/W pin can be disabled*.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis> <emphasis>(unless R/W is disabled)</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_Enable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 4 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB5</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 5 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB6</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 6 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DB7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output pin used to interface with bit 7 of the LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The <literal>R/W</literal> pin can be disabled by setting the <literal>LCD_NO_RW</literal> constant. If this
is done, there is no need for the <literal>R/W</literal> to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the <literal>R/W</literal> line on
the LCD is connected to ground if not used.</simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%204.gcb">Four Wire LCD Example</link>.</simpara>
<simpara>Also see for further code examples see <link xlink:href="http://sourceforge.net/projects/gcbasic/files/Demonstration%20Files/LCD%20Solutions/">Four Wire LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_8">
<title>LCD_IO 8</title>
<simpara><emphasis role="strong">Using connection mode 8:</emphasis></simpara>
<simpara>Using connection mode will require <literal>R/W</literal>, <literal>RS</literal>, <literal>Enable</literal> and all 8 data
lines.</simpara>
<simpara>The data lines must all be connected to the same I/O port, in sequential
order. For example, <literal>DB0</literal> to <literal>PORTB.0</literal>, <literal>DB1</literal> to <literal>PORTB.1</literal> and so on, with <literal>DB7</literal>
going to <literal>PORTB.7</literal>.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the Liquid Crystal
Display routines included with Great Cow BASIC. To set them, place a line in the
main program file that uses <literal>#define</literal> to assign a value to the particular
constant.</simpara>
<simpara>Constants are required for 8-bit mode as follows.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPEED</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FAST</literal>, <literal>MEDIUM</literal> or <literal>SLOW</literal>.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>MEDIUM</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode. Can be 2, 4 or 8.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>8</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Register Select on the
LCD.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_RW</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD. The
R/W pin can be disabled*.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis> <emphasis>(unless R/W is disabled)</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_Enable</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin that is connected to Read/Write on the LCD.</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_DATA_PORT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Output port used to interface with LCD data bus</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_LAT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Drives the port with <literal>LATx</literal> support. Resolves issues with faster Mhz and
the Microchip PIC read/write/modify feature. See example below.</simpara></entry>
<entry align="left" valign="top"><simpara>Optional</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The <literal>R/W</literal> pin can be disabled by setting the <literal>LCD_NO_RW</literal> constant. If this
is done, there is no need for the <literal>R/W</literal> to be connected to the chip, and
no need for the <literal>LCD_RW</literal> constant to be set. Ensure that the R/W line on
the LCD is connected to ground if not used.</simpara>
<simpara>For a code example download <link xlink:href="http://gcbasic.sourceforge.net/library/DEMO%20CODE/Demo%20code%20for%20lcd/Demo%20mode%208.gcb">Eight Wire LCD example</link>.</simpara>
<simpara>For code examples see <link xlink:href="http://sourceforge.net/projects/gcbasic/files/Demonstration%20Files/LCD%20Solutions/">Eight Wire Examples</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link> or <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
</section>
<section xml:id="_lcd_io_10">
<title>LCD_IO 10</title>
<simpara><emphasis role="strong">Using connection mode 10:</emphasis></simpara>
<simpara>The LCD is controlled via I2C of a type 10 LCD 12C adapter.
Use LCD_IO 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter.
To use mode 10 you must define the I2C ports as normal in your Great Cow BASIC code.
Then, define the LCD type, set the I2C_address of the LCD adapter and the LCD speed, if required.
Finally, set the backlight control, if required.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>Specific constants are used to control settings for the Liquid Crystal Display routines included with Great Cow BASIC.  To set these constants the main program should specific constants to support the connection mode using #define.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The I/O mode. Must be 10</simpara></entry>
<entry align="left" valign="top"><simpara><literal>10</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Default <literal>0x4E</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_3</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For code examples see <link xlink:href="http://sourceforge.net/projects/gcbasic/files/Demonstration%20Files/LCD%20Solutions/">I2C LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>,
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>, <link linkend="_lcd_io_12">LCD_IO 12</link></simpara>
<section xml:id="_lcd_io_10_port_configuration">
<title>LCD_IO 10 Port Configuration</title>
<simpara><emphasis role="strong">Using mode 10</emphasis></simpara>
<simpara>When using I2C LCD mode 10 the target I2C device address is setup as
shown below. Each bit of the the variable i2c_lcd_byte is defined to
address the correct LCD display port.</simpara>
<screen>    i2c_lcd_e = i2c_lcd_byte.2
    i2c_lcd_rw = i2c_lcd_byte.1
    i2c_lcd_rs = i2c_lcd_byte.0
    i2c_lcd_bl = i2c_lcd_byte.3
    i2c_lcd_d4 = i2c_lcd_byte.4
    i2c_lcd_d5 = i2c_lcd_byte.5
    i2c_lcd_d6 = i2c_lcd_byte.6
    i2c_lcd_d7 = i2c_lcd_byte.7</screen>
<simpara>If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.</simpara>
<screen>    #define i2c_lcd_e i2c_lcd_byte.1
    #define i2c_lcd_rw i2c_lcd_byte.2
    #define i2c_lcd_rs i2c_lcd_byte.0
    #define i2c_lcd_bl i2c_lcd_byte.3
    #define i2c_lcd_d4 i2c_lcd_byte.7
    #define i2c_lcd_d5 i2c_lcd_byte.6
    #define i2c_lcd_d6 i2c_lcd_byte.5
    #define i2c_lcd_d7 i2c_lcd_byte.4</screen>
</section>
</section>
<section xml:id="_lcd_io_12">
<title>LCD_IO 12</title>
<simpara><emphasis role="strong">Using connection mode 12:</emphasis></simpara>
<simpara>The LCD is controlled via I2C.
A type 12 is the Ywmjkdz I2C adapter with potentiometer  variable resistor) bent over top of chip.
To use mode 12 you must define the I2C ports as normal in your GCB code.
Then, define the LCD type, set the I2C_address of the LCD adapter and the LCD speed, if required.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the Liquid Crystal
Display routines included with Great Cow BASIC. To set them, place a line in the
main program file that uses <literal>#define</literal> to assign a value to the particular
constant.</simpara>
<simpara>When using 2-bit mode only three constants must be set - all others can
be ignored.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_IO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>I/O mode</simpara></entry>
<entry align="left" valign="top"><simpara><literal>12</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Default <literal>0x4E</literal><?asciidoc-br?>
 could also be <literal>0x27</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_I2C_Address_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Address of I2C adapter</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>To set the correct address see the picture below:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/lcd_io12b1.JPG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For code examples see <link xlink:href="http://sourceforge.net/projects/gcbasic/files/Demonstration%20Files/LCD%20Solutions/">I2C LCD Solutions</link>.</simpara>
<simpara>See the separate sections of the Help file for the specifics of each
Connection Mode.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_lcd_io_0">LCD_IO 0</link>, <link linkend="_lcd_io_1">LCD_IO 1</link>, <link linkend="_lcd_io_2">LCD_IO 2</link>
<link linkend="_lcd_io_2_74xx164">LCD_IO 2_74xx164</link>, <link linkend="_lcd_io_2_74xx174">LCD_IO 2_74xx174</link>,
<link linkend="_lcd_io_4">LCD_IO 4</link>, <link linkend="_lcd_io_8">LCD_IO 8</link>,
<link linkend="_lcd_io_10">LCD_IO 10</link></simpara>
<section xml:id="_lcd_io_12_port_configuration">
<title>LCD_IO 12 Port Configuration</title>
<simpara><emphasis role="strong">Using mode 12:</emphasis></simpara>
<simpara>When using I2C LCD mode 12 the target I2C device address is setup as
shown below. Each bit of the the variable <literal>i2c_lcd_byte</literal> is defined to
address the correct LCD display port.</simpara>
<screen>    i2c_lcd_e = i2c_lcd_byte.4
    i2c_lcd_rw = i2c_lcd_byte.5
    i2c_lcd_rs = i2c_lcd_byte.6
    i2c_lcd_bl = i2c_lcd_byte.7
    i2c_lcd_d4 = i2c_lcd_byte.0
    i2c_lcd_d5 = i2c_lcd_byte.1
    i2c_lcd_d6 = i2c_lcd_byte.2
    i2c_lcd_d7 = i2c_lcd_byte.3</screen>
<simpara>If you have an I2C LCD display adapter with a different set of
connection of the adapter then change this configuration to suit the
specific of the adapter as follows. This should be done in the your main
program code.</simpara>
<screen>    #define i2c_lcd_e i2c_lcd_byte.4
    #define i2c_lcd_rw i2c_lcd_byte.5
    #define i2c_lcd_rs i2c_lcd_byte.6
    #define i2c_lcd_bl i2c_lcd_byte.7
    #define i2c_lcd_d4 i2c_lcd_byte.3
    #define i2c_lcd_d5 i2c_lcd_byte.2
    #define i2c_lcd_d6 i2c_lcd_byte.1
    #define i2c_lcd_d7 i2c_lcd_byte.0</screen>
</section>
</section>
<section xml:id="_lcd_speed">
<title>LCD_SPEED</title>
<simpara><emphasis role="strong">Using LCD_SPEED:</emphasis></simpara>
<simpara>The communication performance of a LCD display can be controlled via a <literal>#DEFINE</literal>.
This method allows the timing to be optimised.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<literallayout class="monospaced">#DEFINE LCD_SPEED  FAST</literallayout>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Define</entry>
<entry align="left" valign="top">Required Connections</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>LCD_SPEED</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Options are:<?asciidoc-br?>
<literal>FAST</literal>   - The speed is approximately 20,000 CPS.<?asciidoc-br?>
<literal>MEDIUM</literal> - The speed is approximately 15,000 CPS.<?asciidoc-br?>
<literal>SLOW</literal>   - The speed is approximately 10,000 CPS.<?asciidoc-br?></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>If <literal>LCD_SPEED</literal> is not defined, the speed defaults to <literal>SLOW</literal></simpara>
</section>
</section>
<section xml:id="_cls">
<title>CLS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    CLS</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>CLS</literal> command clears the contents of the LCD, and returns the cursor
to the top left corner of the screen</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    'A Flashing Hello World program for Great Cow BASIC

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    Do
        Print "Hello World"
        Wait 1 sec
        CLS
        Wait 1 sec
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_get">
<title>Get</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = Get(Line, Column)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with the LCD R/W line (pin 5) connected and if the following constant definition is used;
<literal>#define LCD_RW</literal>. Not available if the LCD is connected using the 0 or 2 bit mode or if the constant definition
<literal>#define LCD_NO_RW</literal> is used.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Get</literal> function reads the ASCII character code at a given location on
the LCD.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_put">Put</link>,
<link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdbacklight">
<title>LCDBacklight</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDBacklight ( On | Off )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets the LCD backlight on or off</simpara>
<simpara>Do not connect the LCD backlight directly to the microcontroller! Always refer to
the datasheet for the correct method to drive the LCD backlight.</simpara>
<simpara>The diagram below shows a method to connect the LCD backlight to a microcontroller.</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/lcdbacklightb1.JPG"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject>
The diagram above was provided by William Roth, January 2015.</simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcreatechar">
<title>LCDCreateChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDCreateChar <emphasis>char, chardata()</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDCreateChar command is used to send a custom character to the LCD.</simpara>
<simpara>Each character on the LCD is made up from an 8 row by 5 column (5x8)
matrix of pixels. The data to be sent to the LCD is composed of an 8
element array, where each element corresponds to a row. Inside each
element, the 5 lowest bits make up the data for the corresponding row.
When a bit is set a dot will be drawn at the matching location; when it
is cleared, no dot will appear.</simpara>
<simpara>An array of more than 8 elements may be used, but only the first 8 will
be read.</simpara>
<simpara><literal><emphasis>char</emphasis></literal> is the ASCII value of the character to create. ASCII codes 0
through 7 are usually used to store custom characters.<?asciidoc-br?>
<literal><emphasis>chardata()</emphasis></literal> is an array containing the data for the character.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program draws a smiling face character

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    'Binary has been used to improve the readability of the code, but is not essential
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcdcreatechar">LCDWriteChar</link>,
<link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcreategraph">
<title>LCDCreateGraph</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDCreateGraph <emphasis>value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDCreateGraph command will create a graph like character which can
then be displayed on the LCD</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88,8
    #config osc = intrc

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    Graph_Tests:

    cls
    'Draw the custom character - fill the LCD
    repeat 64
          LCDWriteChar 0
    end Repeat

    ' Update the characters at high speed without re-printing on LCD
    for graphvalue = 0 to 8
        LCDCreateGraph ( 0 ,  graphvalue )
        wait 100 ms
    next</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcmd">
<title>LCDCmd</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDCMD <emphasis>value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command set LCD specific instructions to the LCD display. As shown
in the table below.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">INSTRUCTION</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Decimal</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Hexadecimal</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Scroll display one character right (all lines)</simpara></entry>
<entry align="center" valign="top"><simpara>28</simpara></entry>
<entry align="center" valign="top"><simpara>1E</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Scroll display one character left (all lines)</simpara></entry>
<entry align="center" valign="top"><simpara>24</simpara></entry>
<entry align="center" valign="top"><simpara>18</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Home (move cursor to top/left character position)</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Move cursor one character left</simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Move cursor one character right</simpara></entry>
<entry align="center" valign="top"><simpara>20</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Turn on visible underline cursor</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
<entry align="center" valign="top"><simpara>0E</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Turn on visible blinking-block cursor</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
<entry align="center" valign="top"><simpara>0F</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Make cursor invisible</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>0C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Blank the display (without clearing)</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
<entry align="center" valign="top"><simpara>08</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Restore the display (with cursor hidden)</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
<entry align="center" valign="top"><simpara>0C</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Clear Screen</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
<entry align="center" valign="top"><simpara>01</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Set cursor position (DDRAM address)</simpara></entry>
<entry align="center" valign="top"><simpara>128 + addr</simpara></entry>
<entry align="center" valign="top"><simpara>80+ addr</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Set pointer in character-generator RAM (CG RAM address)</simpara></entry>
<entry align="center" valign="top"><simpara>64 + addr</simpara></entry>
<entry align="center" valign="top"><simpara>40+ addr</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88,8
    #config osc = intrc


    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Command_Tests:

    locate 0,8
    print "123456"
    'Scroll display one character right (all lines)       28
    '
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s
    lcdcmd 28
    wait 1 s

    'Scroll display one character left (all lines)        24
    '
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s
    lcdcmd 24
    wait 1 s


    'Home (move cursor to top/left character position)    2
    '
    lcdcursor flash
    lcdcmd 2
    wait 1 s

    'Move cursor one character left                       16
    '
    lcdcursor flash
    locate 0,8

    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s
    lcdcmd 16
    wait 1 s

    'Move cursor one character right                      20
    '
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s
    lcdcmd 20
    wait 1 s</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdcursor">
<title>LCDCursor</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    LCDCursor value</screen>
<simpara><emphasis role="strong">Command Availability</emphasis>:</simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDCursor command will accept the following parameters:</simpara>
<simpara><literal>LCDON</literal>, <literal>LCDOFF</literal>, <literal>CURSORON</literal>, <literal>CURSOROFF</literal>, <literal>FLASHON</literal>, <literal>FLASHOFF</literal></simpara>
<simpara><literal>FLASH</literal>, and <literal>ON/OFF</literal> have been retained for backward compatibility with
older releases of GCB.</simpara>
<simpara><literal>LCDON</literal>  will turn on (restore) the LCD display.<?asciidoc-br?>
<literal>LCDOFF</literal>  will turn off (hide) the LCD display.<?asciidoc-br?>
<literal>CURSORON</literal>  will turn on the cursor.<?asciidoc-br?>
<literal>CURSOROFF</literal>  will turn off the cursor.<?asciidoc-br?>
<literal>FLASHON</literal>  will flash the cursor.<?asciidoc-br?>
<literal>FLASHOFF</literal>  will stop flashing the cursor.</simpara>
<simpara><emphasis role="strong">Example :</emphasis>																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												#config osc = intrc</simpara>
<screen>    #chip 16f877a, 8

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Start:
    CLS
    WAIT 3 s
    PRINT "START DEMO"
    locate 1,0
    PRINT "DISPLAY ON"

    wait 3 s

    CLS
    Locate 0,0
    Print "Cursor ON"
    Locate 1,0
    LCDcursor CursorOn
    wait 3 S

    CLS
    LCDcursor CursorOFF
    locate 0,0
    Print "Cursor OFF"
    wait 3 s

    CLS
    Locate 0,0
    Print "FLASH ON"
    Locate 1,0
    LCDcursor FLASHON
    wait 3 s

    CLS
    locate 0,0
    Print "FLASH OFF"
    LCDCURSOR FLASHOFF
    wait 3 sec

    Locate 0,0
    Print "CURSOR&amp;FLASH ON" 'Both are on at the same time
    locate 1,0
    LCDCURSOR CURSORON
    LCDCURSOR FLASHON
    Wait 3 sec

    Locate 0,0
    Print "CURSOR FLASH OFF"
    locate 1,0
    LCDCURSOR CursorOFF
    LCDCURSOR FLASHOFF
    Wait 3 sec

    CLS
    Locate 0,4
    PRINT "Flashing"
    Locate 1,4
    Print "Display"
    wait 500 ms

    repeat 5
        LCDCURSOR LCDOFF
        wait 500 ms
        LCDCURSOR LCDON
        wait 500 ms
    end repeat

    CLS
    Locate 0,0
    Print "DISPLAY OFF"
    Locate 1,0
    Print "FOR 5 SEC"
    Wait 2 SEC
    LCDCURSOR LCDOFF
    WAIT 5 s

    CLS
    Locate 0,0
    LCDCURSOR LCDON
    Print "END DEMO"
    wait 3 s
    goto start</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdhex">
<title>LCDHex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDHex value

    LCDHex value, <emphasis role="strong">LeadingZeroActive</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDHex will display the byte value as a 1 or 2 character HEX string.</simpara>
<simpara><literal>value</literal> is a byte value from 0 to 255.</simpara>
<simpara><literal>LeadingZeroActive</literal> is a constant or byte value of 2.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    ;Set chip model required:
    #chip mega328p, 16
    ;Setup LCD Parameters
    #define LCD_IO 4
    #define LCD_NO_RW
    #define LCD_Speed MEDIUM 'FAST IS OK ON ARDUINO UNO R3

    'Change as necessary
    #define LCD_RS PortC.0
    #define LCD_Enable PortC.1
    #define LCD_DB4 PortC.2
    #define LCD_DB5 PortC.3
    #define LCD_DB6 PortC.4
    #define LCD_DB7 PortC.5

    '  #chip 16f877a, 8
    '  ;Setup LCD Parameters
    '  #define LCD_IO 4
    '  #define LCD_NO_RW
    '  #define LCD_Speed fast 'FAST IS OK ON 16f877a
    '
    '  ;Change as necessary
    '  #define LCD_RS PortB.2
    '  #define LCD_Enable PortB.3
    '  #define LCD_DB4 PortB.4
    '  #define LCD_DB5 PortB.5
    '  #define LCD_DB6 PortB.6
    '  #define LCD_DB7 PortB.7

    'Program Start
    DO Forever
       CLS
       WAIT 2 s
       PRINT "Test LCDHex "
       wait 3 s
       CLS
       wait 1 s

       for bv = 0 to 255
          locate 0,0
          Print "DEC " : Print BV
          locate 1,0
          Print "HEX "
          LCDHex BV, LeadingZeroActive ; dislay leading Zero
        ' LCDHex BV         ; do not display leading zero
          wait 1 s
       next
       CLS
       wait 1 s
       Print "END TEST"
    LOOP</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdhome">
<title>LCDHome</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDHome</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LCDHome</literal> command will return the cursor to home position.</simpara>
<simpara>The currentcontents of the LCD screen will be retained.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88,8
    #config osc = intrc

    ;Defines (Constants)
    #define LCD_IO 4
    #define LCD_RS PORTA.6
    #define LCD_NO_RW
    #define LCD_Enable PORTA.7
    #define LCD_DB4 PORTB.4
    #define LCD_DB5 PORTB.5
    #define LCD_DB6 PORTB.6
    #define LCD_DB7 PORTB.7

    Locate 0,0
    Print "Reset"
    wait 1 s
    ClS

    Cursor_Home_Tests:

    cls
    lcdcursor flash
    print "Test Home Cmd"
    LCDHome
    wait 3 s</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcddisplayon">
<title>LCDDisplayOn</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    LCDDisplayOn</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Will turn on (restore) the LCD display</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_lcdcursor">LCDCursor</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcddisplayoff">
<title>LCDDisplayOff</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    LCDDisplayOff</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Will turn off (hide) the LCD display.</simpara>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_lcdcursor">LCDCursor</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdspace">
<title>LCDSpace</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDSpace value</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LCDSpace command will print the required number of spaces on the LCD
display</simpara>
<simpara><literal>value</literal> is a byte value from 1 to 255. Where the <literal>value</literal> is the number of spaces required.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    Locate 0,0
    Print "Reset"
    wait 1 s
    cls

    LCD_Space_Tests:

    lcdcursor flash

    lcdspace 12

    print "*"</screen>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_lcdwritechar">
<title>LCDWriteChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LCDWriteChar <emphasis>char</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LCDWriteChar</literal> command will show the specified character on the LCD,
at the current cursor position.</simpara>
<simpara><literal><emphasis>char</emphasis></literal> is the ASCII value of the character to show. On most LCDs,
characters 0 through 7 are user defined, and can be set using the
<literal>LCDCreateChar</literal> command.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    'This program draws a smiling face character

    'Create an array to store the character until it is copied
    Dim CharArray(8)

    'Set the array to hold the character
    CharArray(1) = b'00011011'
    CharArray(2) = b'00011011'
    CharArray(3) = b'00000000'
    CharArray(4) = b'00000100'
    CharArray(5) = b'00000000'
    CharArray(6) = b'00010001'
    CharArray(7) = b'00010001'
    CharArray(8) = b'00001110'

    'Copy the character from the array to the LCD
    LCDCreateChar 0, CharArray()

    'Draw the custom character
    LCDWriteChar 0</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcdcreatechar">LCDCreateChar</link>,
<link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_locate">
<title>Locate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Locate <emphasis>Line, Column</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Locate command is used to move the cursor on the LCD to the given
location.</simpara>
<simpara><literal>Line</literal> is line number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><literal>Column</literal> is column number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    'A Hello World program for Great Cow BASIC.
    'Uses Locate to show "World" on the second line

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    Print "Hello"
    Locate 1, 5
    Print "World"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_print">
<title>Print</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Print <emphasis>string</emphasis>
    Print <emphasis>byte</emphasis>
    Print <emphasis>word</emphasis>
    Print <emphasis>long</emphasis>
    Print <emphasis>integer</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Print command will show the contents of a variable on the LCD. It
can display string, word, byte, long or integer variables.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'A Light Meter program.

    'General hardware configuration
    #chip 16F877A, 20
    #define LightSensor AN0

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    CLS
    Print "Light Meter"
    Locate 1,2
    Print "A GCBASIC Demo"
    Wait 2 s

    Do
        CLS
        Print "Light Level: "
        Print ReadAD(LightSensor)
        Wait 250 ms
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_put">
<title>Put</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Put <emphasis>Line</emphasis>, <emphasis>Column</emphasis>, <emphasis>Character</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Put command writes the given ASCII character code to the current location on
the LCD.</simpara>
<simpara><literal>Line</literal> is line number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><literal>Column</literal> is column number on the LCD display. A byte value from 0 to 255.</simpara>
<simpara><literal>Character</literal> is the requried ASCII code.  A byte value from 0 to 255.</simpara>
<simpara><emphasis role="strong">Example :</emphasis></simpara>
<screen>    'A scrolling star for Great Cow BASIC

    'Misc Settings
    #define SCROLL_DELAY 250 ms

    'General hardware configuration
    #chip 16F877A, 20

    'LCD connection settings
    #define LCD_IO 8
    #define LCD_DATA_PORT PORTC
    #define LCD_RS PORTD.0
    #define LCD_RW PORTD.1
    #define LCD_Enable PORTD.2

    'Main routine
    For StarPos = 0 To 16
        If StarPos = 0 Then
            Put 0, 16, 32
            Put 0, 0, 42
        Else
            Put 0, StarPos - 1, 32
            Put 0, StarPos, 42
        End If
        Wait SCROLL_DELAY
    Next</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_lcd_overview">LCD Overview</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;LCD.H&gt;</emphasis></simpara>
</section>
<section xml:id="_examples">
<title>Examples</title>
<section xml:id="_lcd_io_2_example">
<title>LCD_IO 2 Example</title>
<simpara>This a connection mode 2 Serial Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed.</simpara>
<simpara>Based on the works by Thomas Henry and then revised Evan R. Venn</simpara>
<screen>    #chip 16F877A,20

    #define LCD_IO 2
    #define LCD_DB portb.2
    #define LCD_CB portb.0
    #define LCD_NO_RW
                ;Here are various LCD commands which can be used.
                ;These are the LCD commands for the HD44780 controller

    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
          printMsg(0)             ;print first message
          wait 3 S                ;pause 3 seconds
          printMsg(2)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 5                ;blink it five times
            LCDCmd(lcdOff)       ;display off
            wait 500 mS           ;pause
            LCDCmd(lcdOn)        ;display on
            wait 500 mS           ;pause
          end repeat
          wait 1 S                ;pause before next demo
          ;demonstrate panning
          printMsg(4)             ;print next message
          wait 3 S                ;pause 3 seconds
          repeat 16
            LCDCmd(panL)         ;pan left a step at a time
            wait 300 mS           ;slow down to avoid blur
          end repeat
          repeat 16
            LCDCmd(panR)         ;then pan right
            wait 300 mS
          end repeat
          wait 1 S                ;pause before next demo
                                  ;demonstrate moving the cursor
          printMsg(6)             ;print next message
          wait 3 S                ;pause 3 seconds
          doHome                  ;home cursor
          LCDCmd(under)          ;choose underline cursor
          for ii = 0 to 15         ;move cursor across first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          for ii = 0 to 15         ;move cursor across second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over second line
            LCDCmd(line2+i)
            wait 200 mS
          next i
          for ii = 15 to 0 step -1 ;move cursor back over first line
            LCDCmd(line1+i)
            wait 200 mS
          next i
          wait 3 S
          ;demonstrate blinking block cursor
          printMsg(8)             ;print next message
          doHome                  ;home the cursor
          LCDCmd(block)          ;choose blinking block cursor
          wait 4 S                ;pause 4 seconds
          LCDCmd(mode1)          ;change to one long line mode
          doHome                  ;home the cursor again
          LCDCmd(curOff)         ;and disable it


          ;demonstrate scrolling a lengthy one-line marquee
          for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
            EPread ii, char        ;fetch directly from eeprom
            print chr(char)
          next i
          wait 1 S
          doHome                  ;home cursor once more
          repeat 141              ;scroll message twice
            LCDCmd(panR)
            wait 250 mS
          end repeat
          wait 2 S
          LCDCmd(mode2)          ;change back to two line mode
          doClr                   ;clear the screen
          ;demonstrate all of the characters
          printMsg(11)             ;print next message
          for ii = 33 to 127       ;print first batch of ASCII characters
            LCDCmd(line1+12)     ;overwrite each character displayed
            print chr(ii)            ;this is the ASCII code
            wait 500 mS
          next i
          for ii = 161 to 255      ;print next batch of ASCII characters
            LCDCmd(line1+12)
            print chr(ii)
            wait 500 mS
          next i
          ;say good-bye
          LCDCmd(line2)
          printMsg(11)             ;print next message
          doHome                  ;home the cursor
    loop

    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
        LCDCmd(line1)              ;get set for first line

        for ii = 0 to StringLength
          index = row*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
        LCDCmd(line2)              ;get set for second line
        for ii = 0 to StringLength
          index = (row+1)*16+ii
          EPread index, char        ;fetch next character and
          print chr(char)             ;transmit to the LCD
        next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"

    end sub

    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64

        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next

    end sub</screen>
</section>
<section xml:id="_lcd_io_4_example">
<title>LCD_IO 4 Example</title>
<simpara>This is a Serial connection mode 4 Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed.</simpara>
<simpara>Based on the works by Thomas Henry and then revised Evan R. Venn</simpara>
<screen>    #chip 16F877A,20

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        doHome                  ;home cursor
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        doHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        doHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        doHome                  ;home cursor once more
        repeat 141              ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        doClr                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)     ;overwrite each character displayed
          print chr(ii)            ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        doHome                  ;home the cursor
    loop
    end




    ;----- Clear the screen
    sub doClr
      LCDCmd(clrHome)
      wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
      LCDCmd(home)
      wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
      LCDCmd(line1)              ;get set for first line

      for ii = 0 to StringLength
        index = row*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next
      LCDCmd(line2)              ;get set for second line
      for ii = 0 to StringLength
        index = (row+1)*16+ii
        EPread index, char        ;fetch next character and
        print chr(char)             ;transmit to the LCD
      next
    end sub

    sub loadEeprom
    ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
    location = 0
    WriteEeprom "First we'll show"
    WriteEeprom "this message.   "
    WriteEeprom "Then we'll blink"
    WriteEeprom "five times.     "
    WriteEeprom "Now lets pan    "
    WriteEeprom "left and right. "
    WriteEeprom "Watch the line  "
    WriteEeprom "cursor move.    "
    WriteEeprom "A block cursor  "
    WriteEeprom "is available.   "
    WriteEeprom "Characters:     "
    WriteEeprom "Bye!            "
    WriteEeprom "in one line mode"
    WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64
        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next
    end sub</screen>
</section>
<section xml:id="_lcd_io_8_example">
<title>LCD_IO 8 Example</title>
<simpara>This is an connection mode 8 Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed.</simpara>
<simpara>Based on the works by Thomas Henry and then revised Evan R. Venn</simpara>
<screen>    #chip 16F877A,20


    'Use LCD in 8 pin mode and define LCD pins
    #define LCD_IO 8
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_Data_Port PORTD

    ;Here are various LCD commands which can be used.
    ;These are the LCD commands for the HD44780 controller
    #define clrHome = 1     ;clear the display, home the cursor
    #define home    = 2     ;home the cursor only
    #define RtoL    = 4     ;print characters right to left
    #define insR    = 5     ;insert characters to right
    #define LtoR    = 6     ;print characters left to right
    #define insL    = 7     ;insert characters to left
    #define lcdOff  = 8     ;LCD screen off
    #define lcdOn   = 12    ;LCD screen on, no cursor
    #define curOff  = 12    ;an alias for the above
    #define block   = 13    ;LCD screen on, block cursor
    #define under   = 14    ;LCD screen on, underline cursor
    #define undblk  = 15    ;LCD screen on, blinking and underline cursor
    #define CLeft   = 16    ;cursor left
    #define CRight  = 20    ;cursor right
    #define panR    = 24    ;pan viewing window right
    #define panL    = 28    ;pan viewing window left
    #define bus4    = 32    ;4-bit data bus mode
    #define bus8    = 48    ;8-bit data bus mode
    #define mode1   = 32    ;one-line mode (alias)
    #define mode2   = 40    ;two-line mode
    #define line1   = 128   ;go to start of line 1
    #define line2   = 192   ;go to start of line 2
    ;----- Variables
    dim char, msn, lsn, index, ii as byte
    ;----- Main Program
    LoadEeprom              ;load the EEprom with strings

    do forever
        printMsg(0)             ;print first message
        wait 3 S                ;pause 3 seconds
        printMsg(2)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 5                ;blink it five times
          LCDCmd(lcdOff)       ;display off
          wait 500 mS           ;pause
          LCDCmd(lcdOn)        ;display on
          wait 500 mS           ;pause
        end repeat
        wait 1 S                ;pause before next demo
        ;demonstrate panning
        printMsg(4)             ;print next message
        wait 3 S                ;pause 3 seconds
        repeat 16
          LCDCmd(panL)         ;pan left a step at a time
          wait 300 mS           ;slow down to avoid blur
        end repeat
        repeat 16
          LCDCmd(panR)         ;then pan right
          wait 300 mS
        end repeat
        wait 1 S                ;pause before next demo
                                ;demonstrate moving the cursor
        printMsg(6)             ;print next message
        wait 3 S                ;pause 3 seconds
        doHome                  ;home cursor
        LCDCmd(under)          ;choose underline cursor
        for ii = 0 to 15         ;move cursor across first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        for ii = 0 to 15         ;move cursor across second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over second line
          LCDCmd(line2+i)
          wait 200 mS
        next i
        for ii = 15 to 0 step -1 ;move cursor back over first line
          LCDCmd(line1+i)
          wait 200 mS
        next i
        wait 3 S
        ;demonstrate blinking block cursor
        printMsg(8)             ;print next message
        doHome                  ;home the cursor
        LCDCmd(block)          ;choose blinking block cursor
        wait 4 S                ;pause 4 seconds
        LCDCmd(mode1)          ;change to one long line mode
        doHome                  ;home the cursor again
        LCDCmd(curOff)         ;and disable it


        ;demonstrate scrolling a lengthy one-line marquee
        for ii = 0xd0 to 0xff    ;print next message - the remaining EEPROM
          EPread ii, char        ;fetch directly from eeprom
          print chr(char)
        next i
        wait 1 S
        doHome                  ;home cursor once more
        repeat 141              ;scroll message twice
          LCDCmd(panR)
          wait 250 mS
        end repeat
        wait 2 S
        LCDCmd(mode2)          ;change back to two line mode
        doClr                   ;clear the screen
        ;demonstrate all of the characters
        printMsg(11)             ;print next message
        for ii = 33 to 127       ;print first batch of ASCII characters
          LCDCmd(line1+12)     ;overwrite each character displayed
          print chr(ii)            ;this is the ASCII code
          wait 500 mS
        next i
        for ii = 161 to 255      ;print next batch of ASCII characters
          LCDCmd(line1+12)
          print chr(ii)
          wait 500 mS
        next i
        ;say good-bye
        LCDCmd(line2)
        printMsg(11)             ;print next message
        doHome                  ;home the cursor
    loop
    end

    ;----- Clear the screen
    sub doClr
        LCDCmd(clrHome)
        wait 5 mS                   ;this command takes extra time
    end sub

    ;----- Home the cursor
    sub doHome
        LCDCmd(home)
        wait 5 mS                   ;and so does this one
    end sub

    ;----- Print a message to the LCD
    ;The parameter 'row' points to the start of the string.
    sub printMsg(in row as byte, in Optional StringLength As Byte = 15)
          LCDCmd(line1)              ;get set for first line

          for ii = 0 to StringLength
            index = row*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
          LCDCmd(line2)              ;get set for second line
          for ii = 0 to StringLength
            index = (row+1)*16+ii
            EPread index, char        ;fetch next character and
            print chr(char)             ;transmit to the LCD
          next
    end sub

    sub loadEeprom

        ' Strings for EEPROM, Strings should be limited to 16 characters for the first 13 sstrings, then a long string to fill eeprom
        location = 0
        WriteEeprom "First we'll show"
        WriteEeprom "this message.   "
        WriteEeprom "Then we'll blink"
        WriteEeprom "five times.     "
        WriteEeprom "Now lets pan    "
        WriteEeprom "left and right. "
        WriteEeprom "Watch the line  "
        WriteEeprom "cursor move.    "
        WriteEeprom "A block cursor  "
        WriteEeprom "is available.   "
        WriteEeprom "Characters:     "
        WriteEeprom "Bye!            "
        WriteEeprom "in one line mode"
        WriteEeprom "Next well scroll this long message as a marquee"
    end sub


    ; Write to the device eeprom
    sub WriteEeprom ( in Estring() ) as string * 64
        for ee = 1 to len ( Estring )
            HSersend Estring(ee)
            epwrite location, Estring(ee)
            location++
        next
    end sub</screen>
</section>
<section xml:id="_lcd_io_10_example">
<title>LCD_IO 10 Example</title>
<simpara>This is an connection mode 10 I2C Driver to demonstrate LCD features. This for the 16F877A, but, it can easily be adapted for other microcontrollers.</simpara>
<simpara>A 2 by 16 LCD is assumed with the LCD being driven using an LCD I2C adapter.
Two types are supported the YwRobot LCD1602 IIC V1 / a Sainsmart LCD_PIC I2C adapter or the Ywmjkdz I2C adapter with pot bent over top of chip.</simpara>
<simpara>The demonstrates reading a DS18B20 and showing the results on the LCD.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip mega328p, 16
    #include &lt;DS18B20.h&gt;

    ; ----- Define Hardware settings
    ' Define I2C settings - CHANGE PORTS
     #define I2C_MODE Master
     #define I2C_DATA PORTC.4
     #define I2C_CLOCK PORTC.5
     #define I2C_DISABLE_INTERRUPTS ON

    '''Set up LCD
     #define LCD_IO 10
     #define LCD_I2C_Address_1 0x4E                ; LCD 1
     #define LCD_I2C_Address_2 0x4C                ; LCD 2

    ; ----- Constants
    ' DS18B20 port settings - this is required
       #define DQ PortC.3

    ; ----- Quick Command Reference:

    '''Set LCD_10 to 10 for the YwRobot LCD1602 IIC V1 or the Sainsmart LCD_PIC I2C adapter
    '''Set LCD_10 to 12 for the Ywmjkdz I2C adapter with pot bent over top of chip

    ; ----- Variables
    dim TempC_100 as word   ' a variabler to handle the temperature calculations
    dim DSdataRaw as Integer


    ; ----- Main body of program commences here.

    'Change to the correct LCD by setting     LCD_I2C_Address_Current to the correct address then write to LCD.
    LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 1 )
    LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 1 )
    wait 4 s
    LCD_I2C_Address_Current = LCD_I2C_Address_1:  CLS
    LCD_I2C_Address_Current = LCD_I2C_Address_2:  CLS

    ccount = 0
    Do forever

        ' The function readtemp12 returns the raw value of the sensor.
        ' The sensor is read as a 12 bit value therefore each unit equates to 0.0625 of a degree
        DSdataRaw = readtemp12    ; save to this variable to prevent the delay bewtween screen up dates
        ' The function readtemp returns the integer value of the sensor
        DSdata = readtemp

        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 2 )  ; update LCD1
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 2 )  ; update LCD2
        DSdata = DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_1: DisplayInformation ( 3 )  ; update LCD1
        DSdata= DSdataRaw ; Set the data
        LCD_I2C_Address_Current = LCD_I2C_Address_2: DisplayInformation ( 3 )  ; update LCD2

        ccount++

        wait 1 s

    loop
    End

    Sub DisplayInformation ( LCDCommand )

        Select case LCDCommand

        Case 1
          CLS
          print "GCBasic 2015"
          locate 1,0
          print "DS18B20 Demo"

        Case 2
           ' Display the integer value of the sensor on the LCD
           locate 0,0
           print hex(ccount)
           print " Ceil"
           locate 0,8
           print DSdata
           print chr(223)+"C"+"  "

         Case 3

           ' Display the integer and decimal value of the sensor on the LCD

           SignBit = DSdata / 256 / 128
           If SignBit = 0 Then goto Positive
           ' its negative!
           DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

        Positive:

           ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
           TempC_100 =  DSdata * 6
           DSdata = ( DSdata * 25 ) / 100
           TempC_100 = TempC_100 + DSdata

           Whole = TempC_100 / 100
           Fract = TempC_100 % 100
           If SignBit = 0 Then goto DisplayTemp
           Print "-"

        DisplayTemp:
           locate 1,0
           print hex(ccount)
           print " Real"
           locate 1,8
           print str(Whole)
           print "."
          ' To ensure the decimal part is two digits
           Dig = Fract / 10
           print Dig
           Dig = Fract % 10
           print Dig
           print chr(223)
           print "C"+"  "

        End Select

    end sub</screen>
</section>
</section>
</section>
<section xml:id="_pulse_width_modulation">
<title>Pulse width modulation</title>
<simpara>This is the Pulse width modulation section of the Help file.  Please refer the sub-sections for details using the contents/folder view for the MicroChip PIC PWM capabilities and the ATMEL AVR PWM capabilities.</simpara>
<section xml:id="_microchip_pic_pwm_overview">
<title>Microchip PIC PWM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller to control
items like the speed of a motor, or the brightness of a LED or lamp.<?asciidoc-br?></simpara>
<simpara>The methods can also be used to generate the appropriate frequency signal to drive an
infrared LED for remote control applications.<?asciidoc-br?></simpara>
<simpara>Great Cow BASIC support the four different method shown below:<?asciidoc-br?>
&#160;&#160;&#160; - Two methods use the microcontroller CCP module<?asciidoc-br?>
&#160;&#160;&#160; - One method uses the microcontroller PWM module, and<?asciidoc-br?>
&#160;&#160;&#160; - One method is a software emulation of PWM.<?asciidoc-br?></simpara>
<simpara><emphasis role="strong"><emphasis>Hardware PWM using a CCP module</emphasis></emphasis></simpara>
<simpara>Using PWM with the CCP module:  This option requires a CCP module within the microcontroller.<?asciidoc-br?></simpara>
<simpara>Hardware PWM is only available through the "CCP" or "CCPx" pin. This is a hardware limitation of Microchip PIC microcontrollers.<?asciidoc-br?></simpara>
<simpara>Microcontrollers with PPS can change the pin - use the PPS tool to set the desired output pin.<?asciidoc-br?></simpara>
<simpara>This method uses three parameters to setup the PWM.</simpara>
<screen>    'HPWM channel, frequency, duty cycle
    HPWM 1, 76, 80</screen>
<simpara><emphasis role="strong"><emphasis>Hardware PWM using a PWM module</emphasis></emphasis></simpara>
<simpara>Using microcontroller PWM module.  This option requires a PWM module within the microcontroller
Microcontrollers with PPS can change the pin - use the PPS tool to set the desired output pin.<?asciidoc-br?></simpara>
<simpara>This method uses four parameters to setup the PWM.</simpara>
<screen>    'HPWM channel, frequency, duty cycle, timer
    HPWM 5, 76, 80, 2</screen>
<simpara><emphasis role="strong"><emphasis>Hardware PWM using the CCP1 in fixed mode</emphasis></emphasis></simpara>
<simpara>Using Hardware PWM on fixed mode PWM requires a CCP1 module.</simpara>
<simpara>The fixed mode can use CCP1 only, and, the parameters of the PWM cannot be dynamically changed in the user program.&#160;&#160;&#160;The parameters are fixed by the definition of two constants.</simpara>
<screen>    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %

    HPWMOn

    wait 5 s

    HPWMOff</screen>
<simpara><emphasis role="strong"><emphasis>Software PWM</emphasis></emphasis></simpara>
<simpara>Using Software PWM on requires no specific modules with the microcontroller.<?asciidoc-br?></simpara>
<simpara>The PWM parameters for duty and the number of pulses can be changed dynamically in the user program.<?asciidoc-br?></simpara>
<simpara>The PWM is <emphasis role="strong">only</emphasis> operational for the number of cycles stated in the calling method.<?asciidoc-br?></simpara>
<screen>    'A call to use the software PWM on the specific port, with a duty of 127 for 100 cycles

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

  ; ----- Define Hardware settings
    'PWM port out.  This is not required but a good practice.
    dir PWM_Out1 out

    'Pulse the PWM
    PWMOut 1, 127, 100</screen>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>A number of constants are used to control settings for the PWM hardware module of the microcontroller.
To set them, place a line in the main program file that uses #define to assign a value to the particular
constant.<?asciidoc-br?></simpara>
<section xml:id="_pwm_software_mode">
<title>PWM Software Mode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOut <emphasis>channel, duty cycle, cycles</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.  This method does NOT require a PWM module within the microcontroller.</simpara>
<simpara>This command uses a software PWM routine within Great Cow BASIC to produce
a PWM signal on the selected port of the chip.</simpara>
<simpara>The method <literal>PWMOut</literal> does not make use of any special hardware within the microcontroller.
The PWM signal is generated only while the <literal>PWMOut</literal> command is executing - therefore, when the <literal>PWMOut</literal> is not executing
by moving onto the next command, the PWM signal will stop.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmout">PWMOut</link></simpara>
<section xml:id="_pwmout">
<title>PWMOut</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOut <emphasis>channel, duty cycle, cycles</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.  This method does NOT require a PWM module within the microcontroller.</simpara>
<simpara>This command uses a software PWM routine within Great Cow BASIC to produce
a PWM signal on the selected port of the chip.</simpara>
<simpara>The method <literal>PWMOut</literal> does not make use of any special hardware within the microcontroller.
The PWM signal is generated only while the <literal>PWMOut</literal> command is executing - therefore, when the <literal>PWMOut</literal> is not executing
by moving onto the next command, the PWM signal will stop.</simpara>
<simpara><emphasis role="strong">Explanation :</emphasis></simpara>
<simpara><literal><emphasis>channel</emphasis></literal> sets the channel that the PWM is to be generated on. This must
have been defined previously by setting the constants <literal>PWM_Out1</literal><?asciidoc-br?></simpara>
<simpara><literal>PWM_Out2</literal>, <literal>PWM_Out3</literal> or <literal>PWM_Out4</literal>. The maximum number of channels available
is 4.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the PWM duty cycle, and ranges from 0 to 255. 255
corresponds to 100%, 127 to 50%, 63 to 25%, and so on.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>cycles</emphasis></literal> is used to set the amount of PWM pulses to supply. This is
useful for situations in which a pulse of a specific length is required.<?asciidoc-br?></simpara>
<simpara>The formula for calculating the time taken for one cycle is:<?asciidoc-br?></simpara>
<screen>    T<subscript>CYCLE</subscript> = (28 + 10C)T<subscript>OSC</subscript>+ (255 * PWM_Delay)</screen>
<simpara>where: <?asciidoc-br?></simpara>
<simpara>&#160;&#160;&#160;-C is the number of channels used<?asciidoc-br?>
&#160;&#160;&#160;-T<subscript>OSC</subscript> is the length of time taken to execute 1 instruction on the chip (0.2 us on a 20 MHz chip, 1
us on a 4 Mhz chip)<?asciidoc-br?>
&#160;&#160;&#160;-PWM_Delay is a length of time specified using the <literal>PWM_Delay</literal> constant<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example 1 :</emphasis></simpara>
<screen>    'This program controls the brightness of an LED on PORTB.0
    'using the software PWM routine and a potentiometer.
    #chip 16f877a, 20

    ; ----- Constants
    'PWM constant. This is a required constant.
    #define PWM_Out1 portb.0

    ; ---- Optional Constant to add an delay after PWM pulse
    ''#Define PWM_Delay 1 us


    ; ----- Define Hardware settings
    'PWM port out.  This is not required but good practice.
    dir PWM_Out1 out

    'A potentiometer is attached to ANO

    ; ----- Variables
    ' No Variables specified in this example.

    ; ----- Main body of program commences here.
      do
          '100 cycles is a purely arbitrary value as the loop will maintain a relatively constant PWM
          PWMOut 1, ReadAD(AN0), 100
      loop

end</screen>
<simpara><emphasis role="strong">Example 2 :</emphasis></simpara>
<screen>    'This program controls the brightness of an LED on gpio.1
    'using the software PWM routine and a potentiometer.
    #chip 12f675, 4

    ; ----- Constants
      'PWM constant. This is a required constant.
      #define PWM_Out1 gpio.1

    ; ----- Define Hardware settings
      'PWM port out.  This is not required but good practice.
      dir PWM_Out1 out

      'A potentiometer is attached to ANO

    ; ----- Variables
      ' No Variables specified in this example.

    ; ----- Main body of program commences here.
        do
          '100 cycles is a purely arbitrary value
            PWMOut 1, ReadAD(AN0), 100
        loop
    end</screen>
</section>
</section>
<section xml:id="_hpwm_ccp">
<title>HPWM CCP</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWM <emphasis>channel, frequency, duty cycle</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM (CCP)
module.</simpara>
<simpara>This command supports the CCP 8 bit support with <emphasis role="strong">Timer 2 only</emphasis>.<?asciidoc-br?></simpara>
<simpara>For PWM 10 Bit support with other timers - see here <link linkend="_hpwm_10_bit">HPWM 10 Bit</link></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle.<?asciidoc-br?></simpara>
<simpara>If you only need one particular frequency and duty cycle, you should use PWMOn and
the constants PWM_Freq and PWM_Duty instead.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2, 3, 4 or 5, and corresponds to the pins CCP1, CCP2, CCP3, CCP4 and CCP5
respectively. On chips with only one CCP port, pin CCP or CCP1 is always
used, and <literal><emphasis>channel</emphasis></literal> is ignored. (It should be set to 1 anyway to allow
for future upgrades to more powerful microcontrollers.)</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 255 where 255 is 100% duty cycle.</simpara>
<simpara>To stop the PWM signal use the <literal>HPWMOff</literal> method with the parameter of the channel.</simpara>
<screen>    'Stop the CCP/PWM signal
    HPWMOff ( 1 )</screen>
<simpara>The optional constant <literal>HPWM_FAST</literal> can be defined to enable the recalculation of the
timer prescaler when needed.  This will provide faster operation, but uses extra byte
of RAM and may cause problems if <literal>HPWM</literal> and <literal>PWMOn</literal> are used together in a program.
This will not cause any issue when using <literal>HPWM</literal> and <literal>PWMOff</literal> in the same program with <literal>HPWM_FAST</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'CCP/PWM.

    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 255 to 1
            HPWM 1, 40, Bright
            wait 10 ms
        next
    loop</screen>
<section xml:id="_hpwmoff">
<title>HPWMOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMOff ( channel )   'selectively turn off the CCP channel

    HPWMOff               'turn off CCP channel 1 only</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture&amp;Compare/PWM (CCP) modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Select chip model and speed
    #chip 16F877A, 20

    'Set the CCP1 pin to output mode
    DIR PORTC.2 out

    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 1, 40, Bright
            wait 10 ms
        next

        wait 1 s
        HPWMOff ( 1 )' turn off the PWM channel

    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_hpwmoff_2">HPWMOff</link></simpara>
</section>
</section>
<section xml:id="_hpwm_10_bit">
<title>HPWM 10 Bit</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWM <emphasis>channel, frequency, duty cycle, timer</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara><emphasis role="strong">Only</emphasis> available on Microchip PIC microcontrollers with the PWM module.</simpara>
<simpara>For the Capture/Compare/PWM (CCP) module, see here <link linkend="_hpwm_ccp">HPWM CCP</link></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. Once this command
is called, the PWM will be emitted until PWMOff is called.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 3, 4, 5, 6 or 7. These corresponds to the HPWM3, HPWM4, HPWM5, HPWM6 or HPWM7
respectively.<?asciidoc-br?>
The channel <emphasis role="strong">MUST</emphasis> be supported by the microcontroller.   Check the microcontroller specific datasheet for the available channel.</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output. It is measured in KHz.
The maximum value allowed is 255 KHz. The minimum value varies depending
on the clock speed. 1 KHz is the minimum on chips 16 MHz or under and 2
Khz is the lowest possible on 20 MHz chips. In situations that do not
require a specific PWM frequency, the PWM frequency should equal
approximately 1 five-hundredth the clock speed of the microcontroller (ie 40 Khz on
a 20 MHz chip, 16 KHz on an 8 MHz chip). This gives the best duty cycle
resolution possible.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.&#160;&#160;&#160; This should be a WORD value. &#160;&#160;&#160;Note: Byte values are supported as a Byte value is factorised to a Word value.</simpara>
<simpara><literal><emphasis>timer</emphasis></literal> specifies the desired to be used. These can be timer 2, 4 or 6.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for Great Cow Basic
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F1705, 32

    'Generated by PIC PPS Tool for Great Cow Basic
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM3
            RA2PPS = 0x000E    'PWM3OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    dim Bright as word

    'Main code
    do
        'Turn up brightness over the range
        For Bright = 0 to 1023
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over the range
        For Bright = 1023 to 0
            HPWM 3, 40, Bright, 2
            wait 10 ms
        next
    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff">PWMOff</link></simpara>
<section xml:id="_hpwmupdate">
<title>HPWMUpdate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMUpdate ( channel, duty_cycle )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara><emphasis role="strong">Only</emphasis> available on Microchip PIC microcontrollers with the PWM module.</simpara>
<simpara>For the Capture/Compare/PWM (CCP) module, see here <link linkend="_hpwm_ccp">HPWM CCP</link></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command updates the <emphasis role="strong">duty cycle only</emphasis>.  You <emphasis role="strong">MUST</emphasis> have previously called the HPWM 10 Bit command using the full command (see <link linkend="_hpwm_10_bit">HPWM 10 Bit</link>) to set the channel specific settings for frequency and timer source.&#160;&#160;See the example below for the usage.</simpara>
<simpara>This command only supports the previously called HPWM 10 Bit command, or, if you have set more than one HPWM 10 Bit PWM channel then to use the command you must have set the channel to the same frequency.</simpara>
<simpara>The command only supports the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform at the previously defined frequency and timer source.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 3, 4, 5, 6 or 7. These corresponds to the HPWM3, HPWM4, HPWM5, HPWM6 or HPWM7
respectively.&#160;&#160;The channel <emphasis role="strong">MUST</emphasis> be supported by the microcontroller.&#160;&#160;&#160;Check the microcontroller specific datasheet for the available channel.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and
ranges from 0 to 1023 where 1023 is 100% duty cycle.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for Great Cow Basic
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Setup PWM - this is mandated as this specifies the frequency and the clock source.
    HPWM 6, 40, 0, 2
    'Main code
    do
        'Turn up brightness over 2.5 seconds
        For Bright = 0 to 1023
            HPWMUpdate 6, Bright
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 1023 to 0
            HPWMUpdate 6, Bright
            wait 10 ms
        next
    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff">PWMOff</link>, <link linkend="_hpwm_10_bit">HPWM 10 Bit</link></simpara>
</section>
<section xml:id="_hpwmoff_2">
<title>HPWMOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HPWMOff ( channel, PWMHardware )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with PWM modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will disable the output of the PWM module on the Microchip PIC chip.<?asciidoc-br?></simpara>
<simpara><literal>PWMHardware</literal> is a Great Cow BASIC defined constant not a user vaariable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> 'This program will alter the brightness of an LED using
    'hardware PWM.

    'Select chip model and speed
    #chip 16F18855, 32

    'Generated by PIC PPS Tool for Great Cow Basic
    '
    'Template comment at the start of the config file
    '
    #startup InitPPS, 85

    Sub InitPPS

            'Module: PWM6
            RA2PPS = 0x000E    'PWM6OUT &gt; RA2

    End Sub
    'Template comment at the end of the config file


    'Set the PWM pin to output mode
    DIR PORTA.2 out

    'Main code
    For ForLoop = 1 to 4
        'Turn up brightness over 2.5 seconds
        For Bright = 1 to 255
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
        'Turn down brightness over 2.5 seconds
        For Bright = 255 to 1
            HPWM 6, 40, Bright, 2
            wait 10 ms
        next
    next

    HPWMOff 6, PWMHardware   'where PWMHardware is the defined constant or you can use TRUE</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_hpwmoffccp">HPWMOff</link></simpara>
</section>
</section>
<section xml:id="_hpwm_fixed_mode">
<title>HPWM Fixed Mode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOn

    'or

    PWMOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara><emphasis role="strong">Only</emphasis> available on Microchip PIC microcontrollers with a CCP1 module.</simpara>
<simpara>See here <link linkend="_hpwm_ccp">HPWM CCP</link> for the method to change PWM parameters dynamically or to use other CCP channels - this method is fixed to CCP1.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command sets up the hardware PWM module of the Microchip PIC microcontroller to generate
a PWM waveform of the given frequency and duty cycle. &#160;&#160;Once this command
is called, the PWM will be emitted until PWMOff is called.</simpara>
<simpara>These constants are required for PWMOn.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Freq</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output frequency of the PWM module in KHz.</simpara></entry>
<entry align="left" valign="top"><simpara>38</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Duty</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the duty cycle of the PWM module output. Given as percentage.</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 16f877a,20

    'Set the PWM pin to output mode
    DIR PORTC.2 out

    'Main code

    #define PWM_Freq 38      'Frequency of PWM in KHz
    #define PWM_Duty 50      'Duty cycle of PWM (%)

    PWMOn

    wait 10 s                'Wait 10 s

    PWMOff

    do
    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmon">PWMOn</link> and <link linkend="_pwmoff">PWMOff</link> <emphasis role="strong">or, for AVR see</emphasis> <link linkend="_hpwm_fixed_mode_for_avr">Fixed Mode PWM for AVR</link></simpara>
<section xml:id="_pwmon">
<title>PWMOn</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOn</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM
module CCP1.</simpara>
<simpara>This command does not operate on any other CCP channel.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will enable the output of the CCP1/PWM module on the Microchip PIC microcontroller.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, also see</emphasis> <link linkend="_pwmoff">PWMOff</link></simpara>
</section>
<section xml:id="_pwmoff">
<title>PWMOff</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available on Microchip PIC microcontrollers with Capture/Compare/PWM
module CCP1.</simpara>
<simpara>This command does not operate on any other CCP channel.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will disable the output of the CCP1/PWM module on the Microchip PIC chip.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will enable a 76 Khz PWM signal, with a duty cycle
    'of 80%. It will emit the signal for 10 seconds, then stop.
    #define PWM_Freq 76    'Set frequency in KHz
    #define PWM_Duty 80    'Set duty cycle to 80 %
    PWMOn                  'Turn on the PWM
    WAIT 10 s              'Wait 10 seconds
    PWMOff                 'Turn off the PWM</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">For more help, also see</emphasis> <link linkend="_pwmon">PWMOn</link></simpara>
</section>
</section>
<section xml:id="_hardware_pwm_code_optimisation">
<title>Hardware PWM Code Optimisation</title>
<simpara><emphasis role="strong">About Hardware PWM Code Optimisation</emphasis></simpara>
<simpara>For compatibility all channels are supported by default.  This is maintains backward compatibility.<?asciidoc-br?></simpara>
<simpara>To mimise the code, use the following to disable support for a specific Capture/Compare/PWM (CCP) module, timers or the PWM module.<?asciidoc-br?></simpara>
<simpara>Setting a constant to <emphasis>FALSE</emphasis> will remove the support of the capability from the method and therefore will reduce the program size.</simpara>
<screen>    #define USE_HPWMCCP1 FALSE
    #define USE_HPWMCCP2 FALSE
    #define USE_HPWMCCP3 FALSE
    #define USE_HPWMCCP4 FALSE</screen>
<simpara>To further mimise the code, use the following to disable support for a specific PWM channels.  Only PWM channels 5, 6 and 7 are supported.</simpara>
<screen>    #define USE_HPWM3 FALSE
    #define USE_HPWM4 FALSE
    #define USE_HPWM5 FALSE
    #define USE_HPWM6 FALSE
    #define USE_HPWM7 FALSE</screen>
<simpara>To further mimise the code, use the following to disable support for a specific timers.</simpara>
<screen>    #define USE_HPWM_TIMER2 TRUE
    #define USE_HPWM_TIMER4 TRUE
    #define USE_HPWM_TIMER6 TRUE</screen>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<simpara>This will save 335 bytes of program memory by removing support for CCP1, CCP2 and CCP4.</simpara>
<screen>    #chip 16f18855,32
    #Config FEXTOSC_OFF, RSTOSC_HFINT32
    #Config WRT_OFF, CPD_ON, MCLRE_ON

    UNLOCKPPS
        RC2PPS = 0x0A       'RC2-&gt;CCP2:CCP2;
    LOCKPPS

    #define USE_HPWMCCP1 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP2 TRUE        ' This is used so include in the compiled code
    #define USE_HPWMCCP3 FALSE       ' This is not used so optimise
    #define USE_HPWMCCP4 FALSE       ' This is not used so optimise


    'Setting the port an output is VERY important... LED will not work if you do not set as an output.
    dir portC.2 out    ; CCP2

    do forever
            For Bright = 1 to 255
                HPWM 2, 40, Bright
                wait 10 ms
            next

    loop</screen>
</section>
</section>
<section xml:id="_atmel_avr_pwm_overview">
<title>ATMEL AVR PWM Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The methods described in this section allow the generation of Pulse
Width Modulation (PWM) signals. PWM signals enables the microcontroller to control
items like the speed of a motor, or the brightness of a LED or lamp.<?asciidoc-br?></simpara>
<simpara>The methods can also be used to generate the appropriate frequency signal to drive an
infrared LED for remote control applications.<?asciidoc-br?></simpara>
<simpara>Great Cow BASIC support the methods described in this section.</simpara>
<simpara><emphasis role="strong">Hardware PWM using a Timer/Counter with a OCRnx module</emphasis></simpara>
<simpara>The AVR devices use a Timer/Counter and OCRnx module that has a variable period register.  The
Hardware PWM is available through the OCnx pin.</simpara>
<simpara>The method uses three parameters to setup the HPWM.</simpara>
<literallayout class="monospaced">'HPWM channel, frequency, duty cycle
HPWM  2, 100, 50</literallayout>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>A number of constants are used to control settings for PWM hardware module of the microcontroller.
To set them, place a line in the main program file that uses #define to assign a value to the particular constant.</simpara>
<simpara>&#160;<?asciidoc-br?>
&#160;<?asciidoc-br?>
&#160;<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">See</emphasis> <link linkend="_hpwm_avr_ocrnx">HPWM AVR OCRnx</link></simpara>
<section xml:id="_hpwm_avr_ocrnx">
<title>HPWM AVR OCRnx</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>     HPWM <emphasis>channel</emphasis>, <emphasis>frequency</emphasis>, <emphasis>duty cycle</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>The HPWM command is available on Atmel AVR microcontrollers with an OCnx pin, and is compatible with the PIC HPWM command method.  Due to the the unique way of AVR PWM implementation, and code efficiency, there are some notable differences in the HPWM initialization and its use.</simpara>
<simpara>This command supports the Fast PWM Mode and period registers for their respective devices.  Typically Timer0 and Timer2 do not have a period register and the "A" channel is sacrificed to provide that function.  Therefore, channel 1 and channel 6 will not be available, but are documented for possible future use.  Some device Timers do not have an adjustable period register, so this command is not feasible (consult the datasheet).</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The HPWM command sets up the hardware PWM module of the Atmel AVR microcontrollers to generate a PWM waveform of the given frequency and duty cycle.  Once this command is called, the PWM will be emitted until the duty cycle parameter is written to zero.</simpara>
<simpara>If the need is just one particular frequency and duty cycle, one should use PWMOn and the constants PWM_Freq and PWM_Duty instead.  PWMOn for the AVR is uniquely assigned to the OC0B pin, or channel 2. PWMOff will only shutdown  the AVR HPWM channel 2.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> described as 1, 2, 3,&#8230;&#8203;16 correspond to the pins OCR0A, OCR0B&#8230;&#8203;.OCR5C as detailed in the <emphasis>channel</emphasis> constant table.  Channel 1 and channel 6 are not available.</simpara>
<simpara><literal><emphasis>frequency</emphasis></literal> sets the frequency of the PWM output measured in Khz.  The maximum value allowed is 255 KHz. In situations that do not require a specific PWM frequency, the PWM frequency should equal approximately 4 times the clock speed (GCB chipMHz) of the microcontroller (ie 63 KHz on a 16 MHz chip, 32 KHz on 8 MHz, 4 Khz on 1 MHz).  This gives the best duty cycle resolution possible.  Alternate frequencies with good duty cycle resolution are 1Khz, and 4Khz with chipMhz values of 16 and 8 respectively.</simpara>
<simpara><literal><emphasis>duty cycle</emphasis></literal> specifies the desired duty cycle of the PWM signal, and ranges from 0 to 255 where 255 is 100% duty cycle.  The AVR fast PWM mode has a small spike at the extreme setting of  0x00, on most devices, with each period register rollover.  By using the HPWM command, and writing 0x00 to the duty cycle parameter, the PWM signal will shutdown completely and avoid the spike.  The PWM signal can then be restarted again with a new HPWM command.</simpara>
<simpara>Note: Due to the AVR having a timer prescaler of just 1, 8, and 64; the AVR frequency and duty cycle resolution will be different from the PIC frequency and duty cycle resolution.   The AVR HPWM parameters will likely need adjusting ,when substituted into an existing PIC program, and where accuracy is required.</simpara>
<simpara><emphasis role="strong">HPWM Constants:</emphasis></simpara>
<simpara>The AVR HPWM timer constants for channel number control are shown in the table below.  Each timer constant needs to be defined for any one of the channels it controls.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="66*"/>
<colspec colname="col_3" colwidth="16*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Timer</emphasis><?asciidoc-br?>
<emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AVRTC0</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC0 associated  with <emphasis>channel</emphasis> 1, and 2</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC1</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC1 associated  with <emphasis>channel</emphasis> 3, 4 and 5<?asciidoc-br?>
Channel 5 present on larger pinout devices</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC2</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC2 associated  with <emphasis>channel</emphasis> 6, and 7</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC3</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC3 associated  with <emphasis>channel</emphasis> 8, 9, and 10</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC4</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC4 associated  with <emphasis>channel</emphasis> 11,12, and 13</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRTC5</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR TC5 associated  with <emphasis>channel</emphasis> 14, 15, and 16</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC HPWM channel constants for output pin control are shown in the table below.  Each HPWM channel used needs to be defined.  The Port pin associated with each OCnx must be set to output.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="16*"/>
<colspec colname="col_2" colwidth="66*"/>
<colspec colname="col_3" colwidth="16*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Channel</emphasis><?asciidoc-br?>
<emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Options</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN1</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 1 to the associated output pin OC0A<?asciidoc-br?>
OCR0A is used as period register and thus not available</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN2</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 2 to the associated output pin OC0B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN3</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 3 to the associated output pin OC1A<?asciidoc-br?>
MUX&#8217;d  with OC0A pin on some ATTiny&#8217;s</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN4</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 4 to the associated output pin OC1B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN5</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 5 to the associated output pin OC1C<?asciidoc-br?>
On some larger pinout devices and MUX&#8217;d with OC0A pin</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN6</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 6 to the associated output pin OC2A<?asciidoc-br?>
OCR2A is used as a period register and thus not available</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN7</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 7 to the associated output pin OC2B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN8</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 8 to the associated output pin OC3A</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN9</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 9 to the associated output pin OC3B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN10</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 9 to the associated output pin OC3C</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN11</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 11 to the associated output pin OC4A</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN12</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 12 to the associated output pin OC4B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN13</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 13 to the associated output pin OC4C</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN14</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 14 to the associated output pin OC5A</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN15</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 15 to the associated output pin OC5B</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>AVRCHAN16</simpara></entry>
<entry align="left" valign="top"><simpara>Specifies AVR HPWM <emphasis>channel</emphasis> 16 to the associated output pin OC5C</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>        'Using HPWM command to alternate ramping leds with the UNO board
    #chip mega328,16

    '************pwm************************
    'Must define AVRTCx, AVRCHANx, and set OCnX pin dir to out

    #define AVRTC0    'Timer0
    #define AVRCHAN2
    dir PortD.5 Out   'OC0B, UNO pin 5

    #define AVRTC1    'Timer1
    #define AVRCHAN3
    #define AVRCHAN4
    dir PortB.1 out   'OC1A, UNO pin 9
    dir PortB.2 Out   'OC1B, UNO pin 10

    #define AVRTC2    'Timer2
    #define AVRCHAN7
    dir PortD.3 Out   'OC2B, UNO pin 3

    do

    '63khz works good with 16MHz
    '32khz with 8MHz intosc
    '4KHz with 8MHz intosc and ckDiv8 fuse
    freq = 63
      For PWMled1 = 0 to 255
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

      For PWMled1 = 255 to 0
        HPWM 2,freq,PWMled1
        PWMled2 = NOT PWMled1
        HPWM 3,freq,PWMled2
        HPWM 4,freq,PWMled2
        HPWM 7,freq,PWMled1
        wait 5 ms
      Next

    loop</screen>
</section>
<section xml:id="_hpwm_fixed_mode_for_avr">
<title>HPWM Fixed Mode for AVR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PWMOn

    'or

    PWMOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The PWMOn command will only enable the output of the OC0B/PWM module of the Atmel AVR microcontroller.</simpara>
<simpara>This command is not available for any other OCnx/PWM modules.</simpara>
<simpara>This command sets up the hardware PWM module of the Atmel AVR microcontroller to generate
a PWM waveform of the given frequency and duty cycle. &#160;&#160;Once PWMON method
is called, the PWM will be emitted until PWMOff is called.</simpara>
<simpara>These constants are required for PWMOn.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Freq</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output frequency of the PWM module in KHz.</simpara></entry>
<entry align="left" valign="top"><simpara>38</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PWM_Duty</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the duty cycle of the PWM module output. Given as percentage.</simpara></entry>
<entry align="left" valign="top"><simpara>50</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmon_for_avr">PWMOn</link> and <link linkend="_pwmoff_for_avr">PWMOff</link> <emphasis role="strong">or, for Microchip microcontrollers see</emphasis> <link linkend="_hpwm_fixed_mode">Fixed Mode PWM for Microchip</link></simpara>
<section xml:id="_pwmon_for_avr">
<title>PWMOn for AVR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  PWMOn</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The PWMOn command will only enable the output of the OC0B/PWM module of the Atmel AVR microcontroller.</simpara>
<simpara>This command is not available for any other OCnx/PWM modules.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmoff_for_avr">PWMOff</link></simpara>
</section>
<section xml:id="_pwmoff_for_avr">
<title>PWMOff for AVR</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  PWMOff</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>This command is only available on the Atmel AVR microcontrollers with a Timer/Counter0 OC0B register.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The PWMOff command will only disable the output of the OC0B/PWM module of the Atmel AVR microcontrollers.</simpara>
<simpara>This command is not available for any other OCnx/PWM modules.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program demonstrates the PWMOn and PWMOff commands
    'of the fixed mode HPWM on OC0B pin.

    #chip mega328p,16

    'activate appropriate PWM output pins
    dir PortD.5 Out     'OC0B

    'define PWM_Freq in kHz
    'define PWM_Duty in %

    #define PWM_Freq 40
    #define PWM_Duty 50

    do

      'turn on/off single channel 40 KHz PWM on OC0B pin
      PWMON
      wait 5 s
      PWMOFF
      wait 5 s

    loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_pwmon_for_avr">PWMOn</link></simpara>
</section>
</section>
</section>
</section>
<section xml:id="_random_numbers">
<title>Random Numbers</title>
<simpara>This is the Random Numbers section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_overview">
<title>Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These routines allow Great Cow BASIC to generate pseudo-random numbers.</simpara>
<simpara>The generator uses a 16 bit linear feedback shift register to produce
pseudo-random numbers.  The most significant 8 bits of the LFSR are used
to provide an 8 bit random number.</simpara>
<simpara>When compiling a program, Great Cow BASIC will generate an initial seed for the
generator. However, this seed will be the same every time the program
runs, so the sequence of numbers produced by a given program will always
be the same. To work around this, there is a Randomize subroutine. It
can be provided with a new seed for the generator (which will cause the
generator to move to a different point in the sequence). Alternatively,
Randomize can be set to obtain a seed from some other source such as a
timer every time it is run.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the random number generation.
To set them, place a line in the main program file that uses
<literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>RANDOMIZE_SEED</simpara></entry>
<entry align="left" valign="top"><simpara>Source of the random seed if Randomize is called without a parameter</simpara></entry>
<entry align="left" valign="top"><simpara>Timer0</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #define RANDOMIZE_SEED Timer2</screen>
</section>
<section xml:id="_random">
<title>Random</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = Random</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Random</literal> function will generate a pseudo-random number between 0 and 255 inclusive.</simpara>
<simpara>The numbers generated by <literal>Random</literal> will follow the same sequence every time, until <literal>Randomize</literal> is used.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop</screen>
</section>
<section xml:id="_randomize">
<title>Randomize</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Randomize
    Randomize <emphasis>seed</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Randomize is used to seed the pseudo random number generator, so that it
will produce a different sequence of numbers each time it is used.</simpara>
<simpara>If no <emphasis>seed</emphasis> is specified, then the RANDOMIZE_SEED constant will be used
as the seed. If <emphasis>seed</emphasis> is specified, then it will be used to seed the
generator.</simpara>
<simpara>It is important that the seed is different every time that Randomize is
used. If the seed is always the same, then the sequence of numbers will
always be the same. It is best to use a running timer, an input port, or
the analog to digital converter as the source of the seed, since these
will normally provide a different value each time the program runs.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip tiny2313, 1

    'Use randomize, with the value on PORTD as the seed
    Randomize PORTD

    'Generate random numbers, and output on PORTB
    Do
        PORTB = Random
        Wait 1 s
    Loop</screen>
</section>
</section>
<section xml:id="_7_segment_displays">
<title>7-Segment Displays</title>
<simpara>This is the 7-Segment Displays section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_7_segment_displays_overview">
<title>7 Segment Displays Overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The Great Cow BASIC 7 segment display methods make it easier for Great Cow BASIC programs to
display numbers and letters on 7 segment LED displays.</simpara>
<simpara>The Great Cow BASIC methods support up to four digit 7 segment display devices, common anode/cathode and inversion of the port logic to support driving the device(s) via a transistor.</simpara>
<simpara>There are three ways that the 7 segment display routines can be set up.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Connect the microcontroller to the 7 segment display (via suitable resistors) using  any eight output bits.
</simpara><simpara>Use <literal>DISP_SEG_x</literal> and <literal>DISP_SEL_x</literal> constants to specify the outpout ports and the select port(s) to be used.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.
</simpara><simpara>This implies the connections are consectutive in terms of the 8 output bits of the port.
</simpara><simpara>Use the <literal>DISPLAYPORTn</literal> and <literal>DISPSELECTn</literal> constants to specify the whole port and the select port(s) to be used.
</simpara><simpara>This method will generate the most efficient code.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Connect the microcontroller to the 7 segment display (via suitable resistors) using whole port (8 bits) of the microcontroller.
</simpara><simpara>This implies the connections are consectutive in terms of the 8 output bits of the port.
</simpara><simpara>Use the <literal>DISPLAYPORTn</literal> and <literal>DISP_SEL_n</literal> constants to specify the whole port and the select port(s) to be used.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>The Great Cow BASIC methods  assume the 7 segment display(s) is to be connected to a common
parallel bus with a Common Cathode.   See the sections
<link linkend="_common_cathode">Common Cathode</link> and
<link linkend="_common_anode">Common Anode</link> for examples of using Great Cow BASIC code to
control these different configurations</simpara>
<simpara>Shown below are the differing constants that must be set for the three connectivity options.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Index</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Constants</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEG_x</literal> &amp; <literal>DISP_SEL_x</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEG_x</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin (output bit) used to control a specific segment of the 7 segment display.
</simpara><simpara>There are seven constants that must be specified.
</simpara><simpara><literal>DISP_SEG_A</literal> through <literal>DISP_SEG_G</literal>. One
must be set for each segment.
</simpara><simpara>Typical commands are:
</simpara><simpara><literal>#define DISP_SEG_A portA.0</literal>
</simpara><simpara><literal>#define DISP_SEG_B portA.1</literal>
</simpara><simpara><literal>#define DISP_SEG_C portA.2</literal>
</simpara><simpara><literal>#define DISP_SEG_D portA.3</literal>
</simpara><simpara><literal>#define DISP_SEG_E portA.4</literal>
</simpara><simpara><literal>#define DISP_SEG_F portA.5</literal>
</simpara><simpara><literal>#define DISP_SEG_G portA.6</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEG_DOT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin (output bit) used to control the decimal point on the
7 segment display.
</simpara><simpara>Typical commands are:
</simpara><simpara><literal>#define DISP_SEG_DOT portA.7</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Optional.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEL_x</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output pin (output bit) used to control a specific 7 segment display.
</simpara><simpara>These constants are used to control the specific 7 segment display being addresses.
</simpara><simpara>Typical commands are:
</simpara><simpara><literal>#define DISP_SEL_1 portA.0</literal>
</simpara><simpara><literal>#define DISP_SEL_2 portA.1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>A valid output pin (output bit) must be specified.  Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal> &amp; <literal>DISPSELECTn</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output port used to control the 7 segment display.
</simpara><simpara>Port.bit &gt;&gt; Segment
</simpara><simpara>port.0      &gt;&gt;   A
</simpara><simpara>port.1     &gt;&gt;   B
</simpara><simpara>port.2     &gt;&gt;   C
</simpara><simpara>port.3     &gt;&gt;   D
</simpara><simpara>port.4     &gt;&gt;   E
</simpara><simpara>port.5     &gt;&gt;   F
</simpara><simpara>port.6     &gt;&gt;   G</simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPLAYPORTA</literal> and/or <literal>DISPLAYPORTB</literal> and/or <literal>DISPLAYPORTC</literal> and/or <literal>DISPLAYPORTD</literal>
</simpara><simpara>Where <literal>DISPLAYPORTn</literal> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.
</simpara><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPSELECTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output command used to <emphasis role="strong">select</emphasis> a specific 7 segment display addressed by <literal>DISPLAYPORT_n</literal>.
</simpara><simpara>Used to control output pin (output bit) when several displays are multiplexed.
</simpara><simpara>Typical commands are:
    <literal>#define DispSelectA Set portA.0 on</literal>
</simpara><simpara>    <literal>#define DispSelectB Set portA.1 on</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPSELECTA</literal> and/or <literal>DISPSELECTB</literal> and/or <literal>DISPSELECTC</literal> and/or <literal>DISPSELECTD</literal>
</simpara><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPDESELECTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>An optional command to specify the output command used to <emphasis role="strong">deselect</emphasis> a specific 7 segment display addressed by <literal>DISPLAYPORT_n</literal>.
</simpara><simpara>Used to control output pin (output bit) when several displays are multiplexed.
</simpara><simpara>Typical commands are:
</simpara><simpara>    <literal>#define DispDeSelectA Set portA.0 off</literal>
</simpara><simpara>    <literal>#define DispDeSelectB Set portA.1 off</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPDESELECTA</literal> and/or <literal>DISPDESELECTB</literal> and/or <literal>DISPDESELECTC</literal> and/or <literal>DISPDESELECTD</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal> &amp; <literal>DISP_SEL_n</literal></simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISPLAYPORTn</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output port used to control the 7 segment display.
</simpara><simpara>Port.bit &gt;&gt; Segment
</simpara><simpara>port.0      &gt;&gt;   A
</simpara><simpara>port.1     &gt;&gt;   B
</simpara><simpara>port.2     &gt;&gt;   C
</simpara><simpara>port.3     &gt;&gt;   D
</simpara><simpara>port.4     &gt;&gt;   E
</simpara><simpara>port.5     &gt;&gt;   F
</simpara><simpara>port.6     &gt;&gt;   G</simpara></entry>
<entry align="left" valign="top"><simpara>Can be <literal>DISPLAYPORTA</literal> and/or <literal>DISPLAYPORTB</literal> and/or <literal>DISPLAYPORTC</literal> and/or <literal>DISPLAYPORTD</literal>
</simpara><simpara>Where <literal>DISPLAYPORTn</literal> can be A, B, C or D which corresponding to displays 1, 2, 3 and 4, respectively.
</simpara><simpara>Must be specified to use this connectivity option.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"><simpara><literal>DISP_SEL_n</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specifies the output command used to select a specific 7 segment display addressed by <literal>DISPLAYPORTn</literal>.
</simpara><simpara>Typical commands are:
</simpara><simpara>    <literal>#define DISP_SEL_1 portA.0</literal>
</simpara><simpara>    <literal>#define DISP_SEL_2 portA.1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified to use this connectivity option.
</simpara><simpara>Can be specified as <literal>DISP_SEL_1</literal> and/or <literal>DISP_SEL_2</literal> and/or <literal>DISP_SEL_3</literal> and/or <literal>DISP_SEL_4</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen> 'A Common Cathode 7 Segment display  2 digit example

 #chip 16F886, 8

    'support for Common Anode
    '#define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    '#define 7Seg_HighSide

' ----- Constants
	  ' You need to specify the port settings
	  ' by one of the following three methods
	  'The Directions of the ports are automaically set according to the defines
	'''METHOD 1  Define individual port pins for segments and selects
	  #define DISP_SEG_A PORTB.0
	  #define DISP_SEG_B PORTB.1
	  #define DISP_SEG_C PORTB.2
	  #define DISP_SEG_D PORTB.3
	  #define DISP_SEG_E PORTB.4
	  #define DISP_SEG_F PORTB.5
	  #define DISP_SEG_G PORTB.6
	  #define DISP_SEG_DOT PORTB.7 '' available on some displays as dp or colon

	  #define DISP_SEL_1 PORTC.5
	  #define DISP_SEL_2 PORTC.4

	'''METHOD 2  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
				''Define DISPSELECTA (B,C,D) for up to 4 digit display selects
	  '#define DISPLAYPORTA PORTB   ' same port name can be assigned
	  '#define DISPLAYPORTB PORTB

	  '#define DispSelectA Set portC.5 off
	  '#define DispSelectB Set portC.4 off
	  '#define DispDeSelectA Set portC.5 on
	  '#define DispDeSelectB Set portC.4 on

	'''METHOD 3  Define DISPLAYPORTA (B,C,D) for up to 4 digit display segments
				''Define port pins for the digit display  selects
	  '#define DISPLAYPORTA PORTB
	  '#define DISPLAYPORTB PORTB

	  '#define DISP_SEL_1 PORTC.5
	  '#define DISP_SEL_2 PORTC.4



		Dim Message As String
		Message = " HAPPY HOLIDAYS  "
		Do
		For Counter = 1 to len(Message)-1
			Repeat 50
				Displaychar 1, Message(Counter)
				wait 3 ms
				DisplayChar 2, Message(Counter+1)
				wait 3 ms

			  end Repeat


			Wait 100 ms
		Next
		Loop</screen>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/CC_4dig_7seg_16F886_Schem.jpg" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/CA_2Dig_7seg_16F886_schem.jpg" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_displaychar">DisplayChar</link>,
<link linkend="_displayvalue">DisplayValue</link></simpara>
<section xml:id="_common_cathode">
<title>Common Cathode</title>
<simpara>This is a Common Cathode 7 Segment display example.</simpara>
<simpara>No additional configuration is required when using Common Cathnode.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comment</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_CommonAnode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Inverts controls for Common Anode displays</simpara></entry>
<entry align="left" valign="top"><simpara>Required for Common Cathode displays</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_HighSide</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Support PFET or PNP high side driving of the display</simpara></entry>
<entry align="left" valign="top"><simpara>Inverts Common Cathode addressing pin logic for multiplexed displays</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>This is a Common Cathode 7 Segment display example.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip model
    #chip 16f1783,8

    'Output ports for the 7-segment device
    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6

    ' This is the usage of the SEG_DOT for decimal point support
	' An optional third parameter of '1' will turn on the decimal point
	' of that digit when using DisplayValue command
    #define DISP_SEG_DOT PortC.7

    'Select ports for the 7-segment device
    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
        For count = 0 to 999
            number = count
            Num2 = 0
            Num3 = 0
            If number &gt;= 100 Then
              Num3 = number / 100
              'SysCalcTempX is the remainder after a division has been completed
              number = SysCalcTempX
            End if
            If number &gt;= 10 Then
              Num2 = number / 10
              number = SysCalcTempX
            end if
            Num1 = number
            Repeat 10
              DisplayValue 1, Num1,1  'Optional third parameter turns on the dp dot on that digit
              wait 5 ms
              DisplayValue 2, Num2
              wait 5 ms
              DisplayValue 3, Num3
              wait 5 ms

            end Repeat
        Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis>
<link linkend="_7_segment_displays_overview">7 Degment Display Overview</link>,
<link linkend="_displaychar">DisplayChar</link>, <link linkend="_displayvalue">DisplayValue</link></simpara>
</section>
<section xml:id="_common_anode">
<title>Common Anode</title>
<simpara>This is a Common Anode 7 Segment display example.</simpara>
<simpara>Additional configuration is required when using Common Anode.</simpara>
<simpara>When setting up the 7 segment Common Anode display you <emphasis role="strong">MUST</emphasis> use the
<literal>7Seg_CommonAnode</literal> constant. You can optionally use the <literal>7Seg_HighSide</literal>
constant to support PFET or PNP high side driving of the Common Anode
displays as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Comment</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_CommonAnode</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Inverts controls for Common Anode displays</simpara></entry>
<entry align="left" valign="top"><simpara>Required for Common Cathode displays</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>7Seg_HighSide</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Support PFET or PNP high side driving of the display</simpara></entry>
<entry align="left" valign="top"><simpara>Inverts Common Cathode addressing pin logic for multiplexed displays</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'A Common Anode 7 Segment display example using bs250p pfets
    'Chip model
    #chip 16f1783,8

    'support for Common Cathode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

    #define DISP_SEG_A PORTC.0
    #define DISP_SEG_B PORTC.1
    #define DISP_SEG_C PORTC.2
    #define DISP_SEG_D PORTC.3
    #define DISP_SEG_E PORTC.4
    #define DISP_SEG_F PORTC.5
    #define DISP_SEG_G PORTC.6
	#define DISP_SEG_DOT PORTC.7

    #define Disp_Sel_1 PortA.1
    #define Disp_Sel_2 PortA.2
    #define Disp_Sel_3 PortA.3

    dim count as word
    dim number as word

    Do Forever
      For count = 0 to 999
          number = count
          Num2 = 0
          Num3 = 0
          If number &gt;= 100 Then
            Num3 = number / 100
            'SysCalcTempX is the remainder after a division has been completed
            number = SysCalcTempX
          End if
          If number &gt;= 10 Then
            Num2 = number / 10
            number = SysCalcTempX
          end if
          Num1 = number
          Repeat 10
            DisplayValue 1, Num1, 1 'Optional third parameter turns on the dp on that digit
            wait 5 ms
            DisplayValue 2, Num2
            wait 5 ms
            DisplayValue 3, Num3
            wait 5 ms
           end Repeat
      Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis>
<link linkend="_7_segment_displays_overview">7 Degment Display Overview</link>,
<link linkend="_displaychar">DisplayChar</link>, <link linkend="_displayvalue">DisplayValue</link></simpara>
</section>
</section>
<section xml:id="_displayvalue">
<title>DisplayValue</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    DisplayValue (<emphasis>display, data, dot</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will display the given value on a seven segment LED
display.</simpara>
<simpara><literal><emphasis>display</emphasis></literal> is the number of the display to use. Up to 4 digits.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>data</emphasis></literal> is the value between 0 and F to be shown.</simpara>
<simpara><literal><emphasis>dot</emphasis></literal> is an optional parameter. When it is 1 then the decimal point for that digit  is turned on.</simpara>
<simpara>The command also support HEX characters in the range between 0x00 and
0x0F (0 to 15). See example two below for usage.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program will count from 0 to 99 on two LED displays
    #chip 16F819, 8
    #config osc = int

  'See 7 Segment Display Overview for alternate ways of defining Ports
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6
  '#define DISP_SEG_DOT PORTB.7 ' Optional DP

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1

    Do
        For Counter = 0 To 99

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number &gt;= 10 Then
                Num1 = Number / 10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    'This program will count from 0 to 0xff on two LED displays
    #chip 16F819, 8
    #config osc = int

    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTA.0
    #define DISP_SEL_2 PORTA.1
    #define DISP_SEL_4 PORTA.2
    #define DISP_SEL_3 PORTA.3

    Do
        For Counter = 0 To 0xff

            'Get the 2 digits
            Number = Counter
            Num1 = 0
            If Number &gt;= 0x10 Then
                Num1 = Number / 0x10
                'SysCalcTempX stores remainder after division
                Number = SysCalcTempX
            End If
            Num2 = Number

            'Show the digits
            'Each DisplayValue will erase the other (multiplexing)
            'So they must be called often enough that the flickering
            'cannot be seen.
            Repeat 500
                DisplayValue 1, Num1
                Wait 1 ms
                DisplayValue 2, Num2
                Wait 1 ms
            End Repeat
        Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_7_segment_displays_overview">7 Segment Display Overview</link>, <link linkend="_displaychar">DisplayChar</link>, <link linkend="_displaysegment">DisplaySegment</link></simpara>
</section>
<section xml:id="_displaychar">
<title>DisplayChar</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    DisplayChar (<emphasis>display, character, dot</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will display the given ASCII character on a seven segment
LED display.</simpara>
<simpara><literal><emphasis>display</emphasis></literal> is the number of the display to use. Up to 4 digits.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>character</emphasis></literal> is the ASCII character to be shown.</simpara>
<simpara><literal><emphasis>dot</emphasis></literal> is an optional parameter. When it is 1 then the decimal point for that digit  is turned on.</simpara>
<simpara>This example below is a Common Cathode configuration.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>   'This program will show " Hello  " on a LED display
    'The display should be connected to PORTB and the Enable on PORTA.0

    #chip 16F877A, 20

    #define DISPLAYPORTA PORTB
    #define DISP_SEL_1 PORTA.0


    Dim Message As String
    Message = " Hello  "
  Do
    For Counter = 1 to len(Message)
      DisplayChar 1, Message(Counter)
      Wait 250 ms
    Next
  Loop</screen>
<simpara>This is a Common Anode example
There are three different methods for port specification
Note the ports are specified bit by bit in this case but
could be specified like Example 1
See Overview for further explanation.</simpara>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>  'This program will show amessage on a LED display
  'This is a Dual digit Common anode with driver transistors example
   #chip 16F886, 8

    'support for Common Anode
    #define 7Seg_CommonAnode

    'support for pfet or pnp high side drivers
    #define 7Seg_HighSide

  ' Constants
  ' You need to specify the port settings
    #define DISP_SEG_A PORTB.0
    #define DISP_SEG_B PORTB.1
    #define DISP_SEG_C PORTB.2
    #define DISP_SEG_D PORTB.3
    #define DISP_SEG_E PORTB.4
    #define DISP_SEG_F PORTB.5
    #define DISP_SEG_G PORTB.6

    #define DISP_SEL_1 PORTC.5
    #define DISP_SEL_2 PORTC.4

    Dim Message As String
    Message = " Happy Holidays  "
    Do
    For Counter = 1 to len(Message)-2
      Repeat 50
        Displaychar 1, Message(Counter)
        wait 3 ms
        DisplayChar 2, Message(Counter+1)
        wait 3 ms
        end Repeat
      Wait 100 ms
    Next
    Loop</screen>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_7_segment_displays_overview">7 Degment Display Overview</link>, <link linkend="_displayvalue">DisplayValue</link>, <link linkend="_displaysegment">DisplaySegment</link></simpara>
</section>
<section xml:id="_displaysegment">
<title>DisplaySegment</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    DisplayValue (<emphasis>display, data</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will display the given value on a seven segment LED
display.</simpara>
<simpara><literal><emphasis>display</emphasis></literal> is the number of the display to use. Up to 4 digits.<?asciidoc-br?></simpara>
<simpara><literal><emphasis>data</emphasis></literal> is the value between 0 and 255. Where <emphasis>data</emphasis> is the representation of the segments to be set.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<screen>      'This program will count from 10 to 0 then fire the rocket!
      'The method DisplaySegment 1, smallTCharacter.  Sets the 7 segment to the value of 120, see the constant, 120 equates to a small t.
      ; ----- Configuration

        #chip 16F690, 4
        #config WDT_OFF

      ; ----- Define Hardware settings
        Dir PORTC Out
        DIR PORTA.5 out
        DIR PORTA.4 out
        DIR PORTA.0 out
        DIR PORTA.1 out
        DIR PORTA.2 in
        DIR PORTB.7 out
      ; ----- Constants
        ; You need to specify the port settings
        #define DISP_SEG_A PORTC.0
        #define DISP_SEG_B PORTC.1
        #define DISP_SEG_C PORTC.2
        #define DISP_SEG_D PORTC.3
        #define DISP_SEG_E PORTC.4
        #define DISP_SEG_F PORTC.5
        #define DISP_SEG_G PORTC.6
        #define DECPNT     PORTC.7
        #define DISP_SEL_1 PORTA.5
        #define DISP_SEL_2 PORTA.4
        #define DISP_SEL_3 PORTA.1
        #define DISP_SEL_4 PORTA.0

        #define smallTCharacter 120 'raw character for 't' on 7 segment.

        #define sw1 PORTA.2

        #define firingPort PORTB.7

      ; ----- Variables
        CountDownValue = 10

      ; ----- Main body of program commences here.
      DECPNT = 1 'Decimal Point off

        Main:
          ' Push number to 7 Segment Display
        if sw1 = 0 then goto Countdown

         num2 = 1
         num3 = 0
         cnt = 5
         gosub display

      goto main

        Countdown:


          num2 = CountDownValue/10
          num3 = CountDownValue%10
          cnt = 60

          gosub display

          If sw1 = 0 then goto hld

          if CountDownValue = 0 then
              firingPort = 1
              cnt = 200
              gosub dispfire
              firingPort = 0
             CountDownValue = 10
             goto main
          end if

          CountDownValue = CountDownValue - 1

        goto Countdown


        display:
         Repeat cnt
                DisplaySegment 1, smallTCharacter
                wait 5 ms
                Displaychar 2, "-"
                DisplayValue 3, Num2
                wait 5 ms
                DisplayValue 4, Num3
                wait 5 ms
         end Repeat

         return

       hld:
        if sw1 = 0 then goto hld
        cnt = 5
        gosub Display
        if sw1 = 1 then goto hld
        goto countdown

       DispFire:
        Repeat cnt

                Displaychar 1, "F"
                wait 5 ms
                Displaychar 2, "i"
                wait 5 ms
                Displaychar 3, "r"
                wait 5 ms
                Displaychar 4, "E"
                wait 5 ms
        End Repeat
       return

      end</screen>
<simpara><emphasis role="strong">Also, see</emphasis> <link linkend="_7_segment_displays_overview">7 Segment Display Overview</link>, <link linkend="_displaychar">DisplayChar</link></simpara>
</section>
</section>
<section xml:id="_one_wire_devices">
<title>One Wire Devices</title>
<simpara>This is the One Wire Devices section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_ds18b20">
<title>DS18B20</title>
<simpara>The DS18B20 is a 1-Wire digital temperature sensor from Maxim IC.</simpara>
<simpara>The sensor reports degrees C with 9 to 12-bit precision from -55C to 125C (+/- 0.5C).</simpara>
<simpara>Each sensor has a unique 64-Bit Serial number etched into it. This allows for a number of sensors to be used on one data bus. This sensor is used in many data-logging and temperature control projects.</simpara>
<simpara>Reading the temperature from a DS18B20 takes up to 750ms.</simpara>
<simpara>To use the DS18B20 driver the following is required to added to the Great Cow BASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;</screen>
<simpara>Note the Great Cow BASIC commands do not work with the older DS1820 or DS18S20 as they have a different internal resolution.</simpara>
<simpara>These commands are not designed to be used with parasitically powered DS18B20 sensors.</simpara>
</section>
<section xml:id="_readdigitaltemp">
<title>ReadDigitalTemp</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ReadDigitalTemp</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Return the value of the sensor in two global variables. The following two lines must be included in the Great Cow BASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</screen>
<simpara>This method returns whole part of the sensor value in the byte variable <literal>DSint</literal>, the method also returns decimal part of the sensor value in the byte variable <literal>DSdec</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    *#include &lt;DS18B20.h&gt;*

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

    ReadDigitalTemp

    ' Display the integer value of the sensor on the LCD
    locate 0,0
    print "Temp"
    locate 0,8
    print DSInt
    print "."
    print DSdec
    print chr(223)+"C"</screen>
</section>
<section xml:id="_readtemp">
<title>ReadTemp</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_var = ReadTemp</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ReadTemp</literal> is a  function that returns the raw value of the sensor. The following two lines must be included in the Great Cow BASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</screen>
<simpara><literal>ReadTemp</literal> reads the sensor and stores in output variable. The conversion takes up to 750ms. Readtemp carries out a full 12 bit conversion and then rounds the result to the nearest full degree Celsius.</simpara>
<simpara>To read the full 12 bit value of the sensor use the <literal>readtemp12</literal> command.</simpara>
<simpara>The temperature is read back in whole degree steps, and the sensor operates from -55 to + 125 degrees Celsius. Note that bit 7 is 0 for positive temperature values and 1 for negative values (ie negative values will appear as 128 + numeric value).</simpara>
<simpara>Note the <literal>Readtemp</literal> command does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    #include &lt;DS18B20.h&gt;

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7

    ' DS18B20 port settings
    #define DQ PortC.3

      ccount = 0
      CLS

    do forever
       ' The function readtemp returns the integer value of the sensor
       DSdata = readtemp

       ' Display the integer value of the sensor on the LCD
       locate 0,0
       print hex(ccount)
       print " Ceil"
       locate 0,8
       print DSdata
       print chr(223)+"C"

       wait 2 s
       ccount++

    loop</screen>
</section>
<section xml:id="_readtemp12">
<title>ReadTemp12</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte_var = ReadTemp12</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ReadTemp12</literal> is a  function that returns the raw value of the sensor. The following two lines must be included in the Great Cow BASIC source file.</simpara>
<screen>    #include &lt;DS18B20.h&gt;
    #define DQ PortC.3 ; change port configuration as required</screen>
<simpara>Reads sensor and stores in output variable. The conversion takes up to 750ms. <literal>Readtemp12</literal> carries out a full 12 bit conversion.</simpara>
<simpara>This command is for advanced users only. For standard ‘whole degree’ data use the <literal>Readtemp</literal> command.</simpara>
<simpara>The temperature is read back as the raw 12 bit data into a word variable (0.0625 degree resolution). The user must interpret the data through mathematical manipulation. See the DS18B20 datasheet for more information on the 12 bit temperature/data information construct.</simpara>
<simpara>The function <literal>readtemp12</literal> does not work with the older DS1820 or DS18S20 as they have a different internal resolution. This command is not designed to be used with parasitically powered DS18B20 sensors, the 5V pin of the sensor must be connected.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Chip Settings. Assumes the development board with with a 16F877A
    #chip 16F877A,1

    <emphasis role="strong">#include &lt;DS18B20.h&gt;</emphasis>

    'Use LCD in 4 pin mode and define LCD pins
    #define LCD_IO 4
    #define LCD_RW PORTE.1
    #define LCD_RS PORTE.0
    #define LCD_Enable PORTE.2
    #define LCD_DB4 PORTD.4
    #define LCD_DB5 PORTD.5
    #define LCD_DB6 PORTD.6
    #define LCD_DB7 PORTD.7


    ' DS18B20 port settings
    #define DQ PortC.3
    dim TempC_100 as word   ' a variable to handle the temperature calculations
    ccount = 0
    CLS

    do forever

       'Display the integer and decimal value of the sensor on the LCD

       ' The function readtemp12 returns the raw value of the sensor.
       ' The sensor is read as a 12 bit value. Each unit equates to 0.0625 of a degree
       DSdata = readtemp12
       SignBit = DSdata / 256 / 128
       If SignBit = 0 Then goto Positive
       ' its negative!
       DSdata = ( DSdata # 0xffff ) + 1 ' take twos comp

    Positive:

       ' Convert value * 0.0625. Mulitple value by 6 then add result to multiplication of the value with 25 then divide result by 100.
       TempC_100 =  DSdata * 6
       DSdata = ( DSdata * 25 ) / 100
       TempC_100 = TempC_100 + DSdata

       Whole = TempC_100 / 100
       Fract = TempC_100 % 100
       If SignBit = 0 Then goto DisplayTemp
       Print "-"

    DisplayTemp:
       locate 1,0
       print hex(ccount)
       print " Real"
       locate 1,8
       print str(Whole)
       print "."
      ' To ensure the decimal part is two digits
       Dig = Fract / 10
       print Dig
       Dig = Fract % 10
       print Dig
       print chr(223)
       print "C"
       wait 2 s
       ccount++

    loop</screen>
</section>
</section>
<section xml:id="_serial_communications">
<title>Serial Communications</title>
<simpara>This is the Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_software">
<title>RS232 (software)</title>
<simpara>This is the Software Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_software_overview">
<title>RS232 Software Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These routines allow the microcontroller to send and receive RS232 data.</simpara>
<simpara>All functions are implemented using software, so no special hardware is
required on the microcontroller. However, if the microcontroller has a
hardware serial module (usually referred to as UART or USART), and the
serial data lines are connected to the appropriate pins, the hardware
routines should be used for smaller code, improved reliability and
higher baud rates.</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses <literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name/s</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SendALow</literal>, <literal>SendBLow</literal>, <literal>SendCLow</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the commands used to send a low (0) bit on
serial channels A, B and C respectively.</simpara></entry>
<entry align="left" valign="top"><simpara>No Default<?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SendAHigh</literal>, <literal>SendBHigh</literal>, <literal>SendCHigh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>These are used to define the commands used to send a high (1) bit on
serial channels A, B and C respectively.</simpara></entry>
<entry align="left" valign="top"><simpara>No Default<?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RecALow</literal>, <literal>RecBLow</literal>, <literal>RecCLow</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The condition that is true when a low bit is being received</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Sys232Temp.0 OFF</literal><?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>RecAHigh</literal>, <literal>RecBHigh</literal>, <literal>RecCHigh</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The condition that is true when a high bit is being received</simpara></entry>
<entry align="left" valign="top"><simpara><literal>Sys232Temp.0 ON</literal><?asciidoc-br?>
<emphasis role="strong">Must be defined</emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_initser">
<title>InitSer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	<literal>InitSer</literal> <emphasis>channel, rate, start, data, stop, parity, invert</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will set up the serial communications. The parameters are
as follows:</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is 1, 2 or 3, and refers to the I/O ports that are used for
communication.</simpara>
<simpara><literal><emphasis>rate</emphasis></literal> is the bit rate, which is given by the letter r and then the
desiredrate in bps. Acceptable units are r300, r600, r1200, r2400,
r4800, r9600 and r19200.</simpara>
<simpara><literal><emphasis>start</emphasis></literal> gives the number of start bits, which is usually 1. To make
the microcontroller wait for the start bit before proceeding with the receive, add
128 to <literal><emphasis>start</emphasis></literal>. (Note: it may be desirable to use the <literal>WaitForStart</literal>
constant here.)</simpara>
<simpara><literal><emphasis>data</emphasis></literal> tells the program how many data bits are to be sent or received.
In most situations t his is 8, but it can range between 1 and 8,
inclusive.</simpara>
<simpara><literal><emphasis>stop</emphasis></literal> is the number of stop bits. If <emphasis>start</emphasis> bit 7 is on, then this
number will be ignored.</simpara>
<simpara><literal><emphasis>parity</emphasis></literal> refers to a system of error checking used by many devices. It
can be odd (in which there must always be an odd number of high bits),
even (where the number of high bits must always be even), or none (for
systems that do not use parity).</simpara>
<simpara><literal><emphasis>invert</emphasis></literal> can be either "normal" or "invert". If it in "invert", then
high bits will be changed to low, and low to high.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please refer to <link linkend="_sersend">SerSend</link> for an example of <literal>InitSer</literal></simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link></simpara>
</section>
<section xml:id="_sersend">
<title>SerSend</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  SerSend <emphasis>channel</emphasis>, <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by <literal><emphasis>data</emphasis></literal> using the RS232 channel
referred to as <literal><emphasis>channel</emphasis></literal> according to the rules set using <literal>InitSer</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will send a byte using PORTB.2, the value of which
  'depends on whether a button is pressed. This can be used with the example for SerReceive.

  #chip 16F819, 8
  #config Osc = Int

  #define RS232Out PORTB.2
  #define RS232In  PORTB.1

  Dir RS232Out Out
  Dir RS232In In

  'Config Software-UART
  #define SendAHigh Set RS232Out ON
  #define SendALow Set RS232Out OFF
  #define RecAHigh Set RS232In ON
  #define RecALow Set RS232In OFF

  Dir Button In

  InitSer 1, r9600, 1+WaitForStart, 8, 1, none, normal
  Do
    If Button = On Then Temp = 100
    If Button = Off Then Temp = 0
    SerSend 1, Temp
    Wait 100 ms
  Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link>,
<link linkend="_initser">InitSer</link></simpara>
</section>
<section xml:id="_serreceive">
<title>SerReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	SerReceive <emphasis>channel</emphasis>, <emphasis>output</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a byte from the RS232 channel given by
<literal><emphasis>channel</emphasis></literal> according to the rules set using <literal>InitSer</literal>, and store the
received byte in the variable <literal><emphasis>output</emphasis></literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'This program will read a byte from PORTB.2, and set the LED on if
	'the byte is more than 50. This can be used with the SerSend
	'example program.

	#chip 16F88, 8
	#config Osc = Int

	#define RecAHigh PORTB.2 ON
	#define RecALow PORTB.2 OFF
	#define LED PORTB.0

	Dir PORTB.0 Out
	Dir PORTB.2 In

	InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, normal
	Do
		SerReceive 1, Temp
		If Temp &lt;= 50 Then Set LED Off
		If Temp &gt; 50 Then Set LED On
	Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link>,
<link linkend="_initser">InitSer</link></simpara>
</section>
<section xml:id="_serprint">
<title>SerPrint</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  SerPrint <emphasis>channel, value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>SerPrint</literal> is used to send a value over the serial connection. <literal><emphasis>value</emphasis></literal> can
be a string, integer, long, word or byte.</simpara>
<simpara><literal><emphasis>channel</emphasis></literal> is the serial connection to send data through (1 | 2 |3 ).</simpara>
<simpara><literal>SerPrint</literal> will not send any new line characters. If the chip is sending
to a terminal, these commands should follow <literal>SerPrint</literal>.</simpara>
<screen>    SerSend channel, 13
    SerSend channel, 10</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will display any values received over the serial
    'connection. If "pot" is received, the value of the analog sensor
    'will be sent.

    'Chip settings
    #chip 18F2525, 8
    #config Osc = Int

    'LCD settings
    #define LCD_IO 4
    #define LCD_RS PORTC.7
    #define LCD_RW PORTC.6
    #define LCD_Enable PORTC.5
    #define LCD_DB4 PORTC.4
    #define LCD_DB5 PORTC.3
    #define LCD_DB6 PORTC.2
    #define LCD_DB7 PORTC.1

    'Serial settings
    #define RS232Out PORTB.0
    #define RS232In  PORTB.1

    'Set pin direction
    Dir RS232Out Out
    Dir RS232In In

    'Config Software-UART
    #define SendAHigh Set RS232Out ON
    #define SendALow Set RS232Out OFF
    #define RecAHigh Set RS232In ON
    #define RecALow Set RS232In OFF
    set RS232Out On

    Do
      'Potentiometer
      #define POT_PORT PORTA.0
      #define POT_AN AN0

      'Set pin direction
      Dir POT_PORT In

      'Create buffer variables to store received messages
      Dim Buffer As String
      Dim OldBuffer As String
      BufferSize = 0

      'Set up serial connection
      InitSer 1, r9600, 1 + WaitForStart, 8, 1, none, invert

      'Show test messages
      Print "Serial Tester"
      Wait 1 s
      SerPrint 1, "GCBASIC RS232 Test"
      SerSend 1, 13
      SerSend 1, 10
      Wait 1 s

      'Main loop
     'Get a byte from the terminal
      SerReceive 1, Temp

      'If Enter key was pressed, deal with buffer contents
      If Temp = 13 Then
        Buffer(0) = BufferSize

        'Try to execute commands in buffer
        If Not ExecCommand (Buffer) Then
          'Show message on bottom line, last message on top.
          CLS
          Print OldBuffer
          Locate 1, 0
          Print Buffer
          'Store the message for next time
          OldBuffer = Buffer
        End If

        BufferSize = 0
      End If
      'Backspace code, delete last character in buffer
      If Temp = 8 Then
        If BufferSize &gt; 0 Then BufferSize -= 1
      End If
      'Received ASCII code between 32 and 127, add to buffer
      If Temp &gt;= 32 And Temp &lt;= 127 Then
        BufferSize += 1
        Buffer(BufferSize) = Temp
      End If
    Loop

    'Takes a sensor reading and sends it to terminal
    Sub SendSensorReading
      SerPrint 1, "Sensor Reading: "
      SerPrint 1, ReadAD10(POT_AN)
      SerSend 1, 13
      SerSend 1, 10
    End Sub

    'Will check the buffer for a command
    'If command found, run it and return true
    'If not, return false
    Function ExecCommand (CmdIn As String)
      ExecCommand = False
      'If received command is "pot", show potentiometer value
      If CmdIn = "pot" Then
        SendSensorReading
        ExecCommand = True
      End If
    End Function</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_rs232_software_overview">RS232 Software Overview</link></simpara>
</section>
</section>
<section xml:id="_rs232_software_optimised">
<title>RS232 (software optimised)</title>
<simpara>This is the Software Serial Communications section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_software_overview_optimised">
<title>RS232 Software Overview - Optimised</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These routines allow the microcontroller to send and receive RS232 data.</simpara>
<simpara>SoftSerial is a library for the Creat Cow BASIC compiler and works on AVR and PIC microcontrollers.
These routines allow the microcontroller to send and receive RS232 data.
All functions are implemented using software, so no special hardware is required on the microcontroller.
SoftSerial uses ASM routines for minimal overhead.
If the microcontroller has a hardware serial module (usually referred to as UART or USART) the hardware routines can be used too.</simpara>
<simpara><emphasis role="strong">Features</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>3 independent channels Ser1&#8230;&#8203; , Ser2&#8230;&#8203; , Ser3&#8230;&#8203;</simpara>
</listitem>
<listitem>
<simpara>I/O pins user configurable</simpara>
</listitem>
<listitem>
<simpara>polarity can be inverted</simpara>
</listitem>
<listitem>
<simpara>freely adjustable baud rate</simpara>
</listitem>
<listitem>
<simpara>maximum baudrate depends on MCU speed</simpara>
<itemizedlist>
<listitem>
<simpara>PIC@ 1Mhz    9600 baud</simpara>
</listitem>
<listitem>
<simpara>PIC@ 4Mhz   38400 baud</simpara>
</listitem>
<listitem>
<simpara>PIC@ 8Mhz   64000 baud</simpara>
</listitem>
<listitem>
<simpara>PIC@16Mhz  128000 baud</simpara>
</listitem>
<listitem>
<simpara>AVR@ 1Mhz   28800 baud</simpara>
</listitem>
<listitem>
<simpara>AVR@ 8Mhz  115200 baud</simpara>
</listitem>
<listitem>
<simpara>AVR@16Mhz  460800 baud</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>5 - 8  data bits</simpara>
</listitem>
<listitem>
<simpara>1 or 2 stop bits</simpara>
</listitem>
<listitem>
<simpara>parity bit not supported</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the RS232 serial
communication routines. To set them, place a line in the main program
file that uses <literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Constant Name/s</entry>
<entry align="left" valign="top">Controls
Valid Values</entry>
<entry align="left" valign="top">Default value</entry>
<entry align="left" valign="top">SER1_TXPORT,
SER2_TXPORT,
SER3_TXPORT</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>These are used to define the port for sending on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only.
Sample:  #define SER1_TXPORT PortB</simpara></entry>
<entry align="left" valign="top"><simpara>PORTA - PORTx</simpara></entry>
<entry align="left" valign="top"><simpara>No Default
Must be defined for sending</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_TXPIN,
SER2_TXPIN,
SER3_TXPIN</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>These are used to define the pin (the corresponding bit) for sending on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_TXPIN 0</simpara></entry>
<entry align="left" valign="top"><simpara>0 - 7</simpara></entry>
<entry align="left" valign="top"><simpara>No Default
Must be defined
for sending</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_RXPORT,
SER2_RXPORT,
SER3_RXPORT</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>These are used to define the port for receiving on serial channels 1, 2 and 3 respectively. Note, that we also have to define a PortPin (see next line). It is not necessary to define this, if we want to receive only.
Sample:  #define SER1_RXPORT PortA</simpara></entry>
<entry align="left" valign="top"><simpara>PORTA - PORTx  No Default</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined
for receiving</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_RXPIN,
SER2_RXPIN,
SER3_RXPIN</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>These are used to define the pin (the corresponding bit) for receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only.
Sample:  #define SER1_RXPIN 5</simpara></entry>
<entry align="left" valign="top"><simpara>0 - 7</simpara></entry>
<entry align="left" valign="top"><simpara>No Default
Must be defined
for receiving</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_BAUD,
SER2_BAUD,
SER3_BAUD</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>These are used to define the baudrate for sending and receiving on serial channels 1, 2 and 3 respectively. It is not necessary to define this, if we want to send only.
Sample:  #define SER1_BAUD 19200</simpara></entry>
<entry align="left" valign="top"><simpara>75 - 512000</simpara></entry>
<entry align="left" valign="top"><simpara>No Default
Must be defined</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_DATABITS,
SER2_DATABITS,
SER3_DATABITS</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>These are used to define the databits for sending and receiving on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_DATABITS 7</simpara></entry>
<entry align="left" valign="top"><simpara>5 - 8</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default = 8</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_STOPBITS,
SER2_STOPBITS,
SER3_STOPBITS</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>These are used to define the stopbits for sending and receiving on serial channels 1, 2 and 3 respectively.
Sample:  #define SER1_STOPBITS 2</simpara></entry>
<entry align="left" valign="top"><simpara>1, 2</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default = 1</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_INVERT,
SER2_INVERT,
SER3_INVERT</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>These are used to define the polarity for sending and receiving on serial channels 1, 2 and 3 respectively. If it is "On", then high bits will be changed to low, and low to high. This is useful for connection to a PCs native serial port or USB-serial converters with  MAX232.
Sample:  #define SER1_INVERT On</simpara></entry>
<entry align="left" valign="top"><simpara>On, Off</simpara></entry>
<entry align="left" valign="top"><simpara>Optional
Default = Off</simpara></entry>
<entry align="left" valign="top"><simpara>SER1_RXNOWAIT,
SER2_RXNOWAIT,
SER3_RXNOWAIT</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_sernsend">
<title>SerNSend</title>
<simpara><emphasis role="strong">Ser1Send, Ser2Send, Ser3Send</emphasis></simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Ser1Send data
    Ser2Send data
    Ser3Send data</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by data using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will send one byte using PORTA.5

    ; ----- Configuration
    #chip 12F1501, 1

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART for sending:
    #define SER1_BAUD 9600     ; baudrate must be defined
    #define SER1_TXPORT PORTA  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 5       ; portbit  must be defined

    ; ----- Main body of program commences here.
    Ser1Send 88   'send one byte (88 = X)</screen>
<simpara>Exposed in SoftSerial.h authored by Frank Steinberg</simpara>
</section>
<section xml:id="_sernprint">
<title>SerNPrint</title>
<simpara><emphasis role="strong">Ser1Print, Ser2Print, Ser3Print</emphasis></simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Ser1Print value
    Ser2Print value
    Ser3Print value</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a value using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines.
value can be a string, integer, long, word or byte.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will send text and an icrementing value using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined

    ; ----- Variables
    Dim xx As Word
    xx = 1000

    ; ----- Main body of program commences here.
    Do Forever
      Wait 1 s       'time to enjoy the result
      Ser1Send  13   'new line in Terminal
      Ser1Send  10
      Ser1Print "Software-UART: "  'send a text
      Ser1Print xx   'send the value of xx
      xx += 1
    Loop</screen>
<simpara>Exposed in SoftSerial.h authored by Frank Steinberg</simpara>
</section>
<section xml:id="_sernreceive">
<title>SerNReceive</title>
<simpara><emphasis role="strong">Ser1Receive, Ser2Receive, Ser3Receive</emphasis></simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    bytevar = Ser1Receive
    bytevar = Ser2Receive
    bytevar = Ser3Receive</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function will read a byte using the channel referred to as Ser1.. , Ser2&#8230;&#8203; , Ser3&#8230;&#8203; according to the rules set by the related defines. The received byte is stored in the variable bytevar.
By default the function waits for the startbit impulse edge before executing the following commands. See the sample files how to realize timeout-functionality or interrupt-driven receiving.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will receive bytes on PORTB.0 and send back using PORTB.1

    ; ----- Configuration
    #chip 16F886, 16
    #option Explicit

    ; ----- Include library
    #include &lt;SoftSerial.h&gt;

    ; ----- Config Serial UART :
    #define SER1_BAUD 115200   ; baudrate must be defined
    #define SER1_DATABITS 7    ; databits optional (default = 8)
    #define SER1_STOPBITS 2    ; stopbits optional (default = 1)
    #define SER1_INVERT Off    ; inverted polarity optional (default = Off)
    ; Config I/O ports for transmitting:
    #define SER1_TXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_TXPIN 1       ; portbit  must be defined
    ; Config I/O ports for receiving:
    #define SER1_RXPORT PORTB  ; I/O port (without .bit) must be defined
    #define SER1_RXPIN 0       ; portbit  must be defined
    #define SER1_RXNOWAIT Off  ; don't wait for stopbit optional (default = Off)

    ; ----- Variables
    Dim RecByte As Byte

    ; ----- Main body of program commences here.
     Wait 1 Ms     'delay to prevent garbage if sending too quick after init
     Ser1Send 10   'new line in Terminal
     Ser1Send 13   '
     Ser1Print "Please send a byte!"

     Do Forever
      RecByte = Ser1Receive   'receive one byte - wait until detecting startbit
      Ser1Send  13            'new line in Terminal
      Ser1Send  10            '
      Ser1Print "You sent: "  'send a text
      Ser1Send RecByte        'send the sign representing the byte
     Loop</screen>
<simpara>Exposed in SoftSerial.h authored by Frank Steinberg</simpara>
</section>
</section>
<section xml:id="_rs232_hardware">
<title>RS232 (hardware)</title>
<simpara>This is the RS232 (hardware) section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_rs232_hardware_overview">
<title>RS232 Hardware Overview</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>Great Cow BASIC support programs to communicate easily using RS232.</simpara>
<simpara>Great Cow BASIC included microcontroller hardware-based serial routines are intended for use on microcontrollers with built in serial communications modules - normally referred to in datasheets as USART or UART modules.  Check the microcontroller data sheet for the defined transmit and receive (TX/Rx) pins.  Make sure your program sets the Tx pin direction to Out and the Rx pin direction to In respectively.  If the RS232 lines are connected elsewhere, or the microcontroller has no USART module, then the Great Cow BASIC software based RS232 routines must be used.</simpara>
<simpara>Initialization of the USART module is handled automatically from your program by defining the chip, speed, and the baudrate.  The baudrate generator values are calculated and set,  usart is set to asynchronous, usart is enabled , the receive and transmit  are enabled. See the table below.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  #chip mega328p, 16
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?>
Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara>The following table explains the methods that can be implemented when using the Great Cow BASIC serial routines.</simpara>
<simpara><emphasis role="strong">Commands:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Parameters</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Example</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Serially print numbers (byte, word, long) or  strings.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerPrint</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number_constant or number_variable or string [,optional usart address]
</simpara><simpara>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine prints a variable value to usart 1. No additional parameter for the usart number is used.
</simpara><simpara><literal>HSerprint</literal> ( mynum )
</simpara><simpara>To print a variable value to usart 2. Note the additional parameter for the usart address.
</simpara><simpara><literal>HSerprint</literal> ( mynum, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially receive ascii number characters and assign to a word variable</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerGetNum</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number_variable [,optional usart address]
</simpara><simpara>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine ensures that the characters received are numbers.  When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. Defaults to usart1.
</simpara><simpara>To receive number characters use.
</simpara><simpara><literal>HSerGetNum</literal> ( mynum   )
</simpara><simpara>To receive number characters via usart2 use.
</simpara><simpara><literal>HSerGetNum</literal> ( mynum, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially receive characters as a string.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerGetString</literal></simpara></entry>
<entry align="left" valign="top"><simpara>User_string_variable [,optional usart address]
</simpara><simpara>The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine ensures that the characters treated as a string.  When a carriage return (CR or ASCII code 13) is received this signifies the end of the character stream. Great Cow BASIC will determine the default buffering size for strings. See here for more help on string sizes. Defaults to usart1.
</simpara><simpara>To receive a string use.<?asciidoc-br?>
<literal>HserGetString</literal> ( mystring )
</simpara><simpara>To a string via usart2 use.<?asciidoc-br?>
<literal>HserGetString</literal> ( mystring, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially receive a character using a subroutine.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceive</literal></simpara></entry>
<entry align="left" valign="top"><simpara>byte_variable</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine handles the incoming characters as raw ASCII values.
</simpara><simpara>The subroutine receives a single byte value in the range of 0 to 255.
</simpara><simpara>The subroutine can receive a byte from usart 1, 2, 3 or 4.
</simpara><simpara>The public variable comport  can be set before the use of this method to select the desired usart address.
</simpara><simpara>If ‘#define USART_BLOCKING’ is defined then this methods will wait until it a byte is received.
</simpara><simpara>If ‘#define USART_BLOCKING’ is NOT defined then the method will returns ASCII value received or the method will return the value of 255 to indicate not ASCII data was received.  You can change the value returned by setting redefining ‘#define DefaultUsartReturnValue = [0-255]’.  When ‘#define USART_BLOCKING’ is NOT defined  this method becomes a non- blocking method which allows for the testing and handling of incoming ASCII data within the user program.
</simpara><simpara>To receive an ASCII byte value in blocking mode use. Defaults to usart1
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
<literal>HSerReceive</literal> (user_byte_variable)
</simpara><simpara>To receive an ASCII byte value via usart 3 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
Comport = 3<?asciidoc-br?>
<literal>HSerReceive</literal> ( user_byte_variable)
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined. This method fefaults to usart1
</simpara><simpara><literal>HSerReceive</literal> (user_byte_variable)
</simpara><simpara>To receive an ASCII byte value via usart 4 using non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>Comport = 4<?asciidoc-br?>
<literal>HSerReceive</literal> ( user_byte_variable )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially receive a character using a function specifically via usart1.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceive1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>none</simpara></entry>
<entry align="left" valign="top"><simpara>This function handles the incoming characters as raw ASCII values.
</simpara><simpara>The function receives a single byte value in the range of 0 to 255.
</simpara><simpara>The function can return only a byte value from usart 1.
</simpara><simpara>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</simpara><simpara>To receive an ASCII byte value via usart 1 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
user_number_variable = <literal>HSerReceive1</literal>
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>user_number_variable = <literal>HSerReceive1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially receive a character using a function specifically via usart2</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceive2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>none</simpara></entry>
<entry align="left" valign="top"><simpara>This function handles the incoming characters as raw ASCII values.
</simpara><simpara>The function receives a single byte value in the range of 0 to 255.
</simpara><simpara>The function can receive only a byte value from usart 2.
</simpara><simpara>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</simpara><simpara>To receive an ASCII byte value via usart 2 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
user_byte_variable = <literal>HSerReceive2</literal>
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>user_byte_variable = <literal>HSerReceive2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially receive a character using a function from either usart ports using a parameter to select the usart.</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerReceiveFrom</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Usart_number,<?asciidoc-br?>
 Default is 1</simpara></entry>
<entry align="left" valign="top"><simpara>This function handles the incoming characters as raw ASCII values.
</simpara><simpara>The function return a single byte value in the range of 0 to 255.
</simpara><simpara>The function can receive only a byte value from usart 1 and usart 2
</simpara><simpara>The blocking and non-blocking mode and the methods are the same as shown in the previous method.
</simpara><simpara>To receive an ASCII byte value via usart 1 using blocking mode use
</simpara><simpara>#define USART_BLOCKING<?asciidoc-br?>
…<?asciidoc-br?>
…<?asciidoc-br?>
user_byte_variable = <literal>HSerReceiveFrom</literal>
</simpara><simpara>To receive an ASCII byte value use in non-blocking mode use. Ensure #define USART_BLOCKING is NOT defined.
</simpara><simpara>'Chosen_usart = 2<?asciidoc-br?>
user_byte_variable = <literal>HSerReceiveFrom</literal> (2)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially send a byte using any of the usart ports</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerSend</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte or byte_variable   [,optional usart address]  + The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine sends a byte value to usart 1. No additional parameter for the usart number is used.
</simpara><simpara><literal>HSerSend</literal>( user_byte )
</simpara><simpara>To print a variable value to usart 2. Note the additional parameter for the usart address.
</simpara><simpara><literal>HSerSend</literal> ( user_byte, 2 )</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially send a byte and a CR&amp;LF using any of the usart ports</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerPrintByteCRLF</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Byte or byte_variable +  [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine sends a byte value to usart 1.
</simpara><simpara><literal>HserPrintCRLF</literal> users_byte,2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Serially send  CR&amp;LF (can be multiple) using any of the usart ports</simpara></entry>
<entry align="left" valign="top"></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HSerPrintCRLF</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number of CR&amp;LF to be sent + [,optional usart address] The optional usart address is microcontroller specific buy can be 1, 2, 3 or 4.</simpara></entry>
<entry align="left" valign="top"><simpara>This subroutine sends a CR&amp;LF to port 2.
</simpara><simpara></simpara><simpara><literal>HserPrintCRLF</literal> 1,2    ' Will send a CR &amp; LF out of comport 2 to the terminal</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Constants</emphasis>
These constants affect the operation of the hardware RS232 routines:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>USART_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART2_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART2_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART2_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART3_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART3_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART3_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART4_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Baud rate (in bps) for the routines to operate at.</simpara></entry>
<entry align="left" valign="top"><simpara>No default, user must enter a baud. Doesn&#8217;t have to be a standard baud.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART4_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the USART routines to wait until data
can be sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART4_TX_BLOCKING</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If defined, this constant will cause the Transmit USART routines to wait until Transmit register is empty before writing the next byte which prevents over running the register and losing data.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. Use “#defining” it implement the action.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>USART_DELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is the delay between characters.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>1 ms</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SerPrintCR</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Causes a Carriage return to be sent after every HserPrint automatically.</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. User “#defining” it implements the action</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SerPrintLF</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Causes a LineFeed to be sent after every HserPrint. Some communications require both CR and LF</simpara></entry>
<entry align="left" valign="top"><simpara>No parameter needed. User “#defining” it implements the action</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_hsergetnum">
<title>HSerGetNum</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <literal>HSerGetNum</literal> <emphasis>myNum</emphasis>    ‘Gets a multi digit number  from USART 1
  <literal>HSerGetNum</literal> <emphasis>myNum</emphasis>,1  ‘Get a multi digit number from USART 1
  <literal>HSerGetNum</literal> <emphasis>myNum</emphasis>,2  ‘Get a multi digit number from USART 2</screen>
<literallayout class="monospaced">When the variable type is a word the number range is 0 to 65535
When the variable type is a long the number range is 0 to 99999</literallayout>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a multi digit number received as ascii chars followed by a CR from an external serial source using a  hardware serial module.  The command checks that only numbers are input disregarding other characters while waiting for the ending &lt;CR&gt;.  It can be used only as a subroutine.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program receives a number and CR from a PC terminal and sends it back on both usarts
  #chip 18f26k22, 16

  'Set the pin directions
  #define USART_BAUD_RATE 9600
  #define USART_BLOCKING
  #define USART2_BAUD_RATE 9600
  #define USART2_BLOCKING

  'Init pins
  #define SerInPort PORTc.7    'usart1 in
  #define SerOutPort PORTc.6    'usart2 out
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In
    Dir PORTB.6 Out            'USART2 out
    Dir PORTB.7 In            'USArt2 in
    Dir PORTB.0 Out            'leds for testing
    Dir PORTB.1 Out            'leds for testing
    Wait 100 Ms

  'Variables
  Dim myNum as Word
  'Main body of program commences here.
  'Message after reset
  HSerPrint "18F26k22"
  HSerPrintCRLF

  'Main routine
  Do forever
    'wait for char from UART
    'HSerReceive InChar
    HSerGetNum myNum,2    'from usart 2
    HSerPrint myNum,1            ' send out usart 1
    HSerPrint myNum,2        'send out usart 2
    HSerPrintCRLF 1,2        'send one CRLF out usart 2
    HserPrintCRLF 1,1        ‘send one CRLF out usart 1
  loop</screen>
<simpara><emphasis role="strong">Example:</emphasis>
This program receives number on serial port 1 and displays.  This example shows using a Long as the input variable.</simpara>
<simpara>Therefore, the result is in the range of 0-99999.  The example also shows how to detect a buffer overrun by testing the HSerInByte variable.</simpara>
<screen>    #chip mega328p, 16

    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    Dim myNum as Long  ' range 0 to 99999
    HSerPrint "Restarted"
    HSerPrintCRLF

    Do
      HSerGetNum myNum
      HSerPrint myNum

      if HSerInByte &lt;&gt; 13 then
          HSerSend 9
          HSerPrint "Error buffer overrun"  'You should handle error appropiately
      End if
      HSerPrintCRLF
    loop
    End</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserreceive">HSerReceive</link> and <link linkend="_hsergetstring">HSerGetString</link></simpara>
</section>
<section xml:id="_hsergetstring">
<title>HSerGetString</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HSerGetString <emphasis>myString</emphasis>      ‘Get a multi char string  from USART 1
    HSerGetString <emphasis>myString</emphasis>,1    ‘Get a multi char string  from USART 1
    HSerGetString <emphasis>myString</emphasis>,2    ‘Get a multi char string  from USART 2</screen>
<literallayout class="monospaced">Variable type is string and the  routine checks for numbers,letters, and puctuation.</literallayout>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a multi character string received as ascii input to the hardware serial module followed by a CR from an external serial source. It can be used only as a subroutine. Variable type is string and the  routine checks for numbers,letters, and puctuation.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'This program receives char string and CR from a PC terminal, sends back the string on the serial port, and turns Led’s on off by command

	#chip 18f26k22, 16

	'Set the pin directions
	#define USART_BAUD_RATE 9600
	#define USART_BLOCKING
	#define USART2_BAUD_RATE 9600
	#define USART2_BLOCKING

	'InitUSART
	#define SerInPort PORTc.7    'USART 1 Rx Pin
	#define SerOutPort PORTc.6    'USART 1 Tx Pin


	'Set pin directions
	Dir SerOutPort Out
	Dir SerInPort In

	Dir PORTB.6 Out        'second USART Tx Pin
	Dir PORTB.7 In        'second USART Rx Pin

	Dir PORTB.0 Out        ' LED hooked up for testing
	Dir PORTB.1 Out        ' LED hooked up for testing

	Wait 100 Ms

	; ----- Variables
	' All byte variables are defined upon use.
	Dim myNum as Word
	Dim MyString as String

	; ----- Main body of program commences here.
	'Message after reset
	HSerPrint "18F26k22"
	HSerPrintCRLF

	'Main routine

	Do Forever

		HSerGetString MyString
		HSerPrint MyString
		HSerSend(13)
		 If MyString = "LED1 ON" Then
			 Set PORTB.0 Off
		 End If
		 If MyString = "LED1 OFF" Then
			 Set PORTB.0 On
		 End If
		 If MyString = "LED2 ON" Then
			 Set PORTB.1 Off
		 End If
		 If MyString = "LED2 OFF" Then
			 Set PORTB.1 On
		 End If

	Loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserreceive">HSerReceive</link> and <link linkend="_hsergetnum">HSerGetNum</link></simpara>
</section>
<section xml:id="_hserprint">
<title>HSerPrint</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HSerPrint <emphasis>user_value</emphasis> [,1|2|3|4]  'Choose comport with optional parameter
                                       'Default comport is 11</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>HSerPrint</literal> is used to send a value over the serial connection. <literal><emphasis>user_value</emphasis></literal>
can be a string, integer, long, word or byte. <literal>HSerPrint</literal> is very similar
to <literal>Print</literal>. The data will be sent out the hardware serial module.</simpara>
<simpara><literal>HSerPrint</literal> will not send any new line characters. If the chip is sending
to a terminal, these commands should follow every <literal>HSerPrint</literal> :</simpara>
<screen>  HSerPrint 13
  HSerPrint 10</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  'This program will display any values received over the serial
  'connection. If "pot" is received, the value of the analog sensor
  'will be sent.
  'Note: This has been adapted from the SerPrint example.

  'Chip settings
  #chip 18F2525, 8
  #config Osc = Int

  'LCD settings
  #define LCD_IO 4
  #define LCD_RS PORTC.7
  #define LCD_RW PORTC.6
  #define LCD_Enable PORTC.5
  #define LCD_DB4 PORTC.4
  #define LCD_DB5 PORTC.3
  #define LCD_DB6 PORTC.2
  #define LCD_DB7 PORTC.1

  'USART settings
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  'Potentiometer
  #define POT_PORT PORTA.0
  #define POT_AN AN0

  'Set pin directions
  Dir POT_PORT In

  'Create buffer variables to store received messages
  Dim Buffer As String
  Dim OldBuffer As String
  BufferSize = 0

  'Show test messages
  Print "Serial Tester"
  Wait 1 s
  HSerPrint "GCBASIC RS232 Test"
  HSerSend 13
  HSerSend 10
  Wait 1 s

  'Main loop
  Do
    'Get a byte from the terminal
    HSerReceive Temp

    'If Enter key was pressed, deal with buffer contents
    If Temp = 13 Then
      Buffer(0) = BufferSize

      'Try to execute commands in buffer
      If Not ExecCommand (Buffer) Then
        'Show message on bottom line, last message on top.
        CLS
        Print OldBuffer
        Locate 1, 0
        Print Buffer
        'Store the message for next time
        OldBuffer = Buffer
      End If

      BufferSize = 0
    End If
    'Backspace code, delete last character in buffer
    If Temp = 8 Then
      If BufferSize &gt; 0 Then BufferSize -= 1
    End If
    'Received ASCII code between 32 and 127, add to buffer
    If Temp &gt;= 32 And Temp &lt;= 127 Then
      BufferSize += 1
      Buffer(BufferSize) = Temp
    End If
  Loop

  'Takes a sensor reading and sends it to terminal
  Sub SendSensorReading
    HSerPrint "Sensor Reading: "
    HSerPrint ReadAD10(POT_AN)
    HSerSend 13
    HSerSend 10
  End Sub

  'Will check the buffer for a command
  'If command found, run it and return true
  'If not, return false
  Function ExecCommand (CmdIn As String)
    ExecCommand = False
    'If received command is "pot", show potentiometer value
    If CmdIn = "pot" Then
      SendSensorReading
      ExecCommand = True
    End If
  End Function</screen>
<simpara><emphasis role="strong">For more help, see also</emphasis>
<link linkend="_hserprintbytecrlf">HserPrintByteCRLF</link>
<emphasis role="strong">and</emphasis> <link linkend="_hserprintcrlf">HserPrintCRLF</link></simpara>
</section>
<section xml:id="_hserreceive">
<title>HSerReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara><emphasis role="strong"><emphasis>Used as subroutine:</emphasis></emphasis></simpara>
<screen>    HSerReceive (<emphasis>user_byte_variable</emphasis>)</screen>
<simpara>or, if other multiple comports are in use, set the comport before using HSerReceive.</simpara>
<screen>    comport = 1   '(1|2|3|4)Not needed unless using multiple comports in use
    HSerReceive (_user_byte_variable_)</screen>
<simpara><emphasis role="strong"><emphasis>Used as function:</emphasis></emphasis></simpara>
<screen>	<emphasis>user_byte_variable</emphasis> = <literal>HSerReceive</literal>	'Supports only USART1
	<emphasis>user_byte_variable</emphasis> = <literal>HSerReceive1</literal>	'Supports only USART1
	<emphasis>user_byte_variable</emphasis> = <literal>HSerReceive2</literal>	'Supports only USART2</screen>
<simpara>For other comports use Function <literal>HSerReceiveFrom</literal></simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.</simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a byte from the hardware RS232 module. It can be
used either as a subroutine or as a function. If used as a subroutine, a
variable must be supplied to store the received value in. If used as a
function, it will return the received value.</simpara>
<simpara>The subroutine HSerReceive can get a byte from any comport but must set the comport number immediately before the call.  If ”#define USART_BLOCKING” is defined then the HserReceive waits in a loop until it receives a byte.   If” #define USART_BLOCKING” is NOT defined then HserReceive returns the new byte that was received OR returns 255 because of “DefaultUsartReturnValue = 255”  was defined.  This is good because it don’t hold up your program from executing other  commands and your can check it for new data priodically.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'This program will read a value from the USART, and send it to PORTB.

	#chip 16F877A, 20

	'USART settings
	#define USART_BAUD_RATE 9600	'sets up comport 1 for 9600 baud

	'Set PORTB to output
	Dir PORTB Out
	'Set USART receive pin to input
	Dir PORTC.7 In

	'Main loop
	Do
		'Get serial data and output value to PortB as 8 bit binary
		HSerReceive(InChar)	 'Receive data as Subroutine from comport 1
		'InChar = HSerReceive	 'Could also be written as Function
		If InChar &lt;&gt; 255 Then   'If value is 255 then it is old data
			PortB = InChar		'If new data then it goes to PortB
		End If
	Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>	'If you choose no “Blocking” and comment both of them out.
	'USART settings
	#define USART_BAUD_RATE 9600
	'#define USART_BLOCKING        ' just none OR one of the blocking
	'#define USART_TX_BLOCKING    ' statements should be defined

	'Main loop
	Do
		'Get and display value
		'If there is no new data, HSerReceive will return default value.
		comport = 1
		HSerReceive tempvalue
		If tempvalue &lt;&gt; 255    Then    ‘ don’t change PortB if it is default
			PortB = tempvalue
		End If

	Loop</screen>
<simpara><emphasis role="strong">Example 3:</emphasis></simpara>
<screen>	'If you choose no “Blocking” and comment both of them out.
	#chip mega328p, 16

	#define USART_BAUD_RATE 9600
	'#define USART_BLOCKING
	'#define USART_TX_BLOCKING

	'Don't forget to Set usart pin directions
	Dir PortD.1 Out    'com1   USART0
	Dir PortD.0 In

	Wait 1 s

	'Message after reset
	HSerPrint "ATmega328P  com test"
	HSerPrintCRLF

	'Main routine  hook up FTDI232 usb to serial and use terminal program to check
	Start:
		comport = 1
		HSerReceive(InChar)    'Subroutine needs the comport set
		'InChar = HSerReceive    ' This function will get from comport 1
			If InChar &lt;&gt; 255 Then    ' check if for received byte
									'return 255 if old data
				HSerSend InChar    'send back char to UART
			End If
	Goto Start</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_rs232_hardware_overview">RS232 Hardware Overview</link></simpara>
</section>
<section xml:id="_hserreceivefrom">
<title>HSerReceiveFrom</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	<emphasis>user_byte</emphasis> = HSerReceiveFrom [,1 | 2 | 3 | 4]
	<emphasis>user_byte</emphasis> = HSerReceiveFrom         'Defaults to USART1

	'other Receive functions
	<emphasis>user_byte</emphasis> = HSerReceive1		'from USART1
	<emphasis>user_byte</emphasis> = HSerReceive2		'from USART2</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will read a byte from the hardware RS232 module. It can be only be used as a function. It will return the received value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'This program will read a value from the USART, and display it on PORTB.

	#chip 16F877A, 20

	'USART settings
	#define USART_BAUD_RATE 9600
	#define USART_BLOCKING
	#define USART_TX_BLOCKING


	'Set PORTB to input
	Dir PORTB Out
	'Set USART receive pin to input
	Dir PORTC.7 In

	'Main loop
	Do
		'Get byte value
		bytein = HSerReceiveFrom (2)
		'do something useful
	Loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserreceive">HSerReceive</link></simpara>
</section>
<section xml:id="_hsersend">
<title>HSerSend</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HSerSend <emphasis>user_byte</emphasis> [,1|2|3|4] 	'Choose comport with optional parameter
	                                    'Default comport is 1</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.</simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by <emphasis>user_byte</emphasis> using the hardware RS232
module.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'This program will send the status of PORTB through the hardware
	'serial module.

	#chip 16F877A, 20

	'USART settings
	#define USART_BAUD_RATE 9600	'Initializes USART port with 9600 baud
	'#define USART_BLOCKING		' Both of these blocking statements will
	#define USART_TX_BLOCKING	' wait for tx register to be empty
								' use only one of the two
	'Set PORTB to input
	Dir PORTB In
	'Set USART transmit pin to output
	Dir PORTC.6 Out

	'Main loop
	Do
		'Send PORTB value through USART
		HSerSend PORTB
		HSerSend(13)		' sends a CR
		'Short delay for receiver to process message
		Wait 10 ms			'probably not necessary with blocking statement
	Loop</screen>
</section>
<section xml:id="_hserprintbytecrlf">
<title>HserPrintByteCRLF</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	<literal>HserPrintByteCRLF</literal>  <emphasis>user_data</emphasis> [, 1 | 2  | 3 | 4 ]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.</simpara>
<simpara>Microchip PIC supports USART1 and 2.<?asciidoc-br?>
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send a byte given by <emphasis>user_data</emphasis> using the hardware USART
module and then send the ASCII codes 13 and 10. ASCII codes 13 and 10
equate to a carriage return and line feed.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'This program will send the status of PORTB through the hardware serial module.

	HserPrintByteCRLF 65    ' Will print a single A on the terminal
	HserPrintByteCRL  "A"   'Will print a single A on the terminal</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserprintcrlf">HserPrintCRLF</link></simpara>
</section>
<section xml:id="_hserprintcrlf">
<title>HserPrintCRLF</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HserPrintCRLF [optional BYTE] [, 1 | 2  | 3 | 4 ]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a USART or UART module.<?asciidoc-br?></simpara>
<simpara>Microchip PIC supports USART1 and 2.+
Atmel AVR supports USART 1,2,3 and 4.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will send ASCII codes 13 and 10 only using the hardware
RS232 module. ASCII codes 13 and 10 equate to a carriage return and line
feed.</simpara>
<simpara>Optionally, you can add a parameter. The number will determine the
number of ASCII codes 13 and 10 set to the hardware RS232 module.</simpara>
<simpara>Also you can choose the comport with second optional parameter if it is not the default comport 1. If there is no first optional parameter then you must have atleast acomma before it  to indicate this is the second parameter.</simpara>
<simpara><emphasis role="strong">Examples:</emphasis></simpara>
<screen>	'This Line will send 1  CR and LF
	HserPrintCRLF    ' Will send a CR &amp; LF to the terminal

	'This Line will send 2  times (CR and LF)
	HserPrintCRLF 2    ' Will send 2 times (CR &amp; LF) to the terminal
						'out of comport 1

	'This Line will send 1  CR and LF
	HserPrintCRLF 1,2    ' Will send a CR &amp; LF out of
						'comport 2 to the terminal</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_hserprintbytecrlf">HserPrintByteCRLF</link></simpara>
</section>
</section>
</section>
<section xml:id="_ps_2">
<title>PS/2</title>
<simpara>This is the PS/2 section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_ps_2_overview">
<title>PS/2 Overview</title>
<simpara><emphasis role="strong">PS2 Overview</emphasis></simpara>
<simpara>These routines make it easier to communicate with a PS/2 device,
particularly an external keyboard.</simpara>
<simpara><emphasis role="strong">Relevant Constants</emphasis></simpara>
<simpara>These constants affect the operation of the PS/2 routines:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>PS2Data</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin connected to PS/2 data line</simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PS2Clock</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin connected to PS/2 clock line.</simpara></entry>
<entry align="left" valign="top"><simpara>Must be specified</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PS2_DELAY</literal></simpara></entry>
<entry align="left" valign="top"><simpara>This constant can be set to a delay, such as 10 ms. If set, a delay will
be added at the end of every byte sent or received.</simpara></entry>
<entry align="left" valign="top"><simpara>Not set</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Connections between the Keyboard and the Microcontroller</emphasis>
The following diagram show a typical connection between the keyboard and the microcontroller.  The value of R1 and R2 is typically 4.7k for a 5v system.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/overview_ps21.PNG" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="_inkey">
<title>InKey</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    output = InKey</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>InKey</literal> function will read the last pressed key from a PS/2 keyboard,
and return an ASCII value corresponding to the key. If no key is
pressed, then <literal>InKey</literal> will return 0.</simpara>
<simpara>It will also monitor Caps Lock, Num Lock and Scroll Lock keys, and
update the status LEDs as appropriate.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'A program to accept messages from a standard PS/2 keyboard
	'Any keys pressed will be shown on an LCD screen.

	'Hardware settings
	#chip 18F4620, 20

	'LCD connection settings
	#define LCD_IO 4
	#define LCD_DB4 PORTD.4
	#define LCD_DB5 PORTD.5
	#define LCD_DB6 PORTD.6
	#define LCD_DB7 PORTD.7
	#define LCD_RS PORTD.0
	#define LCD_RW PORTD.1
	#define LCD_Enable PORTD.2

	'PS/2 connection settings
	#define PS2Clock PORTC.1
	#define PS2Data PORTC.0
	#define PS2_DELAY 10 ms

	'Set up key log
	Dim KeyLog(32)
	DataCount = 0
	KeyLog(1) = 32

	Main:
		'Read the last pressed key
		KeyIn = INKEY
		'If no key pressed, try reading again
		If KeyIn = 0 Then Goto Main

		'Escape pressed - clear message
		If KeyIn = 27 Then
			DataCount = 0
			For DataPos = 1 to 32
				KeyLog(DataPos) = 32
			Next
			Goto DisplayData
		End If

		'Backspace pressed - delete last character
		If KeyIn = 8 Then
			If DataCount = 0 Then Goto Main
			KeyLog(DataCount) = 32
			DataCount = DataCount - 1
			Goto DisplayData
		End If

		'Otherwise, add the character to the buffer
		If KeyIn &gt;= 31 And KeyIn &lt;= 127 Then
			DataCount = DataCount + 1
			KeyLog(DataCount) = KeyIn
		End If

	DisplayData:
		'Display key buffer
		'LCDWriteChar is used instead of Print for greater control
		CLS
		For DataPos = 1 to DataCount
			If DataPos = 17 then Locate 1, 0
			LCDWriteChar KeyLog(DataPos)
		Next

	Goto Main</screen>
</section>
<section xml:id="_ps2setkbleds">
<title>PS2SetKBLeds</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PS2SetKBLeds (<emphasis>LedStatus</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This routine will turn the status LEDs on a keyboard on or off.
<literal><emphasis>LedStatus</emphasis></literal> is a variable, of which the lower 3 bits correspond to the 3
LEDs. Bit 0 is for Scroll Lock, bit 1 controls Num Lock and bit 2
controls Caps Lock.</simpara>
<simpara>Note that this routine does not alter the status variables within the
INKEY routine - so even if the Caps Lock LED is turned on, Caps Lock
will stay off.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	'A spinning LED program for a keyboard
	'Will flash Num Lock, then Caps Lock, then Scroll Lock.

	'Hardware settings
	#chip 16F88, 8

	#define PS2Clock PORTB.2
	#define PS2Data PORTB.3
	#define PS2_DELAY 10 ms

	'Main Loop
	Do

		'Turn on only Num Lock (bit 1)
		PS2SetKBLeds b'00000010'
		Wait 250 ms

		'Turn on only Caps Lock (bit 2)
		PS2SetKBLeds b'00000100'
		Wait 250 ms

		'Turn on only Scroll Lock (bit 0)
		PS2SetKBLeds b'00000001'
		Wait 250 ms

	Loop</screen>
</section>
<section xml:id="_ps2readbyte">
<title>PS2ReadByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    output = PS2ReadByte</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>PS2ReadByte</literal> will read a byte from the PS/2 bus. It will return the byte,
or 0 if no data was returned by the PS/2 device.</simpara>
<simpara>The PS/2 bus will normally be held in the inhibit state. <literal>PS2ReadByte</literal>
will uninhibit the bus for 25 ms. If a response is received, it will be
read. Then, the bus will be placed back in the inhibit state.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>For an example, please refer to the <literal>InKey</literal> function.
<link linkend="_inkey">PS2 Inkey</link></simpara>
</section>
<section xml:id="_ps2writebyte">
<title>PS2WriteByte</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PS2WriteByte <emphasis>user_data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>PS2WriteByte</literal> will send a byte to a PS/2 device. Once the byte has been
written, the PS/2 bus will be placed in the inhibit state.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>For an example, please refer to the <literal>PS2SetKBLeds</literal> function.<?asciidoc-br?>
<link linkend="_ps2setkbleds">PS2 Set Keyboard Leds</link></simpara>
</section>
</section>
<section xml:id="_spi">
<title>SPI</title>
<simpara>This is the Serial Peripheral Interface section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_spi_overview">
<title>SPI Overview</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<simpara>The SPI interface allows for the transmission and receiption of data simultaneously on two lines (MOSI and MISO).</simpara>
<simpara>The Clock polarity (CPOL) and clock phase (CPHA) are the main parameters that define a clock format to be used by the SPI bus. Depending on CPOL parameter, SPI clock may be inverted or non-inverted. CPHA parameter is used to shift the sampling phase. If CPHA=0 the data are sampled on the leading (first) clock edge. If CPHA=1 the data are sampled on the trailing (second) clock edge, regardless of whether that clock edge is rising or falling.</simpara>
<simpara>CPOL=0, CPHA=0</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-0-cpha-0.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The data must be available before the first clock signal rising.  The clock idle state is zero.  The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock&#8217;s low-to-high transition and propagated on high-to-low clock transition.</simpara>
<simpara>CPOL=0, CPHA=1</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-0-cpha-1.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The first clock signal rising can be used to prepare the data. The clock idle state is zero. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock&#8217;s high-to-low transition and propagated on low-to-high clock transition.</simpara>
<simpara>CPOL=1, CPHA=0</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-1-cpha-0.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The data must be available before the first clock signal falling. The clock idle state is one. The data on MISO and MOSI lines must be stable while the clock is low and can be changed when the clock is high. The data is captured on the clock&#8217;s high-to-low transition and propagated on low-to-high clock transition.</simpara>
<simpara>CPOL=1, CPHA=1</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spi-cpol-1-cpha-1.png" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The first clock signal falling can be used to prepare the data. The clock idle state is one. The data on MISO and MOSI lines must be stable while the clock is high and can be changed when the clock is low. The data is captured on the clock&#8217;s low-to-high transition and propagated on high-to-low clock transition.</simpara>
<simpara><emphasis role="strong">Key Commands</emphasis></simpara>
<screen>    SPIMode  ( _Mode_ [, SPIClockMode])

    SPITransfer (  _OutByte_, _InByte_ )

    FastHWSPITransfer( _OutByte_ )</screen>
<simpara>The Great Cow BASIC used the microcontrollers hardware module for SPI.  The example below shows an implementation of Hardware and Software SPI.  Software SPI allows for a greater choice of ports to be used to control the SPI operations.</simpara>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<simpara>This example demonstrates the SPI capabilities for the mega328p.  The process is similar of any microcontroller..</simpara>
<simpara>This example show using the hardware SPI option and a sofware SPI option.</simpara>
<simpara>Using hardware SPI mode - make sure the <literal>#define SPI_HardwareSPI</literal> is not commented out.
Using software SPI mode - comment out <literal>#define SPI_HardwareSPI</literal>. The example code will then use software SPI.</simpara>
<simpara>Usage</simpara>
<literallayout class="monospaced">Hardware SPI mode the Data Out, Data In and Clock (DO/DI and SCK) cannot be moved but the optional Data Command, Chip Select and Reset are all moveable.
Software SPI mode the Data Out, Data In and Clock (DO/DI and SCK), Data Command, Chip Select and Reset are all moveable.</literallayout>
<simpara>Code overview</simpara>
<literallayout class="monospaced">InitSPIMode calls SPIMode if needed, when hardware mode, and set the lines.
The sub SendByteviaSPI is called to handle whether to call the Hardware or use Software (bit-banging) SPI.</literallayout>
<screen>        #chip mega328p, 16
        #option explicit
        #include &lt;UNO_mega328p.h &gt;

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out

        DIM byte1 As byte
        DIM byte2 As byte
        DIM byte3 As byte

        byte1 = 100 ' temp values (will come from potentiometer later)
        byte2 = 150
        byte3 = 200

        InitSPIMode


        do forever
            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte1)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte2)
            set SPI_CS ON;
            set SPI_DC ON

            set SPI_CS OFF;
            set SPI_DC OFF;
            SendByteviaSPI (byte3)
            set SPI_CS ON;
            set SPI_DC ON

            wait 10 ms
        loop



    sub InitSPIMode

          #ifdef SPI_HardwareSPI
              SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )
          #endif

          set SPI_DO OFF;
          set SPI_CS ON;   therefore CPOL=0
          set SPI_DC ON;   deselect

    End sub

    sub  SendByteviaSPI( in SPISendByte as byte )

      set SPI_CS OFF
      set SPI_DC OFF;

      #ifdef SPI_HardwareSPI
         FastHWSPITransfer  SPISendByte
         set SPI_CS ON;
         exit sub
      #endif

      #ifndef SPI_HardwareSPI
      repeat 8

        if SPISendByte.7 = ON  then
          set SPI_DO ON;
        else
          set SPI_DO OFF;
        end if
        SET SPI_SCK On;           ; therefore CPOL=0 ==ON, and, where CPOL=1==ON
        rotate SPISendByte left
        set SPI_SCK Off;          ; therefore CPOL=0  =OFF, and, where CPOL=1==OFF

      end repeat
      set SPI_CS ON;
      set SPI_DO OFF;
      #endif

    end Sub</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spimode">SPIMode</link>,<link linkend="_spitransfer">SPITransfer</link>,<link linkend="_fasthwspitransfer">FastHWSPITransfer</link></simpara>
</section>
<section xml:id="_spimode">
<title>SPIMode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SPIMode ( <emphasis>Mode</emphasis> [, SPIClockMode])</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with Hardware SPI modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><emphasis>Mode</emphasis> sets the mode of the SPI module within the microcontroller. These are
the possible SPI Modes:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Mode Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>MasterSlow</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master mode, SPI clock is 1/64 of the frequency of the microcontroller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Master</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master mode, SPI clock is 1/16 of the frequency of the microcontroller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>MasterFast</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Master mode, SPI clock is 1/4 of the frequency of the microcontroller.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Slave mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SlaveSS</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Slave mode, with the Slave Select pin enabled.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis>SPIClockMode</emphasis> is an optional parameter to set the mode of the SPI clock mode. This optional parameter sets both the clock polarity and clock edge.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">SPIClockMode</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 0 &amp; SPI_CPHA = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 0 &amp; SPI_CPHA = 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 1 &amp; SPI_CPHA = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>SPI_CPOL = 1 &amp; SPI_CPHA = 1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>You can alternatively use constants to set the SPIClockMode as follows:</simpara>
<screen>    SPIMode ( MasterFast, SPI_CPOL_n + SPI_CPHA_n )</screen>
<simpara>Where the following parameters can be used as a calculation to set the SPIClockMode.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Mode Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>SPI_CPOL_0</simpara></entry>
<entry align="left" valign="top"><simpara>CPOL = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPI_CPOL_1</simpara></entry>
<entry align="left" valign="top"><simpara>CPOL = 1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPI_CPHA_0</simpara></entry>
<entry align="left" valign="top"><simpara>CPHA = 0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SPI_CPHA_1</simpara></entry>
<entry align="left" valign="top"><simpara>CPHA = 1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Summary:</emphasis></simpara>
<simpara>When using SPI setting the clock frequency is completed using SPIMode, and the master must also configure the clock polarity and phase with respect to the data. Using the two options as CPOL and CPHA.</simpara>
<simpara>The timing diagram is shown below. The timing is further described and applies to both the master and the slave device.</simpara>
<simpara>When CPOL=0 the base value of the clock is zero, i.e. the active state is 1 and idle state is 0.</simpara>
<itemizedlist>
<listitem>
<simpara>For CPHA=0, data are captured on the clock&#8217;s rising edge (low→high transition) and data is output on a falling edge (high→low clock transition).</simpara>
</listitem>
<listitem>
<simpara>For CPHA=1, data are captured on the clock&#8217;s falling edge and data is output on a rising edge.</simpara>
</listitem>
</itemizedlist>
<simpara>When CPOL=1 the base value of the clock is one (inversion of CPOL=0), i.e. the active state is 0 and idle state is 1.</simpara>
<itemizedlist>
<listitem>
<simpara>For CPHA=0, data are captured on clock&#8217;s falling edge and data is output on a rising edge.</simpara>
</listitem>
<listitem>
<simpara>For CPHA=1, data are captured on clock&#8217;s rising edge and data is output on a falling edge.</simpara>
</listitem>
</itemizedlist>
<simpara>When CPHA=0 means sampling on the first clock edge and , while CPHA=1 means sampling on the second clock edge, regardless of whether that clock edge is rising or falling.  Note that with CPHA=0, the data must be stable for a half cycle before the first clock cycle.</simpara>
<simpara>In other words, CPHA=0 means transmitting data on the active to idle state and CPHA=1 means that data is transmitted on the idle to active state edge. Note that if transmission happens on a particular edge, then capturing will happen on the opposite edge(i.e. if transmission happens on falling, then reception happens on rising and vice versa). The MOSI and MISO signals are usually stable (at their reception points) for the half cycle until the next clock transition. SPI master and slave devices may well sample data at different points in that half cycle.</simpara>
<simpara>This adds more flexibility to the communication channel between the master and slave.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/spimode1.PNG" align="center"/>
</imageobject>
<textobject><phrase>[graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Example</emphasis></simpara>
<simpara>This example demonstrates the SPI capabilities for the mega328p.  The process is similar of any microcontroller..</simpara>
<simpara>You must set the data line as inputs and outputs.</simpara>
<screen>        #chip mega328p, 16
        #option explicit
        #include &lt;UNO_mega328p.h &gt;

        #define SPI_HardwareSPI  'comment this out to make into Software SPI but, you may have to change clock lines

        'Pin mappings for SPI - this SPI driver supports Hardware SPI
        #define SPI_DC       DIGITAL_8          ' Data command line
        #define SPI_CS       DIGITAL_4          ' Chip select line
        #define SPI_RESET    DIGITAL_9          ' Reset line

        #define SPI_DI       DIGITAL_12          ' Data in | MISO
        #define SPI_DO       DIGITAL_11          ' Data out | MOSI
        #define SPI_SCK      DIGITAL_13          ' Clock Line

        dir SPI_DC    out
        dir SPI_CS    out
        dir SPI_RESET out
        dir SPI_DO    Out
        dir SPI_DI    In
        dir SPI_SCK   Out

        'If DIGITAL_10 is NOT used as the SPI_CS (sometimes called SS) the port must and output or set as input/pulled high with a 10k resistor.
        'As follows:
        'If CS is configured as an input, it must be held high to ensure Master SPI operation.
        'If the CS pin is driven low by peripheral circuitry when the SPI is configured as a Master with the SS pin defined as an input, the
        'SPI system interprets this as another master selecting the SPI as a slave and starting to send data to it!
        'If CS is an output SPI communications will commence with no flow control.
        dir DIGITAL_10 Out


        dim outbyte, inbyte as byte

        SPIMode ( MasterFast, SPI_CPOL_0 + SPI_CPHA_0 )


       do
        set SPI_CS OFF;  Select line
        set SPI_DC OFF;  Send Data if off, or, Data if On
        SPITransfer ( outbyte, inbyte )
        set SPI_CS ON;   Deselect Line
        set SPI_DC ON
        wait 10 ms
       loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spitransfer">SPITransfer</link>,<link linkend="_fasthwspitransfer">FastHWSPITransfer</link></simpara>
</section>
<section xml:id="_spitransfer">
<title>SPITransfer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <literal>SPITransfer</literal> <emphasis>tx</emphasis>, <emphasis>rx</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with Hardware SPI modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command simultaneously sends and receives a byte of data using the
SPI protocol. It behaves differently depending on whether the microcontroller has
been set to act as a master or a slave.
When operating as a master, <literal>SPITransfer</literal> will initiate a transfer. The
data in <literal><emphasis>tx</emphasis></literal> will be sent to the slave, whilst the byte that is buffered
in the slave will be read into <literal><emphasis>rx</emphasis></literal>.
In slave mode, the <literal>SPITransfer</literal> command will pause the program until a
transfer is initiated by the master. At this point, it will send the
data in <literal><emphasis>tx</emphasis></literal> whilst reading the transmission from the master into the
<literal><emphasis>rx</emphasis></literal> variable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>There are two example programs for this command - one to run on the
slave microcontroller , and one on the master. A reading is taken from a sensor on
the slave, and sent across to the master which shows the data on its LCD
screen.</simpara>
<simpara><emphasis role="strong">Slave Program:</emphasis></simpara>
<screen>  'Select chip model and configuration
  #chip 16F88, 20
  #config MCLR_OFF

  'Set directions of SPI pins
  dir PORTB.2 out
  dir PORTB.1 in
  dir PORTB.4 in
  'Set direction of analogue pin
  dir PORTA.0 in

  'Set SPI mode to slave
  SPIMode Slave

  'Allow other microcontroller to initialise LCD
  Wait 1 sec

  'Main loop - takes a reading, and then waits to send it across.
  do
  'Note that rx is 0 - this is because no data is to be received.
  SPITransfer ReadAD(AN0), 0
  loop</screen>
<simpara><emphasis role="strong">Master Program:</emphasis></simpara>
<screen>  'General hardware configuration
  #chip 16F877A, 20

  'LCD connection settings
  #define LCD_IO 8
  #define LCD_DATA_PORT PORTC
  #define LCD_RS PORTD.0
  #define LCD_RW PORTD.1
  #define LCD_Enable PORTD.2

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do
  'Read a byte from the slave
  'No data to send, so tx is 0
  SPITransfer 0, Temp

  'Display data
  if Temp &gt; 0 then
    CLS
    Print "Light: "
    LCDInt Temp
    Temp = 0
  end if

  'Wait to allow time for the LCD to show the given value
  wait 100 ms
  loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spimode">SPIMode</link>,<link linkend="_fasthwspitransfer">FastHWSPITransfer</link></simpara>
</section>
<section xml:id="_fasthwspitransfer">
<title>FastHWSPITransfer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <literal>FastHWSPITransfer</literal> <emphasis>tx</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip PIC microcontrollers with Hardware SPI modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command only sends a byte of data using the
SPI protocol. This command only supports master mode.</simpara>
<simpara>As a master, <literal>FastHWSPITransfer</literal> will initiate a transfer. The
data in <literal><emphasis>tx</emphasis></literal> will be sent to the slave.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This is an example for this command.</simpara>
<simpara><emphasis role="strong">Master Program:</emphasis></simpara>
<screen>  'General hardware configuration
  #chip 16F877A, 20

  'Set SPI pin directions
  dir PORTC.5 out
  dir PORTC.4 in
  dir PORTC.3 out

  'Set SPI Mode to master, with fast clock
  SPIMode MasterFast

  'Main Loop
  do

      'Send the value of 0x55
      FastHWSPITransfer 0x55

  loop</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_spitransfer">SPITransfer</link>,<link linkend="_spimode">SPIMode</link></simpara>
</section>
</section>
<section xml:id="_i2c_software">
<title>I2C Software</title>
<simpara>This is the I2C Software section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_i2c_overview">
<title>I2C Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These software routines allow Great Cow BASIC programs to send and receive I2C
messages. They can be configured to act as master or slave, and the
speed can also be altered.</simpara>
<simpara>No hardware I2C module is required for these routines - all
communication is handled in software. However, these routines will not
work on 12-bit instruction Microchip PIC microcontrollers (10F, 12F5xx and 16F5xx chips).</simpara>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants control the setup of the software I2C routines:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>I2C_MODE</simpara></entry>
<entry align="left" valign="top"><simpara>Mode of I2C routines (Master or Slave)</simpara></entry>
<entry align="left" valign="top"><simpara>Master</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_DATA</simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C data</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_CLOCK</simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C clock</simpara></entry>
<entry align="left" valign="top"><simpara>N/A</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_BIT_DELAY</simpara></entry>
<entry align="left" valign="top"><simpara>Time for a bit (used for acknowledge detection)</simpara></entry>
<entry align="left" valign="top"><simpara>2 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_CLOCK_DELAY</simpara></entry>
<entry align="left" valign="top"><simpara>Time for clock pulse to remain high</simpara></entry>
<entry align="left" valign="top"><simpara>1 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_END_DELAY</simpara></entry>
<entry align="left" valign="top"><simpara>Time between clock pulses</simpara></entry>
<entry align="left" valign="top"><simpara>1 us</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_USE_TIMEOUT</simpara></entry>
<entry align="left" valign="top"><simpara>Set to true if the I2C routines should stop waiting for the
I2c bus - the routine will exit if a timeout occurs.
Should be used when you need to prevent system lockups on the I2C bus.
</simpara><simpara>Supports both software I2C master and slave mode.
</simpara><simpara>Will return the variable <literal>I2CAck = FALSE</literal> when a timeout has occurred.</simpara></entry>
<entry align="left" valign="top"><simpara>Not Set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>I2C_DISABLE_INTERRUPTS</simpara></entry>
<entry align="left" valign="top"><simpara>Disable interrupts during I2C routines. Important when an i2C clock is
part of your solution</simpara></entry>
<entry align="left" valign="top"><simpara>Not defined.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis>
This example examines the IC2 devices and displays on a terminal.
This code will require adaption but the code shows an approach to discover the IC2 devices.</simpara>
<screen>  ' I2C Overview - using the ChipIno board, see here for information
  #chip 16F886, 8
  #config MCLRE_ON

  ' Define I2C settings
  #define I2C_MODE Master
  #define I2C_DATA PORTC.4
  #define I2C_CLOCK PORTC.3
  #define I2C_DISABLE_INTERRUPTS ON

  'USART/SERIAL PORT via a MAX232 TO PC Terminal
  #define USART_BAUD_RATE 9600
  #define USART_TX_BLOCKING

  Dir PORTc.6 Out
  #define USART_DELAY 5 ms

  HSerPrintCRLF 2
  HSerPrint "I2C Discover using the ChipIno"
  HSerPrintCRLF 2

  HSerPrint "Started: "
  HSerPrint "Searching I2C address space: v0.85"
  HSerPrintCRLF

  wait 100 ms
  dim DeviceID as byte
  for DeviceID = 0 to 255
    I2CStart
    I2CSend ( deviceID )
    I2CSend ( 0 )
    I2CSend ( 0 )
    i2cstop

    if I2CSendState = True  then

      HSerPrint   "__"
      HSerPrint   "ID: 0x"
      HSerPrint   hex(deviceID)
      HSerPrint   " (d"
      HSerPrint   Str(deviceID)
      HSerPrint   ")"
      HSerPrintCRLF
    end if
  next
  HSerPrint   "End of Device Search": HSerPrintCRLF 2
  End</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cackpollstate">
<title>I2CAckPollState</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	&lt;test condition&gt; I2CAckPollState</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.</simpara>
<simpara><literal>I2CACKPOLL</literal> sets the state of variable <literal>I2CAckPollState</literal>. <literal>I2CAckPollState</literal>
can only read - it cannot be set.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	 ...
	' ACK polling removes the need to for the 24xxxxx device to have a 5ms
	write time
	I2CACKPOLL( eeprom_device )
	' You check the exit state,
	' Use I2CAckPollState to check the state of a target device
	 ...</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cackpoll">
<title>I2CAckpoll</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	I2CAckpoll ( <emphasis>I2C_device_address</emphasis> )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Should only be used when I2C routines are operating in Master mode, this
command will look for a specific I2C device on the I2C bus.</simpara>
<simpara>This sets a global variable <literal>I2CAckPollState</literal> that can be inspected in
your calling routine.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>	 ...
	' ACK polling removes the need to for the 24xxxxx device to have a 5ms write time
	I2CACKPOLL( eeprom_device )
	' You check the exit state, use I2CAckPollState to check the state of
	' the acknowledge from the target device
	 ...</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2creceive">
<title>I2CReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	I2CReceive <emphasis>data</emphasis>
	I2CReceive <emphasis>data</emphasis>, <emphasis>ack</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The I2CReceive command will send <literal><emphasis>data</emphasis></literal> through the I2C connection. If
<literal><emphasis>ack</emphasis></literal> is TRUE, or no value is given for <literal><emphasis>ack</emphasis></literal>, then <literal>I2CReceive</literal> will send
an ack.</simpara>
<simpara>If in master mode, <literal>I2CReceive</literal> will read the data immediately.</simpara>
<simpara>If in slave mode, <literal>I2CReceive</literal> will wait for the master to send the data
before reading. When the method <literal>I2CReceive</literal> is used in Slave mode the
global variable <literal>I2CMatch</literal> will be set to true when the received value is
equal to the constant <literal>I2C_ADDRESS</literal>.</simpara>
<simpara><emphasis role="strong">Example 1 - Master Mode:</emphasis></simpara>
<screen>	' I2C Receive - using the ChipIno board, see here for information. ' This program reads an I2C register and LED is set to on if the value  is over 100.
	' This program will read from address 83, register 1.

	#chip 16F886, 8
	#config MCLRE_ON

	'I2C settings
	#define I2C_MODE Master
	#define I2C_DATA PORTC.4
	#define I2C_CLOCK PORTC.3

	'Misc settings
	#define LED PORTB.5
	dir LED Out

	'Main loop
	Do
		'Send start
		I2CStart

		'Request value
		I2CSend 83
		I2CSend 1

		'Read value
		I2CReceive ValueIn

		'Send stop
		I2CStop

		'Turn on LED if received value &gt; 100
		Set LED Off
		If ValueIn &gt; 100 Then Set LED On

		'Delay
		Wait 20 ms

	Loop</screen>
<simpara><emphasis role="strong">Example 2 - Slave Mode:</emphasis></simpara>
<simpara>See the <link linkend="_i2c_overview">I2C Overview</link> for the
Master mode device to control this Slave mode device.</simpara>
<screen>	' I2CReceive_Slave.gcb - using a 16F88.
	' This program receives commands from a GCB Master. This Slave has three LEDs attached.

	;----- Configuration

	#chip 16F88, 8
	#config INTRC_IO,MCLR_OFF


	#define I2C_MODE    Slave     ;this is a slave device now
	#define I2C_CLOCK   portb.4    ;SCL on pin 10
	#define I2C_DATA    portb.1    ;SDA on pin 7
	#define I2C_ADDRESS 0x60      ;address of the slave device

	;----- Variables

	dim addr, reg, value as byte

	;----- Program
	#define LED0  porta.2          ;pin 1
	#define LED1  porta.3          ;pin 2
	#define LED2  porta.4          ;pin 3

	dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
	dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
	dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

	do
	  I2CStart                 ;wait for Start signal
	  I2CReceive( addr )         ;then wait for an address

	  if I2CMatch  = true then    ;if it matches, proceed

		I2CReceive(regval, ACK)   ;get the register number
		I2CReceive(value, ACK)    ;and its value
		I2CStop                   ;release the bus from this end

		select case regval        ;now turn proper LED on or off
		  case 0:
			if value then
			  set LED0 on
			else
			  set LED0 off
			end if

		  case 1:
			if value then
			  set LED1 on
			else
			  set LED1 off
			end if

		  case 2:
			if value then
			  set LED2 on
			else
			  set LED2 off
			end if
		  case else
					 ;other register numbers are ignored
		end select
	  else
		 I2CStop           ;release bus in any event
	  end if

	loop</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2creset">
<title>I2CReset</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CReset</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This will attempt a reset of the I2C by changing the state of the I2C
bus.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> ...
	I2CReset
 ...</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2crestart">
<title>I2CRestart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CRestart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the I2C routines are operating in Master mode, this command will send
a start and restart condition in a single command.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> ...
	I2CRESTART
 ....</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2csend">
<title>I2CSend</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>	I2CSend <emphasis>data</emphasis>
	I2CSend <emphasis>data</emphasis>, <emphasis>ack</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The I2CSend command will send <emphasis>data</emphasis> through the I2C connection. If
<literal><emphasis>ack</emphasis></literal> is TRUE, or no value is given for <literal><emphasis>ack</emphasis></literal>, then <literal>I2CSend</literal> will wait
for an Ack from the receiver before continuing.
If in master mode, <literal>I2CSend</literal> will send the data immediately. If in slave
mode, <literal>I2CSend</literal> will wait for the master to request the data before
sending.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>	' I2CSend - using the ChipIno board, see here for information.
	' This program send commands to a GCB Slave with three LEDs attached.

	#chip 16F886, 8
	#config MCLRE_ON

	'I2C settings
	#define I2C_MODE Master
	#define I2C_DATA PORTC.4
	#define I2C_CLOCK PORTC.3
	#define I2C_BIT_DELAY 20 us
	#define I2C_CLOCK_DELAY 30 us


	#define I2C_ADDRESS 0x60      ;address of the slave device
	;----- Variables

	dim reg as byte

	;----- Program

	do

	  for reg = 0 to 2            ;three LEDs to control
		I2CStart                  ;take control of the bus
		I2CSend I2C_ADDRESS       ;address the device
		if I2CSendState = ACK then
		  I2CSend reg               ;address the particular register
		  I2CSend ON                ;command to turn on LED
		end if
		I2CStop                   ;relinquish the bus
		wait  100 ms
	  next reg
	  wait 1 S                  ;pause to show results

	  for reg = 0 to 2            ;similarly, turn them off
		I2CStart                  ;take control of the bus
		I2CSend I2C_ADDRESS       ;address the device
		if I2CSendState = ACK then
		  I2CSend reg               ;address the particular register
		  I2CSend OFF               ;command to turn off LED
		end if
		I2CStop                   ;relinquish the bus
		wait  100 ms
	  next reg
	  wait 1 S                  ;pause to show results

	loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>	'This program will act as an I2C analog to digital converter
	'When data is requested from address 83, registers 0 through
	'3, it will return the value of AN0 through AN3.

	'Chip model
	#chip 16F88, 8

	'I2C settings
	#define I2C_MODE Slave
	#define I2C_CLOCK PORTB.0
	#define I2C_DATA PORTB.1

	#define I2C_DISABLE_INTERRUPTS ON

	'Main loop
	Do
		'Wait for start condition
		I2CStart

		'Get address
		I2CReceive Address
		If Address = 83 Then
			'If address was this device's address, respond
			I2CReceive Register

			OutValue = ReadAD(Register)
			I2CSend OutValue
		End If

		I2CStop

		Wait 5 ms
	Loop</screen>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cstart">
<title>I2CStart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CStart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the I2C routines are operating in Master mode, this command will send
a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.</simpara>
<simpara>If interrupt handling is enabled, this command will disable it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_i2csend">I2CSend</link> and <link linkend="_i2creceive">I2CReceive</link>
for an example.</simpara>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cstartoccurred">
<title>I2CStartoccurred</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CStartoccurred</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction Microchip PIC microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the I2C routine IS operating in Slave mode, this function will check if a start condition has occurred since the last run of this function.
	'Only used in slave mode</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_i2csend">I2CSend</link> and <link linkend="_i2creceive">I2CReceive</link>
for an example.</simpara>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
<section xml:id="_i2cstop">
<title>I2CStop</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    I2CStop</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers except 12 bit instruction microcontrollers (10F,
12F5xx, 16F5xx chips)</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>When in Master mode, this command will send an I2C stop condition, and
re-enable interrupts if <literal>I2CStart</literal> disabled them. In Slave mode, it will
re- enable interrupts.</simpara>
<simpara><literal>I2CStop</literal> should be called at the end of every I2C transmission.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_i2csend">I2CSend</link> and <link linkend="_i2creceive">I2CReceive</link>
for an example.</simpara>
<simpara>Supported in &lt;I2C.H&gt;</simpara>
</section>
</section>
<section xml:id="_i2c_twi_hardware_module">
<title>I2C/TWI Hardware Module</title>
<simpara>This is the I2C/TWI section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_hi2c_overview">
<title>HI2C Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These methods allow Great Cow BASIC programs to send and receive Inter- Integrated Circuit (I2C™) messages via:</simpara>
<itemizedlist>
<listitem>
<simpara>Master Synchronous Serial Port (MSSP) module of the microcontroller for the Microchip PIC architecture, or</simpara>
</listitem>
<listitem>
<simpara>ATMEL 2-wire Serial Interface (TWI) for the Atmel AVR microcontroller architecture.</simpara>
</listitem>
</itemizedlist>
<simpara>These methods are serial interfaces that are useful for communicating with other peripheral or microcontroller devices.
These peripheral devices may be serial EEPROMs, shift registers, display drivers, A/D converters, etc.</simpara>
<simpara>The method can operate in one of two operational modes:</simpara>
<itemizedlist>
<listitem>
<simpara>Master Mode, or</simpara>
</listitem>
<listitem>
<simpara>Slave mode (with general address call)</simpara>
</listitem>
</itemizedlist>
<simpara>These methods fully implement all the I2C master and slave functions (including general call support) and
supports interrupts on start and stop bits in hardware to determine a free bus (multi-master function).</simpara>
<simpara>These methods implement the standard mode specifications as well as 7-bit and 10-bit addressing.
A “glitch” filter is built into the SCL and SDA pins when the pin is an input.  This filter operates in both
the 100 KHz and 400 KHz modes. In the 100 KHz mode, when these pins are an output, there
is a slew rate control of the pin that is independent of device frequency.</simpara>
<simpara>A hardware I2C/TWI module within the microcontroller is required for these methods.</simpara>
<simpara>The driver supports two hardware I2C ports.  The second port is addressed by the suffix HI2C2.  All HI2C commands are applicable to the second HI2C2 port.</simpara>
<simpara>The method supports the following frequencies:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Frequency</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Support</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Up to 400 kbits/s</simpara></entry>
<entry align="left" valign="top"><simpara>I2C/TWI <literal>fast mode</literal>: Defined as transfer rates up to 400 kbit/s</simpara></entry>
<entry align="left" valign="top"><simpara>Supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Up to 100 kbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C/TWI <literal>standard mode</literal>:  Defined as transfer rates up to 100 kbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>Supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Up to 1 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C <literal>fast-mode plus</literal>: Allowing up to 1 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>Not Supported</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Up to 3.4 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>I2C <literal>high speed</literal>: Allowing up to 3.4 Mbit/s.</simpara></entry>
<entry align="left" valign="top"><simpara>Not Supported</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants control the setup of the hardware I2C methods:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Usage</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Master</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operational mode of the microcontroller</simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2CMode ( <emphasis>Master</emphasis> )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Slave</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operational mode of the microcontroller</simpara></entry>
<entry align="left" valign="top"><simpara><literal>HI2CMode ( <emphasis>Slave</emphasis> )</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_BAUD_RATE</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Operational speed of the microcontroller. Defaults to 100mhz</simpara></entry>
<entry align="left" valign="top"><simpara><literal>#define HI2C_BAUD_RATE 400</literal>   or <?asciidoc-br?>
<literal>#define HI2C_BAUD_RATE 100.</literal><?asciidoc-br?>
Where  <literal>#define HI2C_BAUD_RATE 100</literal> is the default value and therefore does need to be specified.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Port Settings:</emphasis></simpara>
<simpara>The settings of the pin direction is critical to the operation of these
methods. Both pins <emphasis role="strong">must</emphasis> be set as inputs and be pulled up with an
appropriate resistor (typically 4.k @ 5.0v for 100Mkz transmissions).</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_DATA</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C data</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>HI2C_CLOCK</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Pin on microcontroller connected to I2C clock)</simpara></entry>
<entry align="left" valign="top"><simpara>Must be defined</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example examines the IC2 devices and displays on a serial terminal.
This code will require adaption but the code shows an approach to
discover the IC2 devices.</simpara>
<screen>    ' Hardware I2C Overview - using the ChipIno board, see
    ' http://www.elproducts.com/chipino.html for information

    #chip mega328p, 16
    #config MCLRE_ON

    ' Define I2C settings
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.5
    #define HI2C_CLOCK PORTC.4
    'I2C pins need to be input for SSP module when used on Microchip PIC device
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER MODE
    HI2CMode Master

    'USART/SERIAL PORT WORKS WITH max232 THEN TO PC Terminal
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    Dir PORTc.6 Out
    #define USART_DELAY 10 ms

    HSerPrintCRLF 2
    HSerPrint "Hardware I2C Discover using the "
    HSerPrint CHipNameStr
    HSerPrintCRLF 2

    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if HI2CAckPollState = false then

         if (( deviceID &amp; 1 ) = 0 ) then
         HSerPrint "W"
        else
         HSerPrint "R"
        end if
        HSerSend 9
        HSerPrint   "ID: 0x"
        HSerPrint   hex(deviceID)
        HSerSend 9
        HSerPrint "(d)"+str(deviceID)
        HSerPrintCRLF

        HI2CSend ( 0 )
        HI2CSend ( 0 )
      end if

      HI2CStop
    next
    HSerPrintCRLF
    HSerPrint   "End of Device Search"
    HSerPrintCRLF 2</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cackpollstate">
<title>HI2CAckPollState</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    &lt;test condition[s]&gt; HI2CAckPollState</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Should only be used when I2C routines are operating in Master mode, this
command will return the last state of the acknowledge response from a
specific I2C device on the I2C bus.</simpara>
<simpara><literal>HI2CSend</literal> sets the state of variable <literal>HI2CAckPollState</literal>.<?asciidoc-br?>
<literal>HI2CAckPollState</literal> can only read - it cannot be set.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    &lt;test condition[s]&gt; HI2C2AckPollState</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example code would display the devices on the I2C bus.</simpara>
<screen>     ...
    for deviceID = 0 to 255
      HI2CStart
      HI2CSend ( deviceID )

      if <literal>HI2CAckPollState</literal> = false then
      HSerPrint "ID: 0x"
      HSerPrint hex(deviceID)
      HSerSend 9
      end if
    next
     ...</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2creceive">
<title>HI2CReceive</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CReceive <emphasis>data</emphasis>

    HI2CReceive <emphasis>data</emphasis>, ACK
    HI2CReceive <emphasis>data</emphasis>, NACK</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The HI2CReceive command will send <emphasis>data</emphasis> through the I2C connection. If
<literal><emphasis>ack</emphasis></literal> is TRUE, or no value is given for <literal><emphasis>ack</emphasis></literal>, then <literal>HI2CReceive</literal> will send
an ack to the I2C bus.</simpara>
<simpara>If in master mode, <literal>HI2CReceive</literal> will read the data immediately. If in
slave mode, <literal>HI2CReceive</literal> will wait for the master to send the data before
reading.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Receive  _data_

    HI2C2Receive _data_, ACK
    HI2C2Receive _data_, NACK</screen>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program reads an I2C register and sets an LED if it is over 100.

    'It will read from I2C device with an address of 83, register 1.
    ' Change the processor
    #chip 16F1937, 32
    #config Osc = intOSC, MCLRE_ON, PLLEN_ON, VCAPEN_OFF


    ' Define I2C settings
    #define HI2C_BAUD_RATE 400

    #define HI2C_DATA PORTC.4
      #define HI2C_CLOCK PORTC.3

    'I2C pins need to be input for SSP module
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in

    'MASTER I2C Device
    HI2CMode Master

    'Misc settings
    #define LED PORTB.0

    'Main loop
    Do
      'Send start
      HI2CStart

      'Request value
      HI2CSend 83
      HI2CSend 1

      'Read value
      HI2CReceive ValueIn

      'Send stop
      HI2CStop

      'Turn on LED if received value &gt; 100
      Set LED Off
      If ValueIn &gt; 100 Then Set LED On

      'Delay
      Wait 20 ms

    Loop</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>See the <link linkend="_i2c_overview">I2C Overview</link> for the Master mode
device to control this Slave mode device.</simpara>
<screen>    ' I2CHardwareReceive_Slave.gcb - using a 16F88.
    ' This program receives commands from a GCB Master. This Slave has three LEDs attached.

    ; This Slave device responds to address 0x60 and may only be written to.
    ; Within it, there are three registers, 0,1 and 2 corresponding to the three LEDs. Writing a zero
    ; turns the respective LED off. Writing anything else turns it on.


    #chip 16F88, 4
    #config INTRC_IO,MCLR_Off

    #define I2C_MODE    Slave     ;this is a slave device now
    #define I2C_CLOCK   portb.4   ;SCL on pin 10
    #define I2C_DATA    portb.1   ;SDA on pin 7
    #define I2C_ADDRESS 0x60      ;address of the slave device

    #define I2C_BIT_DELAY 20 us
    #define I2C_CLOCK_DELAY 10 us
    #define I2C_END_DELAY 10 us


    'Serial settings
    #define SerInPort PORTB.6
    #define SerOutPort PORTB.7

    #define SendAHigh Set SerOutPort OFF
    #define SendALow Set SerOutPort On
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In

    'Set up serial connection
    InitSer 1, r2400, 1 + WaitForStart, 8, 1, none, INVERT
    wait 1 s

    #define LED0  porta.2          ;pin 1
    #define LED1  porta.3          ;pin 2
    #define LED2  porta.4          ;pin 3

    ;----- Variables

    dim addr, reg, value,location as byte
    addr = 255
    reg = 255
    value = 255
    location = 0
    mempointer = 255

    ;----- Program

    dir LED0 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED1 out                  ;0, 1 and 2 are outputs (LEDs)
    dir LED2 out                  ;0, 1 and 2 are outputs (LEDs)

    set LED0 off
    set LED1 off
    set LED2 off

    #define SerialControlPort portb.3
    dir SerialControlPort in

    'Set up interrupt to process I2C

       dir I2C_CLOCK in           ; required to input for MSSP module
       dir I2C_DATA in            ; required to input for MSSP module
       SSPADD=I2C_ADDRESS         ; Slave address
       SSPSTAT=b'00000000'        ; configuration
       SSPCON=b'00110110'         ; configuration
       PIE1.SSPIE=1               ; enable interrupt


    repeat 3                      ;flash LEDs
      set LED0 on
      set LED1 on
      set LED2 on
      wait 50 ms
      set LED0 off
      set LED1 off
      set LED2 off
      wait  100 ms
    end Repeat

    oldvalue = 255                ; old value, set up value only
    oldreg = 255                  ; old value, set up value only

    UpdateLEDS                    ; call method to set LEDs
                    ; set up interrupt
    On Interrupt SSP1Ready call I2C_Interrupt

    do forever
       if reg &lt;&gt; oldreg then      ; only process when the reg is a new value
        oldreg = reg            ; retain old value
        show = 1                ; its time to show the LEDS!
        if  value &lt;&gt; oldvalue then    ; logic for tracking old values. You only want to update terminal once per change
          oldvalue = value
          show = 1
        end if
       end if

       UpdateLEDS                  ; Update date LEDs

                     ; update serial terminal
       if show = 1  and SerialControlPort = 1 then

        SerPrint 1, "0x"+hex(addr)
        SerSend 1,9

        SerPrint 1, STR(reg)
        SerSend 1,9

        SerPrint 1, STR(value)
        SerSend 1,10
        SerSend 1,13

        show = 0
       end if
    loop


    Sub I2C_Interrupt
      ' handle interrupt
      IF SSPIF=1 THEN                   ; its a valid interrupt

         IF SSPSTAT.D_A=0 THEN          ; its an address coming in!
          addr=SSPBUF
          IF addr=I2C_ADDRESS THEN    ; its our address

           mempointer = 0           ; set the memory pointer. This code emulates an EEPROM!

          end if
          IF addr = ( I2C_ADDRESS | 1 ) THEN    ; its our write address
           CKP = 0                            ; acknowledge command
                            ; If the SDA line was low (ACK), the transmit data must be loaded into
                            ; the SSPBUF register which also loads the SSPSR
                            ; register. Then, pin RB4/SCK/SCL should be enabled
                            ; by setting bit CKP.

           mempointer = 10                    ; set a pointer to track incoming write reqests
           if I2C_DATA = 0 then
            SSPBUF = 0x22
            CKP = 1
            readpointer = 0x55
           end if
          end if

         else

         if  SSPSTAT.P = 1 then             ' Stop bit has been detected - out of sequence
           ' handle event
         end if

         IF  SSPSTAT.S = 1 THEN             ' Start bit has been detected - out of sequence
           ' handle event
         END IF

         IF SSPSTAT.R_W = 0 THEN            ' Write operations requested

          SELECT CASE mempointer
               CASE 0
                reg = SSPBUF         ' incoming value
                mempointer++         ' increment our counter
               CASE 1
                value = SSPBUF       ' incoming value
                mempointer++         ' increment our counter
               CASE ELSE
                dummy = SSPBUF       ' incoming value
          END SELECT

         ELSE                                ' Read operations
          SSPBUF = readpointer             ' incoming value
          readpointer++                    ' increment our counter

         END IF
         END IF
         CKP = 1                               ' acknowledge command
         SSPOV = 0                             ' acknowledge command
      END IF
      SSPIF=0
    END SUB



    sub UpdateLEDS

      select case reg           ;now turn proper LED on or off
        case 0
        if value = 1 then
          set LED0 on
        else
          set LED0 off
        end if

        case 1
        if value = 1 then
          set LED1 on
        else
          set LED1 off
        end if

        case 2
        if value = 1 then
          set LED2 on
        else
          set LED2 off
        end if

      end select

    End Sub</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2crestart">
<title>HI2CRestart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CRestart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the HI2C routines are operating in Master mode, this command will
send a start and restart condition in a single command.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Restart</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    do
        HI2CReStart                           ;generate a start signal
        HI2CSend(eepDev)                      ;inidcate a write
    loop While HI2CAckPollState

    HI2CSend(eepAddr_H)                   ;as two bytes
    HI2CSend(eepAddr)
    HI2CReStart
    HI2CSend(eepDev + 1)                  ;indicate a read

    eep_i = 0                             ;loop consecutively
    do while (eep_i &lt; eepLen)             ;these many bytes
        eep_j = eep_i + 1                   ;arrays begin at 1 not 0
        if (eep_i  &lt; (eepLen - 1)) then
        HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
        else
        HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
        end if
        eep_i++                             ;get set for next
    loop
    HI2CStop</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2csend">
<title>HI2CSend</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CSend <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the MSSP module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The HI2CSend command will send <literal><emphasis>data</emphasis></literal> through the I2C connection.
If in master mode, HI2CSend will send the data immediately. If in slave
mode, HI2CSend will wait for the master to request the data before
sending.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Send  data</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example code retrieves multiple bytes from an EEPROM memory device.</simpara>
<screen>	do
	  HI2CReStart                         ;generate a start signal
	  HI2CSend(eepDev)                    ;indicate a write
	loop While HI2CAckPollState

	HI2CSend(eepAddr_H)                   ;as two bytes
	HI2CSend(eepAddr)
	HI2CReStart
	HI2CSend(eepDev + 1)                  ;indicate a read

	eep_i = 0                             ;loop consecutively
	do while (eep_i &lt; eepLen)             ;these many bytes
	  eep_j = eep_i + 1                   ;arrays begin at 1 not 0
	  if (eep_i  &lt; (eepLen - 1)) then
		HI2CReceive(eepArray(eep_j), ACK)  ;more data to get
	  else
		HI2CReceive(eepArray(eep_j), NACK ) ;send NACK on last byte
	  end if
	  eep_i++                             ;get set for next
	loop
	HI2CStop</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstart">
<title>HI2CStart</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStart</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the MSSP module..</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>If the HI2C routines are operating in Master mode, this command will
send a start condition. If routines are in Slave mode, it will pause the
program until a start condition is sent by the master. It should be
placed at the start of every I2C transmission.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Start</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_hi2csend">HI2CSend</link> and <link linkend="_hi2creceive">HI2CReceive</link> for
examples.</simpara>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstartoccurred">
<title>HI2CStartOccurred</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStartOccurred</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Check if a start condition has occurred since the last run of this
function</simpara>
<simpara>Only used in slave mode.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2StartOccurred</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cmode">
<title>HI2CMode</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CMode Master | Slave</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets the microcontroller to either a Master device or a Slave device.</simpara>
<simpara>Only used in slave mode</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Mode Master | Slave</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2csetaddress">
<title>HI2CSetAddress</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CSetAddress address_number</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Sets the microcontroller address number in Slave mode.</simpara>
<simpara>Only used in slave mode.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2SetAddress address_number</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstop">
<title>HI2CStop</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStop</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>HI2CStop</literal> should be called at the end of every I2C transmission.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Stop</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>Please see <link linkend="_hi2csend">HI2CSend</link> and <link linkend="_hi2creceive">HI2CReceive</link> for an
example.</simpara>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cstopped">
<title>HI2CStopped</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CStopped</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>In Slave mode only. Check if start condition received since last used of
HI2CStopped.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2Stopped</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
<section xml:id="_hi2cwaitmssp">
<title>HI2CWaitMSSP</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    HI2CWaitMSSP</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Only available for microcontrollers with the hardware I2C or TWI module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The methods sets the global byte variable <emphasis>HI2CWaitMSSPTimeout</emphasis> to 255 ( or True ) if the MSSP module has timeout during operations.</simpara>
<simpara><emphasis>HI2CWaitMSSPTimeout</emphasis> can tested for the status of the I2C bus.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>This command is also available on microcontrollers with a second hardware I2C port.</simpara>
<screen>    HI2C2WaitMSSP</screen>
<simpara>Supported in &lt;HI2C.H&gt;</simpara>
</section>
</section>
<section xml:id="_sound">
<title>Sound</title>
<simpara>This is the Sound section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_sound_overview">
<title>Sound Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>These Great Cow BASIC methods generate tones of a given frequency and duration.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Method</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Tone</simpara></entry>
<entry align="left" valign="top"><simpara>Generate a specified tone for a specified duration in terms of a frequency of a specified Mhz and units of 10ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ShortTone</simpara></entry>
<entry align="left" valign="top"><simpara>Generate a specified tone for a specified duration in terms of a frequency of a 10Mhz and units of 1ms</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Play</simpara></entry>
<entry align="left" valign="top"><simpara>Play a tune string.  The format of the string is the QBASIC play command.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>PlayRTTTL</simpara></entry>
<entry align="left" valign="top"><simpara>Play a tune string.  The format of the string is the Nokia cell phone RTTTL format.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Relevant Constants:</emphasis></simpara>
<simpara>These constants are used to control settings for the tone generation routines. To set them, place a line in the main program file that uses <literal>#define</literal> to assign a value to the particular constant.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="3">
<colspec colname="col_1" colwidth="112*"/>
<colspec colname="col_2" colwidth="112*"/>
<colspec colname="col_3" colwidth="112*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Constant Name</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Controls</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Default Value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>SoundOut</literal></simpara></entry>
<entry align="left" valign="top"><simpara>The output pin to produce sound on</simpara></entry>
<entry align="left" valign="top"><simpara>N/A - <emphasis role="strong"><emphasis>Must be defined</emphasis></emphasis></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong"><emphasis>Note:</emphasis></emphasis> If an exact frequency is required, or a smaller program is needed, these routines should not be used. Instead, you should use code like this:</simpara>
<screen>    Repeat <emphasis>count</emphasis>
    PulseOut SoundOut, <emphasis>period</emphasis> us
    Wait <emphasis>period</emphasis> us
    End Repeat</screen>
<simpara>Set <literal><emphasis>count</emphasis></literal> and <literal><emphasis>period</emphasis></literal> to the appropriate values as follows:</simpara>
<simpara><literal><emphasis>period</emphasis></literal> to 1000000 / desired frequency / 2<?asciidoc-br?>
<literal><emphasis>count</emphasis></literal> to desired duration / <emphasis>period</emphasis>.</simpara>
</section>
<section xml:id="_tone">
<title>Tone</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Tone <emphasis>Frequency, Duration</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will produce the specified tone for the specified duration.
<literal><emphasis>Frequency</emphasis></literal> is measured in Hz, and <literal><emphasis>Duration</emphasis></literal> is in 10 ms units.</simpara>
<simpara>Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>'Sample program to produce a constant A note (440 Hz)
'on PORTB bit 1.
#chip 16F877A, 20
#define SoundOut PORTB.1

Do
    Tone 440, 1000
Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
<section xml:id="_shorttone">
<title>ShortTone</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ShortTone Frequency, Duration</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This command will produce the specified tone for the specified duration.
Frequency is measured in units of 10 Hz, and Duration is in 1 ms units.
Please note that this command may not produce the exact frequency
specified. While it is accurate enough for error beeps and small pieces
of monophonic music, it should not be used for anything that requires a
highly precise frequency.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Sample program to produce a tone on PORTB bit 1, based on the
    'reading of an LDR on AN0 (usually PORTA bit 0).

    #chip 16F88, 20
    #define SoundOut PORTB.1

    Dir PORTA.0 In

    Do
        ShortTone ReadAD(AN0), 100
    Loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
<section xml:id="_play">
<title>Play</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Play SoundPlayDataString</screen>
<simpara>You must specify the following include and the port of the sound device.</simpara>
<screen>    #include &lt;songplay.h&gt;
    #define SOUNDOUT PORTN.N</screen>
<simpara><emphasis role="strong">Command Availability::</emphasis>
Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
This command will plays a QBASIC sequence of notes. The SoundPlayDataString is a string representing a musical note or notes to play where Notes are A to G.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>A - G</simpara></entry>
<entry align="left" valign="top"><simpara>May be followed by length: 2 = half note, 4 = quarter, also may be followed by # or + (sharp) or - (flat).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>On</simpara></entry>
<entry align="left" valign="top"><simpara>Sets current octave. n is octave from 0 to 6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Pn</simpara></entry>
<entry align="left" valign="top"><simpara>Pause playing. n is length of rest</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ln:</simpara></entry>
<entry align="left" valign="top"><simpara>Set default note length. n = 1 to 8.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>&lt; or &gt;</simpara></entry>
<entry align="left" valign="top"><simpara>Change down or up an octave</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Tn:</simpara></entry>
<entry align="left" valign="top"><simpara>Sets tempo in L4s/minute. n = 32 to 255, default 120.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Nn</simpara></entry>
<entry align="left" valign="top"><simpara>Play note n. n = 0 to 84, 0 = rest.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Unsupported QBASIC commands are</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<?dbhtml table-width="80%"?>
<?dbfo table-width="80%"?>
<?dblatex table-width="80%"?>
<tgroup cols="2">
<colspec colname="col_1" colwidth="170*"/>
<colspec colname="col_2" colwidth="170*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>M</simpara></entry>
<entry align="left" valign="top"><simpara>Play mode</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>.</simpara></entry>
<entry align="left" valign="top"><simpara>Changes note length</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>For more information on the QBASIC PLAY command set, see <link xlink:href="https://en.wikibooks.org/wiki/QBasic/Appendix">https://en.wikibooks.org/wiki/QBasic/Appendix</link></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Sample program to play a string
    'on PORTB bit 1.
    #chip 16F877A, 20
    #include &lt;songplay.h&gt;
    #define SoundOut PORTB.1


    play "C C# C C#"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
<section xml:id="_play_rtttl">
<title>Play RTTTL</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PlayRTTTL SoundPlayRTTTLDataString</screen>
<simpara>You must specify the following include and the port of the sound device.</simpara>
<screen>    #include &lt;songplay.h&gt;
    #define SOUNDOUT PORTN.N</screen>
<simpara><emphasis role="strong">Command Availability::</emphasis>
Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis>
This command will play a sequence of notes in the Nokia RTTTL string format.</simpara>
<simpara>The SoundPlayRTTTLDataString is a string representing a musical note or notes to play where Notes are A to G. This format and information below is credited to WikiPedia, see here.
To be recognized by ringtone programs, an RTTTL/Nokring format ringtone must contain three specific elements: name, settings, and notes.   For example, here is the RTTTL ringtone for Haunted House:</simpara>
<simpara>HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4</simpara>
<simpara>The three parts are separated by a colon.</simpara>
<itemizedlist>
<listitem>
<simpara>Part 1: name of the ringtone (here: "HauntHouse"), a string of characters represents the name of the ringtone</simpara>
</listitem>
<listitem>
<simpara>Part 2: settings (here: d=4,o=5,b=108), where "d=" is the default duration of a note. In this case, the "4" means that each note with no duration specifier (see below) is by default considered a quarter note. "8" would mean an eighth note, and so on. Accordingly, "o=" is the default octave. There are four octaves in the Nokring/RTTTL format. And "b=" is the tempo, in "beats per minute".</simpara>
</listitem>
<listitem>
<simpara>Part 3: the notes. Each note is separated by a comma and includes, in sequence: a duration specifier, a standard music note, either a, b, c, d, e, f or g, and an octave specifier. If no duration or octave specifier are present, the default applies.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    #chip 16f877a
    #include &lt;songplay.h&gt;


    #define SOUNDOUT PORTA.4
    PlayRTTTL "HauntHouse: d=4,o=5,b=108: 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4, 1p, 2a4, 2e, 2d#, 2b4, 2a4, 2c, 2d, 2a#4, 2e., e, 1f4, 1a4, 1d#, 2e., d, 2c., b4, 1a4"</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>		#chip 16f877a
    #include &lt;songplay.h&gt;

    'Defines
    #define SoundOut PORTC.0


    Dir SoundOut Out
    Dim SoundPlayRTTTLDataString as String


    wait 1 s
    SoundPlayRTTTLDataString = "Thegood,:d=4,o=6,b=63:32c,32f,32c,32f,c,8g_5,8a_5,f5,8p,32c,32f,32c,32f,c,8g_5,8a_5,d_"
    PlayRTTTL(SoundPlayRTTTLDataString)


    wait 1 s
    SoundPlayRTTTLDataString ="LedZeppel:d=4,o=6,b=80:8g,16p,8f_,16p,8f,16p,8e,16p,8d,8a5,8c,16p,8b5,16p,a_5,8a5,16f5,16e5,16d5,8p,16p,16a_5,16a_5,16a_5,8p,16p,16b5,16b5,16b5,8p,16p,16b5,16b5,16b5,8p,16p,16c,16c,16c,8p,16p,16c,16c,16c"
    PlayRTTTL(SoundPlayRTTTLDataString)


    Do Forever
    Loop
    End</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_sound_overview">Sound Overview</link></simpara>
</section>
</section>
<section xml:id="_timers">
<title>Timers</title>
<simpara>This is the Timers section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_timer_overview">
<title>Timer Overview</title>
<simpara>Great Cow BASIC supports methods to set, clear, read, start and stop the microcontroller timers.</simpara>
<simpara>Great Cow BASIC supports the following timers.</simpara>
<screen>    Timer 0
    Timer 1
    Timer 2
    Timer 3
    Timer 4
    Timer 5
    Timer 6
    Timer 7
    Timer 8
    Timer 10
    Timer 12</screen>
<simpara>Not all of these timers available on all microcontrollers. For example,
if a microcontroller has three timers, then typically only <literal>Timer0</literal>,
<literal>Timer1</literal> and <literal>Timer2</literal> will be available.</simpara>
<simpara>Please refer to the datasheet for your microcontroller to determine the supported
timers and if a specific timer is 8-bit or 16-bit.</simpara>
<simpara><emphasis role="strong">Calculating a Timer Prescaler:</emphasis></simpara>
<simpara>To initialise and change the timers you may have to change the Prescaler.</simpara>
<simpara>A Prescaler is an electronic counting circuit used to reduce a high frequency electrical signal to a lower frequency by integer division.
The prescaler takes the basic timer clock frequency and divides it by some value before being processed by the timer, according to how the Prescaler register(s) are configured.
The prescaler values that may be configured might be limited to a few fixed values, see the timer specfic page in this Help file or refer to the datasheet.</simpara>
<simpara>To use a Prescaler some simple integer maths is required, however, when calculating the Prescaler there is often be a tradeoff between resolution, where a high resolution requires a high clock frequency and range where a high clock frequency willl cause the timer to overflow more quickly.
For example, achieving 1 us resolution and a 1 sec maximum period using a 16-bit timer may require some clever thinking when using 8-bit timers.
Please ask for advice via the Great Cow BASIC forum, or, search for some of the many great resources on the internet to calculate a Prescaler value.</simpara>
<simpara><emphasis role="strong">Common Langauge:</emphasis></simpara>
<simpara>Using timers has the following terms /common langauge.  This following paragraph is intended to explain the common language.</simpara>
<simpara>The Oscillator (OSC) is the system clock, this can be sourced from an internal or external source, OSC is same the as microcontroller Mhz.
This is called the the Frequency of the OSCillator (FOSC) or the System Clock.</simpara>
<simpara>On a Microchip PIC microcontroller, one machine code instruction is executed for every four system clock pulses.<?asciidoc-br?>
This means that instructions are executed at a frequency of FOSC/4.<?asciidoc-br?>
The Microchip PIC datasheets call this FOSC/4 or FOSC4.<?asciidoc-br?>
All Microchip PIC timer prescales are based on the FOSC/4, not the FOSC or the System Clock.<?asciidoc-br?>
As Prescale are based upon FOSC/4,  you must use FOSC/4 in your timer calculations to get the results you expect.<?asciidoc-br?>
All Prescale and Postscale values are integer numbers.</simpara>
<simpara>On Atmel AVR microcontroller, most machine code instructions will execute in a single clock pulse.</simpara>
<simpara><emphasis role="strong">Timer differences between Microchip PIC and Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>Initialising a timer for a Microchip PIC microcontroller may not operate as expected when using the same code for an Atmel AVR microcontroller by simply changing the <literal>#chip</literal> definition.
You <emphasis role="strong">must</emphasis> recalculate the Prescaler of a timer when moving timer parameters between Microchip PIC and Atmel AVR microcontrollers.
And, of course, the same when moving timer parameters between Atmel AVR and Microchip PIC microcontrollers.</simpara>
<simpara><emphasis role="strong">Timer Best Practices:</emphasis></simpara>
<simpara>Initialising microcontrollers with very limited RAM using Great Cow BASIC needs carefull consideration.
RAM may be need to be optimised by using ASM to control the timers.
You can use Great Cow BASIC to create the timer related Great Cow BASIC ASM code then manually edit the Great Cow BASIC ASM to optmise RAM usage.
Add your revised and optimised ASM back into your program and then remove the no longer required calls the the Great Cow BASIC methods.
If you need advice on this subject please ask for advice via the Great Cow BASIC forum.</simpara>
<simpara><emphasis role="strong">Using Timers 2/4/6/8 on Microchip PIC microcontrollers.</emphasis></simpara>
<simpara>A Microchip PIC microcontroller can have one of two types of 8-bit timer 2/4/6/8.</simpara>
<simpara>The first type has only one clock source and that clock is the FOSC/4 source.</simpara>
<simpara>The second type is much more flexible and can have many different clock sources and supports more prescale values.</simpara>
<simpara>The timer type for a Microchip PIC microcontroller can be determined by checking for the existence of a T2CLKCON register, either in the Datasheet or in the Great Cow BASIC "dat file" for the specific microcontroller.</simpara>
<simpara>If the microcontroller DOES NOT have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the first type, and are configured using:</simpara>
<screen>    _InitTimer2 (PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</screen>
<simpara>If the microcontroller DOES have a T2CLKCON register then ALL Timer 2/4/6/8 timers on that chip are the second type and are configured using:</simpara>
<screen>    _InitTimer2 (Source, PreScale, PostScale)_   'Timer2 is example for timer 2/4/6 or 8</screen>
<simpara>The possible <emphasis>Source</emphasis>, <emphasis>PreScale</emphasis> and <emphasis>PostScale</emphasis> constants for each type are shown in the Great Cow BASIC Help file.  See each timer for the constants.</simpara>
<simpara>The "Period" of these timers is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;&#160;The timer period registers are PR2, PR4, PR6 or PR8 for timer2, timer4, timer6 and timer8 respectively.  These registers are also called PRx and TMRx where the <emphasis role="strong"><literal>x</literal></emphasis> refers to specific timer number.</simpara>
<simpara>When a specific timer is enabled/started the TMRx timer register will increment until the TMRx register matches the value in the PRx register.&#160;&#160;&#160;At this time the TMRx register is cleared to 0 and the timer continues to increment until the next match of the PRx register, and so on until the timer is stopped.&#160;&#160;&#160;The lower the value of the PRx register, the shorter the timer period will be.&#160;&#160;&#160;The default value for the PRX register at power up is 255.</simpara>
<simpara>The timer interrupt flag (TMRxIF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
<section xml:id="_cleartimer">
<title>ClearTimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    ClearTimer <emphasis>TimerNo</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip PIC and Atmel AVR microcontrollers with built in timer modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>ClearTimer</literal> is used to clear the specified timer to a value of 0.</simpara>
<simpara><literal>Cleartimer</literal> can be used on-the-fly if desired, so there is no requirement to
stop the timer first.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    .....
    'Clear timer 1
    ClearTimer 1
    .....</screen>
<simpara><emphasis role="strong">See also, <link linkend="_inittimer1">InitTimer1</link></emphasis> article for an example.</simpara>
</section>
<section xml:id="_inittimer0">
<title>InitTimer0</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    InitTimer0 source, prescaler</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 0 module.</simpara>
<simpara>See also  see: <link linkend="_inittimer0_8bit_16bit">InitTimer0 8bit/16bit</link> for support for microcontrollers with a 8 bit/16 bit Timer 0 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer0</literal> will set up timer 0.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows from 255 to 0, a  <literal>Timer0Overflow</literal> interrupt will
be generated. This can be used in conjunction with <literal>On Interrupt</literal> to run a
section of code when the overflow occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers where the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 2 to 256  you should use one of the following constants.  If the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 1 to 32768 then see the subsequent table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:256 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On Atmel AVR microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the
internal oscillator - the prescaler has no effect when the external clock
source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1 for 8-bit timer 0:</emphasis></simpara>
<simpara>This code uses Timer 0 and On Interrupt to generate a Pulse Width Modulation
signal, that will allow the speed of a motor to be easily controlled.</simpara>
<screen>    #chip 16F88, 8
    #config osc = int

    #define MOTOR PORTB.0

    'Call the initialisation routine
    InitMotorControl

    'Main routine
    Do
        'Increase speed to full over 2.5 seconds
        For Speed = 0 to 100
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
        'Decrease speed to zero over 2.5 seconds
        For Speed = 100 to 0
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
    Loop

    'Setup routine
    Sub InitMotorControl
        'Clear variables
        MotorSpeed = 0
        PWMCounter = 0

        'Add a handler for the interrupt
        On Interrupt Timer0Overflow Call PWMHandler

        'Set up the timer using the internal oscillator with a prescaler of 1/2 (Equates to 0)
        'Timer 0 starts automatically on a Microchip PIC microcontroller, therefore, StartTimer is not required.
        InitTimer0 Osc, PS0_2

    End Sub

    'PWM sub
    'This will be called when Timer 0 overflows
    Sub PWMHandler
        If MotorSpeed &gt; PWMCounter Then
            Set MOTOR On
        Else
            Set MOTOR Off
        End If
        PWMCounter += 1
        If PWMCounter = 100 Then PWMCounter = 0
    End Sub</screen>
<simpara><emphasis role="strong">Example 1 for 18-bit timer 0 operating an 8-bit timer:</emphasis></simpara>
<simpara>The same example for a 16-bit timer 0 operating as an 8-bit timer.</simpara>
<screen>#chip 16f18855,32
#option Explicit
'timer test Program

dim speed, MotorSpeed, PWMCounter as byte

#define MOTOR PORTb.0
dir MOTOR out

'Call the initialisation routine
InitMotorControl

'Main routine
Do
    'Increase speed to full over 2.5 seconds
    For Speed = 0 to 100
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
    'Decrease speed to zero over 2.5 seconds
    For Speed = 100 to 0
        MotorSpeed = Speed
        Wait 25 ms
    Next
    'Hold speed
    Wait 1 s
Loop

'Setup routine
Sub InitMotorControl
    'Clear variables
    MotorSpeed = 0
    PWMCounter = 0

    'Add a handler for the interrupt
    On Interrupt Timer0Overflow Call PWMHandler

    InitTimer0(Osc, TMR0_FOSC4 + PRE0_1 , POST0_1)
    StartTimer 0

End Sub

'PWM sub
'This will be called when Timer 0 overflows
Sub PWMHandler

    If MotorSpeed &gt; PWMCounter Then
        Set MOTOR On
    Else
        Set MOTOR Off
    End If
    PWMCounter += 1
    If PWMCounter = 100 Then PWMCounter = 0

End Sub</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
<section xml:id="_inittimer0_8bit_16bit">
<title>InitTimer0 8bit/16bit</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    InitTimer0 source, prescaler, postscaler</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on microcontrollers with a Timer 0 with an 8 bit/16 bit timer module.</simpara>
<simpara>Timer 0 on Microchip PIC 18(L)F, as well as small number of 18C and 16(L)F microcontrollers,
can be configured for either 8-bit or 16-bit operation.</simpara>
<simpara>The default operation is as an 8-bit timer.</simpara>
<simpara>Refer to the datasheet for your microcontroller to determine if it supports both 8-bit and 16-bit operation.</simpara>
<simpara>See also  see: <link linkend="_inittimer0">InitTimer0</link> for microcontroller with only an 8 bit Timer 0 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer0</literal> will set up timer 0.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows to 0, a  <literal>Timer0Overflow</literal> interrupt will
be generated. This can be used in conjunction with <literal>On Interrupt</literal> to run a
section of code when the overflow occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>On Microchip PIC microcontrollers where the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 2 to 256  you should use one of the following constants.  If the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 1 to 32768 then see the subsequent table.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:256 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer0 Match (8/16-bit Timer0)</emphasis></simpara>
<simpara>On Chips with 8/16-bit Timer0, when in 8-bit mode, Timer0 behaves much like Timers2/4/6. In 8-bit mode the TMR0H register does not increment. It instead becomes the Period or Match register and is aliased as "PR0"  (Period Register 0).</simpara>
<simpara>In 8-bit mode, Timer0 does not technically overflow. Instead when TMR0L increments and matches the value in the PR0 register, TMR0L is reset to 0. The interrupt flag bit (TMR0IF) bit is then set (based upon Postscaler).</simpara>
<simpara>The default value in the PR0 "match register" is 255.  This value can be set/changed in the user program to set/change the timer period. This can be used to fine tune the timer period.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Microchip PIC microcontrollers 16bit Timer 0 support:</emphasis></simpara>
<simpara>To configure PIC Timer 0 for 16_bit operation add the following line to the source code.</simpara>
<screen>    #define TMR0_16bit</screen>
<simpara><?asciidoc-br?></simpara>
<simpara>As shown above, where Timer 0 supports 16bit you must use the following syntax:</simpara>
<screen>    InitTimer0 source, prescaler, postscaler</screen>
<simpara>An example is shown below using the Great Cow BASIC constants.  See the tables below for the constants.</simpara>
<screen>    InitTimer0 Osc, PRE0_256 + TMR0_HFINTOSC ,  POST0_2</screen>
<simpara>In this example specfic values have been passed to the method.
Great Cow BASIC supports passing specfic values to setup Timer 0.  These specfic values be obtained from the MicroChip Configurator.</simpara>
<screen>    InitTimer0 Osc, 0x91 ,  0x48      ' Where these values are specfic to the timer setup.</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Great Cow BASIC constants as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where <literal>Osc</literal> is an internal oscillator and <literal>Ext</literal> is an external oscillator.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values for Microchip PIC or the Atmel AVR microcontrollers.
You may also be required to specify one of the following clock sources.<?asciidoc-br?>
<?asciidoc-br?>
TMR0_CLC1<?asciidoc-br?>
TMR0_SOSC<?asciidoc-br?>
TMR0_LFINTOSC<?asciidoc-br?>
TMR0_HFINTOSC<?asciidoc-br?>
TMR0_FOSC4<?asciidoc-br?>
TMR0_T0CKIPPS_Inverted<?asciidoc-br?>
TMR0_T0CKIPPS_True<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara>You should use a simple addition to concatenate the prescaler with a specific clock source. For example.
<?asciidoc-br?>
<?asciidoc-br?>
<literal>PRE0_16</literal> + <literal>TMR0_HFINTOSC</literal>
<?asciidoc-br?>
 <?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>See the tables below for permitted values for Microchip.<?asciidoc-br?>
Also, refer to the specific datasheet <literal><emphasis>postcaler</emphasis></literal> values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
Microchip PIC microcontrollers where the <literal><emphasis>prescaler</emphasis></literal> rate select bits are in the range of 1 to 32768  you should use one of the following constants.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:512</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_512</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2048</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_2048</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4096</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_4096</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8192</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_8192</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16384</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_16384</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32768</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PRE0_32768</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:1 and 1:32768 of the oscillator
speed where the oscillator speed is (FOSC/4). The prescaler applies to
both the internal oscillator or the external clock.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>On Microchip PIC microcontroller that require <literal><emphasis>postscaler</emphasis></literal> is can be one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_3</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_5</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_6</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_7</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_9</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_10</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_11</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_12</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_13</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_14</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_15</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>POST0_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This code uses Timer 0 and On Interrupt to generate a Pulse Width Modulation
signal, that will allow the speed of a motor to be easily controlled.</simpara>
<screen>    #chip 16F88, 8
    #config osc = int

    #define MOTOR PORTB.0

    'Call the initialisation routine
    InitMotorControl

    'Main routine
    Do
        'Increase speed to full over 2.5 seconds
        For Speed = 0 to 100
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
        'Decrease speed to zero over 2.5 seconds
        For Speed = 100 to 0
            MotorSpeed = Speed
            Wait 25 ms
        Next
        'Hold speed
        Wait 1 s
    Loop

    'Setup routine
    Sub InitMotorControl
        'Clear variables
        MotorSpeed = 0
        PWMCounter = 0

        'Add a handler for the interrupt
        On Interrupt Timer0Overflow Call PWMHandler

        'Set up the timer using the internal oscillator with a prescaler of 1/2 (Equates to 0)
        'Timer 0 starts automatically on a Microchip PIC microcontroller, therefore, StartTimer is not required.
        InitTimer0 Osc, PS0_2

    End Sub

    'PWM sub
    'This will be called when Timer 0 overflows
    Sub PWMHandler
        If MotorSpeed &gt; PWMCounter Then
            Set MOTOR On
        Else
            Set MOTOR Off
        End If
        PWMCounter += 1
        If PWMCounter = 100 Then PWMCounter = 0
    End Sub</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
</section>
<section xml:id="_inittimer1">
<title>InitTimer1</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    InitTimer1 <emphasis>source, prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 1 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer1</literal> will set up timer 1.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara></simpara><simpara></simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series.  On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On the majority of Atmel AVR microcontrollers  <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS1_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>On Atmel AVR ATtiny15/25/45/85/216/461/861 microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:512</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_512</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2048</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_2048</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4096</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_4096</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8192</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_8192</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16384</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1_16384</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1 (Microchip):</emphasis></simpara>
<simpara>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM.</simpara>
<screen>    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 2 (Atmel AVR):</emphasis></simpara>
<simpara>This example will flash the yellow LED on an Arduino Uno (R3) once every second.</simpara>
<literallayout class="monospaced">#Chip mega328p, 16  'Using Arduino Uno R3</literallayout>
<literallayout class="monospaced">#define LED PORTB.5
Dir LED OUT</literallayout>
<literallayout class="monospaced">Inittimer1  OSC, PS_256
Starttimer 1
Settimer 1, 3200  ;Preload Timer</literallayout>
<literallayout class="monospaced">On Interrupt Timer1Overflow Call Flash_LED</literallayout>
<literallayout class="monospaced">Do
    'Wait for interrupt
loop</literallayout>
<literallayout class="monospaced">Sub Flash_LED
   Settimer 1, 3200   'Preload timer
   pulseout LED, 100 ms
End Sub</literallayout>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer2">
<title>InitTimer2</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer2 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer2 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer2 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 2 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer2 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer2 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the Great Cow BASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer2 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer2 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 2 is held in register PR2.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR2 register matches the value in the PR2 register.&#160;&#160;At this time the TMR2 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR2 register, the shorter the timer period will be.&#160;&#160;The default value for the PR2 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR2IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an optional parameter.  Please review the datasheet for specific usage.<?asciidoc-br?>
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings, if you MicroChip microcontroller has the T2CKPS4 bit then refer to table 3:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 2 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 3 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Eqautes to</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_2</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_3</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_4</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_5</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_6</simpara></entry>
<entry align="left" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_7</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_8</simpara></entry>
<entry align="left" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_9</simpara></entry>
<entry align="left" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_10</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_11</simpara></entry>
<entry align="left" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_12</simpara></entry>
<entry align="left" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_13</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_14</simpara></entry>
<entry align="left" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_15</simpara></entry>
<entry align="left" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="left" valign="top"><simpara>POST_16</simpara></entry>
<entry align="left" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 4 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:(Atmel AVR)</emphasis></simpara>
<simpara><literal>InitTimer2</literal> will set up timer 2, according to the settings given.</simpara>
<simpara><literal>source</literal> can be one of the following settings:
Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 5 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> for Atmel AVR Timer 2 is chip specific and can be selected from one of the two
tables shown below.  Please refer to the datasheet determine which table to use and which
prescales within that table are supported by a specific Atmel AVR microcontroller.</simpara>
<simpara>Table1: Prescaler Rate Select bits are in the range of 1 to 1024</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS2_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 6 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>Prescaler Rate Select bits are in the range of 1 to 16384</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_2</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_16</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_32</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_128</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:512</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_512</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2048</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_2048</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4096</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_4096</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8192</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_8192</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16384</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_2_16384</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>none</literal></simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 7 shown above</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This code uses Timer 2 and On Interrupt to flash an LED every 200 timer ticks.</simpara>
<screen>    #chip 16F1788, 8
    #config OSC = INTOSC

    #DEFINE LED PORTA.1
    DIR LED OUT

    #Define Match_Val PR2 'PR2 is the timer 2 match register
    Match_Val = 200       'Interrupt afer 200 timer ticks

    On interrupt timer2Match call FlashLED  'Interrupt on match
    Inittimer2 PS2_64, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 2

    Do
      ' Wating for interrupt on match val of 100
    Loop

    'This sub will be called when Timer 2 matches "Match_Val" (PR2)
    SUB FlashLED
        pulseout LED, 5 ms
    END SUB</screen>
</section>
<section xml:id="_inittimer3">
<title>InitTimer3</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer3 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 3 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer3</literal> will set up timer 3.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS3_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On the majority of Atmel AVR microcontrollers  <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_3_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer4">
<title>InitTimer4</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer4 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer4 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer4 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 4 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer4 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer4 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the Great Cow BASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T4CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer4 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer4 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 4 is held in register PR4.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR4 register matches the value in the PR4 register.&#160;&#160;At this time the TMR4 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR4 register, the shorter the timer period will be.&#160;&#160;The default value for the PR4 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR4IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>If required by method select.
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings, if you MicroChip microcontroller has the T4CKPS4 bit then refer to table 2:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 2</emphasis></simpara>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 3</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:(Atmel AVR)</emphasis></simpara>
<simpara><literal>InitTimer4</literal> will set up timer 4, according to the settings given.</simpara>
<simpara><literal>source</literal> can be one of the following settings:
Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal> or <literal>Ext</literal> where`Osc` is an internal oscillator and <literal>Ext</literal> is an external oscillator.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> for Atmel AVR Timer 4 can be selected from the table below.</simpara>
<simpara>Prescaler Rate Select bits are in the range of 1 to 1024</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS4_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_4_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<simpara>This code uses Timer 4 and On Interrupt to generate a 1ms pulse 20 ms.</simpara>
<screen>    #chip 18F25K80, 8
    #config OSC =INTIO2

    #DEFINE PIN3 PORTA.1
    DIR PIN3 OUT

    #Define Match_Val PR4  'PR4 is the timer 2 match register
    Match_Val = 154        'Interrupt afer 154 Timer ticks (~20ms)

    On interrupt timer4Match call PulsePin3  'Interrupt on match
    Inittimer4 PS4_16, 15 'Prescale 1:64 /Postscale 1:16 (15)
    Starttimer 4

    Do
       'Waiting for interrupt on match val of 154
    Loop

    Sub PulsePin3
       pulseout Pin3, 1 ms
    End Sub</screen>
</section>
<section xml:id="_inittimer5">
<title>InitTimer5</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer5 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 5 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer5</literal> will set up timer 5.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series  On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS5_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Atmel AVR microcontrollers:</emphasis></simpara>
<simpara>On the majority of Atmel AVR microcontrollers  <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<simpara>The prescaler will only apply when the timer is driven from the <literal>Osc</literal> the internal oscillator - the prescaler has no effect when the external clock source is specified.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Secondary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:0</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_0</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_0</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_8</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_64</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:256</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_256</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_256</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:1024</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_1024</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS_5_1024</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer6">
<title>InitTimer6</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer6 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer6 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer6 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 6 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer6 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer6 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the Great Cow BASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer6 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer6 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 6 is held in register PR6.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR6 register matches the value in the PR6 register.&#160;&#160;At this time the TMR6 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR6 register, the shorter the timer period will be.&#160;&#160;The default value for the PR6 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR6IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an optional parameter.  Please review the datasheet for specific usage.<?asciidoc-br?>
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings, if you MicroChip microcontroller has the T6CKPS4 bit then refer to table 3:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 2</emphasis></simpara>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:32</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_32</literal></simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:128</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS6_128</literal></simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 3</emphasis>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_inittimer7">
<title>InitTimer7</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer7 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on  Microchip microcontrollers with a Timer 7 module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>InitTimer7</literal> will set up timer 7.</simpara>
<simpara>Parameters are required as detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>source</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The clock source for this specific timer. Can be either <literal>Osc</literal>, <literal>Ext</literal> or <literal>ExtOsc</literal> where:<?asciidoc-br?>
<literal>Osc</literal> is an internal oscillator.<?asciidoc-br?>
<literal>Ext</literal> is an external oscillator.<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?>
<?asciidoc-br?>
<literal>Osc</literal> - Selects the clock source in use, as set by the microcontroller specific configuration (fuses or #config).&#160;&#160;This could be an internal clock or an external clock source ( external clock sources are typically attached to the XTAL pins).
</simpara><simpara><literal>Ext</literal> - Selects the clock source attached to a specific exernal interrupt input port.&#160;&#160;This allows a different clock frequency than the main clock to be used, such as 32.768 kHz crystals commonly used for real time circuits.
<?asciidoc-br?>
<?asciidoc-br?>
</simpara><simpara><literal>ExtOsc</literal> is an external oscillator and only available on a Microchip PIC microcontroller.
</simpara><simpara>Enhanced Microchip PIC microcontrollers with a dedicated TMRxCLK register support additional clock sources.  This includes, but limited to,  the following devices: 16F153xx, 16F16xx, 16F188xx and 18FxxK40 Microchip PIC microcontroller  series.  On these devices the clock source can be one of the following:
</simpara><simpara><literal>Osc</literal> is an internal oscillator which is the same source as <literal>FOSC4</literal>.<?asciidoc-br?>
<literal>Ext</literal>  is an external oscillator which is the same source as <literal>TxXKIPPS</literal>.<?asciidoc-br?>
<literal>ExtOsc</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>FOSC</literal> is an internal oscillator which is the Frequency of the OSCillator.<?asciidoc-br?>
<literal>FOSC4</literal> is an internal oscillator which is the Frequency of the OSCillator divided by 4.<?asciidoc-br?>
<literal>SOSC</literal> is an external oscillator which is the same source as <literal>SOSC</literal>.<?asciidoc-br?>
<literal>MFINTOSC</literal> is an internal 500KHz internal clock oscillator.<?asciidoc-br?>
<literal>LFINTOSC</literal>  is an internal 31Khz internal clock oscillator.<?asciidoc-br?>
<literal>HFINTOSC</literal> is an oscillator as specified within the datasheet for each specific microcontroller.<?asciidoc-br?>
<literal>TxCKIPPS</literal> is an oscillator input on TxCKIPPS Pin.<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted vales for Microchip PIC or the Atmel AVR microcontrollers.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>When the timer overflows an interrupt event will be generated.
This interrupt event can be used in conjunction with <literal>On Interrupt</literal> to run a section of code when the interrupt event occurs.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Microchip PIC microcontrollers:</emphasis></simpara>
<simpara>On Microchip PIC microcontrollers <literal><emphasis>prescaler</emphasis></literal> must be one of the following constants:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_2</literal></simpara></entry>
<entry align="center" valign="top"><simpara>16</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>32</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS7_8</literal></simpara></entry>
<entry align="center" valign="top"><simpara>48</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>These correspond to a prescaler of between 1:2 and 1:8 of the oscillator (FOSC/4)
speed. The prescaler will apply to either the oscillator or the external
clock input.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_inittimer8">
<title>InitTimer8</title>
<simpara><emphasis role="strong">Syntax: (MicroChip PIC)</emphasis></simpara>
<screen>    InitTimer8 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis>

or, where you required to state the clock source, use the following

    InitTimer8 <emphasis>clocksource</emphasis>, <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Syntax: (Atmel AVR)</emphasis></simpara>
<screen>    InitTimer8 <emphasis>source</emphasis>, <emphasis>prescaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer 8 module.&#160;&#160;As shown above a Microchip microcontroller can potentially support two types of methods for initialisation.
<?asciidoc-br?>
<?asciidoc-br?>
The first method is:
<?asciidoc-br?></simpara>
<screen>    InitTimer8 prescaler, postscaler</screen>
<simpara>This the most common method to initialise a Microchip microcontroller timer.&#160;&#160;With this method the timer has only one possible clock source, this mandated by the microcontrollers architecture, and that clock source is the System Clock/4 also known as FOSC/4.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
The second method is much more flexible in term of the clock source.&#160;&#160;Microcontrollers that support this second method enable you to select different clock sources and to select more prescale values.&#160;&#160;The method is shown below:
<?asciidoc-br?></simpara>
<screen>    InitTimer8 clocksource, prescaler, postscaler</screen>
<simpara><emphasis role="strong">How do you determine which method to use for your specific Microchip microcontroller ?</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The timer type for a Microchip microcontroller can be determined by checking for the existance of a T2CLKCON register, either in the Datasheet or in the Great Cow BASIC  "dat file" for the specific device.
<?asciidoc-br?>
<?asciidoc-br?>
If the Microchip microcontroller <emphasis role="strong">DOES NOT</emphasis> have a T2CLKCON register then timers 2/4/6/8 for that specific microcontroller chip use the first method, and are configured using:
<?asciidoc-br?></simpara>
<screen>    InitTimer8 (PreScale, PostScale)</screen>
<simpara>If the microcontroller <emphasis role="strong">DOES</emphasis> have a T2CLKCON register then ALL timers 2/4/6/8 for that specific microcontroller chip use the second method, and are configured using:</simpara>
<screen>    InitTimer8 (Source,PreScale,PostScale)</screen>
<simpara>The possible Source, Prescale and Postscale constants for each type are shown in the tables below.&#160;&#160;These table are summary tables from the Microchip datasheets.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Period of the Timers</emphasis></simpara>
<simpara>The Period of the timer is determined by the system clock speed, the prescale value and 8-bit value in the respective timer period register.&#160;&#160;The timer period for timer 8 is held in register PR8.&#160;&#160;
<?asciidoc-br?></simpara>
<simpara>When the timer is enabled, by starting the timer, it will increment until the TMR8 register matches the value in the PR8 register.&#160;&#160;At this time the TMR8 register is cleared to 0 and the timer continues to increment until the next match, and so on.
<?asciidoc-br?></simpara>
<simpara>The lower the value of the PR8 register, the shorter the timer period will be.&#160;&#160;The default value for the PR8 register at power up is 255.
<?asciidoc-br?></simpara>
<simpara>The timer interrupt flag (TMR8IF) is set based upon the number of match conditions as determine by the postscaler.&#160;&#160;The postscaler does not actually change the timer period, it changes the time between interrupt conditions.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Timer constants for the MicroChip microcontrollers</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the tables below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>clocksource</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>This is an optional parameter.  Please review the datasheet for specific usage.<?asciidoc-br?>
&#160;<?asciidoc-br?>
Source can be one of the following numeric values:<?asciidoc-br?>
&#160;<?asciidoc-br?>
         1 equates to OSC (FOSC/4). &#160;&#160;&#160;The default clock source<?asciidoc-br?>
        <?asciidoc-br?>
         6 equates to EXTOSC same as SOSC<?asciidoc-br?>
         5 equates to MFINTOSC<?asciidoc-br?>
         4 equates to LFINTOSC<?asciidoc-br?>
         3 equates to HFINTOSC<?asciidoc-br?>
         2 equates to FOSC<?asciidoc-br?>
         1 equates to FOSC/4 same as OSC<?asciidoc-br?>
         0 equates to TxCKIPPS same as EXTOSC and EXT (T1CKIPPS)<?asciidoc-br?>
</simpara><simpara>Other sources may be available but can vary from microcontroller to microcontroller and these can be included manually per the specific microcontrollers datasheet.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Table 1 shown above</emphasis></simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS8_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_inittimer10">
<title>InitTimer10</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer10 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip microcontrollers with a Timer 10 module.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS10_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_inittimer12">
<title>InitTimer12</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>InitTimer12 <emphasis>prescaler</emphasis>, <emphasis>postscaler</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip microcontrollers with a Timer 12 module.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Parameters for this timer are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Parameter</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>prescaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the prescaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal><emphasis>postscaler</emphasis></literal></simpara></entry>
<entry align="left" valign="top"><simpara>The value of the postscaler for this specific timer.  See the tables below for permitted values.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal>prescaler</literal> can be one of the following settings:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Prescaler Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Primary GCB Constant</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Constant Equates<?asciidoc-br?>
to value</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_1</literal></simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_4</literal></simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_16</literal></simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:64</simpara></entry>
<entry align="left" valign="top"><simpara><literal>PS12_64</literal></simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Note that a 1:64 prescale is only avaialable on certain midrange microcontrollers.
Please refer to the datasheet to determine if a 1:64 prescale is supported by a
spectific microcontroller.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><literal><emphasis>postscaler</emphasis></literal> slows the rate of the interrupt generation (or WDT reset) from a
counter/timer by dividing it down.</simpara>
<simpara>On Microchip PIC microcontroller one of the following constants where the Postscaler Rate Select bits are in the range of 1 to 16.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="center" valign="top"><emphasis role="strong">Postcaler Value</emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">Use Numeric Constant</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="center" valign="top"><simpara>1:1 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:2 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:3 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>2</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:4 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>3</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:5 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>4</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:6 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>5</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:7 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>6</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:8 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>7</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:9 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>8</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:10 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>9</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:11 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>10</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:12 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>11</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:13 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>12</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:14 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>13</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:15 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>14</simpara></entry>
</row>
<row>
<entry align="center" valign="top"><simpara>1:16 Postscaler</simpara></entry>
<entry align="center" valign="top"><simpara>15</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section xml:id="_settimer">
<title>Settimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Settimer <emphasis>timernumber</emphasis>, <emphasis>byte_value</emphasis>

    Settimer <emphasis>timernumber</emphasis>, <emphasis>word_value</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer modules.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>Settimer</literal> will set the value of the specified timer with either byte value or a word value.
8-bit timers use a byte value. 16-bit timers use a word value.</simpara>
<simpara><literal>Settimer</literal> can be used on-the-fly, so there is no requirement to stop the timer first.</simpara>
<simpara>Refer to the datasheet for timer specific information.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example shows the operation of setting two timers - is not intended as a meaningful solution.</simpara>
<screen>    #chip 16f877a, 4
    On Interrupt Timer1Overflow call Overflowed
    Set PORTB.0 On

    InitTimer1 Osc, PS1_8
    SetTimer 1, 1
    StartTimer 1

    InitTimer2 PS2_16, PS2_16
    SetTimer 2, 255
    StartTimer 2

    'Manually set Timer2Overflow to create a second event
    'this will event will be handled by the Interrupt sub routine
    TMR2IE = 1
    end

    Sub Interrupt
      Set PORTB.2 On
      TMR2IF = 0
    End Sub

    Sub Overflowed
      Set PORTB.1 On
      TMR1IF = 0
    End Sub</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_starttimer">
<title>StartTimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    StartTimer <emphasis>TimerNo</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer module.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>StartTimer</literal> is used to start the specified timer.</simpara>
<simpara><emphasis role="strong">Timer 0:</emphasis></simpara>
<simpara>Please refer to the datasheet to determine if Timer 0 on specific Microchip PIC microcontroller
can be started and stopped with <literal>starttimer</literal> and <literal>stoptimer</literal>. If the Microchip PIC microcontroller
has a register named "T0CON"  then it supports <literal>stoptimer</literal> and <literal>starttimer</literal>.</simpara>
<simpara>On Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be started  with <literal>starttimer</literal>.<?asciidoc-br?>
On Microchip PIC baseline and midrange microcontrollers <literal>starttimer</literal> (and <literal>stoptimer</literal>) has no effect upon Timer 0.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM.</simpara>
<screen>    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_stoptimer">
<title>StopTimer</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    StopTimer <emphasis>TimerNo</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers with a Timer modules.
<emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>On the Microchip PIC 18(L)Fxxx microcontrollers Timer 0 can be stopped  with <literal>stopttimer</literal>.<?asciidoc-br?>
With respect to Timer 0 on the Microchip PIC baseline and midrage range of microcontrollers <literal>stoptimer</literal> (and <literal>starttimer</literal>) has no effect as Timer 0.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example:</emphasis></simpara>
<simpara>This example will measure that time that a switch is depressed (or on) and will write the results to the EEPROM. <?asciidoc-br?>
The example shows how to stop a timer when not in use.</simpara>
<screen>    #chip 16F819, 20
    #define Switch PORTA.0

    Dir Switch In
    DataCount = 0

    'Initilise Timer 1
    InitTimer1 Osc, PS1_8

    Dim TimerValue As Word

    Do
        ClearTimer 1
        Wait Until Switch = On
        StartTimer 1
        Wait Until Switch = Off
        StopTimer 1

        'Read the timer
        TimerValue = Timer1

        'Log the timer value
        EPWrite(DataCount, TimerValue_H)
        EPWrite(DataCount + 1, TimerValue)
        DataCount += 2
    Loop</screen>
<simpara><emphasis role="strong">Supported in &lt;TIMER.H&gt;</emphasis></simpara>
</section>
<section xml:id="_reading_timers">
<title>Reading Timers</title>
<simpara>Great Cow BASIC has the following functions to read the current timer value. They
are:</simpara>
<screen>    Timer0()
    Timer1()
    Timer2()
    Timer3()
    Timer4()
    Timer5()
    Timer6()
    Timer7()
    Timer8()
    Timer10()
    Timer12()</screen>
<simpara>Note that these functions should only be used to read the timer value.  To write the timer value, <literal>settimer</literal> should be used.</simpara>
<simpara>Not all of these functions are available on all microcontrollers. For example, if a microcontrollers has three timers, then typically only <literal>Timer0</literal>, <literal>Timer1</literal> and <literal>Timer2</literal> will be available.</simpara>
<simpara>Please refer to the datasheet for your microcontroller to determine the supported timer numbers, and if a specific timer is 8-bit or 16-bit.</simpara>
</section>
<section xml:id="_smt_timers">
<title>SMT Timers</title>
<simpara>The Signal Measurement Timer (SMT) capability is a 24-bit counter with advanced clocking and gating logic, which can be configured for measuring a variety of digital signal parameters such as pulse width, frequency and duty cycle, and the time difference between edges on two signals.&#160;&#160;</simpara>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SETSMT1PERIOD ( 4045000 )        ' 1.000s period
                                     ' a perfect internal clock would be 4000000

    SETSMT2PERIOD ( 9322401 )        ' 4.600s period

    InitSMT1(SMT_FOSC,SMTPres_1)
    InitSMT2(SMT_FOSC4,SMTPres_8)

    On Interrupt SMT1Overflow Call yourSMT1InterruptHandler
    On interrupt SMT2Overflow Call yourSMT1InterruptHandler

    StartSMT1
    StartSMT2</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on Microchip microcontrollers with the SMT timer module.</simpara>
<simpara>This command set supports the use of the SMT as a 24-bit timer only.</simpara>
<simpara>Microchip PIC Microcontrollers have either 1 or 2 Signal Measurement Timers (SMT).&#160;&#160; A 24-bit timer allows for very long timer periods/high resolution and can be quite useful for certain applications.
&#160;&#160;SMT timers support multiple clock sources and prescales.&#160;&#160; Interrupt on overflow/match is also supported.</simpara>
<simpara>SMT timers will "overflow" when the 24-bit timer value "matches"  the 24-bit period registers.</simpara>
<simpara>The timer period can be precisely adjusted/set by writing a period value to the respective period register for eact timer.</simpara>
<simpara>The maximum period is achieved by a period register value of 16,777,215.&#160;&#160;  16,777,215 is the default value at POR. &#160;&#160;The timer period is also affected by the ChipMhz, TimerSource and Timer Prescale.</simpara>
<simpara>The library supports "normal" timer operation of SMT1/SMT2.&#160;&#160; The library does not support the advanced signal measurement features.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Commands are detailed in the table below:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top">Command</entry>
<entry align="left" valign="top">Description</entry>
<entry align="left" valign="top">Example
&#160;</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>InitSMT1( Source,Presscaler )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Source can be one of the below:<?asciidoc-br?>
<literal>SMT_AT1_perclk</literal> &#160;&#160;equates to     6<?asciidoc-br?>
<literal>SMT_MFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        5         (500KHz)<?asciidoc-br?>
<literal>SMT_MFINTOSC_16</literal> equates to     4         (500Khz / 16)<?asciidoc-br?>
<literal>SMT_LFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        3         (32Khz)<?asciidoc-br?>
<literal>SMT_HFINTOSC</literal>  &#160;&#160;&#160;&#160;&#160;equates to       2<?asciidoc-br?>
<literal>SMT_FOSC4</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to           1         (FOSC/4)<?asciidoc-br?>
<literal>SMT_FOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to            0<?asciidoc-br?>
<?asciidoc-br?>
Prescaler can be one of the following:<?asciidoc-br?>
<literal>SMTPres_1</literal> equates to      1:1<?asciidoc-br?>
<literal>SMTPres_2</literal> equates to      1:2<?asciidoc-br?>
<literal>SMTPres_4</literal> equates to      1:4<?asciidoc-br?>
<literal>SMTPres_8</literal> equates to      1:8<?asciidoc-br?>
<?asciidoc-br?></simpara></entry>
<entry align="left" valign="top"><simpara><literal>InitSMT1(SMT_FOSC,SMTPres_1)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>InitSMT2( Source,Presscaler )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Source can be one of the below:<?asciidoc-br?>
<literal>SMT_AT1_perclk</literal> &#160;&#160;equates to     6<?asciidoc-br?>
<literal>SMT_MFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        5         (500KHz)<?asciidoc-br?>
<literal>SMT_MFINTOSC_16</literal> equates to     4         (500Khz / 16)<?asciidoc-br?>
<literal>SMT_LFINTOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;equates to        3         (32Khz)<?asciidoc-br?>
<literal>SMT_HFINTOSC</literal>  &#160;&#160;&#160;&#160;&#160;equates to       2<?asciidoc-br?>
<literal>SMT_FOSC4</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to           1         (FOSC/4)<?asciidoc-br?>
<literal>SMT_FOSC</literal> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;equates to            0<?asciidoc-br?>
<?asciidoc-br?>
Prescaler can be one of the following:<?asciidoc-br?>
<literal>SMTPres_1</literal> equates to      1:1<?asciidoc-br?>
<literal>SMTPres_2</literal> equates to      1:2<?asciidoc-br?>
<literal>SMTPres_4</literal> equates to      1:4<?asciidoc-br?>
<literal>SMTPres_8</literal> equates to      1:8<?asciidoc-br?>
</simpara><simpara><?asciidoc-br?></simpara></entry>
<entry align="left" valign="top"><simpara><literal>InitSMT2(SMT_FOSC4,SMTPres_8)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClearSMT1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clears the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ClearSMT1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ClearSMT</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Clears the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>ClearSMT2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT1( TimerValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT1(4045000)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT2( TimerValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT2(4045000)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StopSMT1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Stops the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>StopSMT2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StopSMT2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Stops the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StartSMT1</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Starts the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>StartSMT1</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>StartSMT2</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Starts the timer.  No parameter required.</simpara></entry>
<entry align="left" valign="top"><simpara><literal>StartSMT2</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT1Period ( PeriodValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer period to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT1PERIOD(4045000)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>SetSMT2Period ( PeriodValue )</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Sets the timer period to the specific value.  The value can be 1 to 16777215</simpara></entry>
<entry align="left" valign="top"><simpara><literal>SETSMT1PERIOD(9322401)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example 1 (Microchip Only):</emphasis></simpara>
<simpara>This example will ..</simpara>
<screen>    #Chip 16F18855, 32

    #option explicit
    #Include &lt;SMT_Timers.h&gt;
    #config CLKOUTEN_ON


      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D1 |-
      ''-----------------------------------------
      ''
      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      #define Potentiometer   PORTA.4

      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT
      DIR     Potentiometer In


     SETSMT1PERIOD ( 4045000 )        ' 1.000s periodwith the parameters of SMT_FOSC and SMTPres_1 within the clock variance of the interclock
                                      ' a perfect internal clock would be 4000000

     SETSMT1PERIOD ( 9322401 )        ' 4.600s period with the parameters of SMT_FOSC4 and SMTPres_8

     InitSMT1(SMT_FOSC,SMTPres_1)
     InitSMT2(SMT_FOSC4,SMTPres_8)


     On Interrupt SMT1Overflow Call BlinkLEDD2
     On interrupt SMT2Overflow Call BlinkLEDD3

     StartSMT1
     StartSMT2


     Do
       '// Waiting for interrupts

     LOOP


    Sub BlinkLEDD2
      LEDD2 = !LEDD2
    End SUB



    Sub BlinkLEDD3
      LEDD3 = !LEDD3
    End SUB</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Supported in &lt;SMT_Timers.h&gt;</emphasis></simpara>
</section>
</section>
<section xml:id="_variables_operations">
<title>Variables Operations</title>
<simpara>This is the Variables Operations section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_using_variables">
<title>Using Variables</title>
<simpara><emphasis role="strong">Explaination</emphasis></simpara>
<simpara>Using and accessing bytes within word and long numbers etc may be required when you are creating your solution. This can be done with some ease.</simpara>
<simpara>You can access the bytes within word and longs variables using the following as a guide using the Suffixes <literal>_H</literal>, <literal>_U</literal> and <literal>_E</literal></simpara>
<screen>    Dim workvariable as word
    workvariable = 21845
    Dim lowb as byte
    Dim highb as byte
    Dim upperb as byte
    Dim lastb as byte

    lowb = workvariable
    highb = workvariable_H
    upperb = workvariable_U
    lastb = workvariable_E</screen>
<simpara>To further explain, where</simpara>
<screen>    Dim rB as Byte
    Dim sW as Word
    Dim sW as Word</screen>
<simpara>To extract the bytes from a WORD of 16 bits use the Suffix <literal>_H</literal></simpara>
<screen>    'To use the bits 7-0 [lower byte] in the Word variable sW
    rB = sW

    'For bits 15-8 [upper byte] in the Word variable sW, use sw_H
    rB = sW_H</screen>
<simpara>To extract the bytes from a LONG of 32 bits use the Suffixes <literal>_H</literal>, <literal>_U</literal> and
<literal>_E</literal>, where</simpara>
<screen>    Dim rB as Byte
    Dim sW as Word
    Dim tL as Long

    ‘ For bits 7-0 [lowest byte #0] in Long variable tL
    rB = tL

    ‘ For bits 15-8 [lower middle byte #1] in Long variable tL
    rB = tL_H

    ‘ For bits 23-16 [upper middle byte #2] in Long variable tL
    rB = tL_U

    ‘ For bits 31-24 [highest byte #3] in Long variable tL
    rB = tL_E</screen>
<simpara>To extract nibbles from the variable <literal>rB</literal></simpara>
<screen>    lower_nibble = rB &amp; 0x0F
    upper_nibble = (rB &amp; 0xF0) / 16</screen>
</section>
<section xml:id="_more_on_setting_variables_and_constants">
<title>More on setting Variables and Constants</title>
<simpara><emphasis role="strong">Explanation</emphasis></simpara>
<simpara>Within Great Cow BASIC you can use regular variable assignments. But, you can also use C like maths assignments.</simpara>
<simpara>The following methods are also supported.</simpara>
<screen>    GLCDPrintLoc += 6
    CharCode -= 15
    CharCode++
    CharCode---</screen>
<simpara>Within Great Cow BASIC you can define binary, hexidecimal and decimal constants, see <link linkend="_constants">Constants</link>. Please note what is and what is not support with respect to assigning numbers to constants. An example program examines what is supported.</simpara>
<screen>    #chip 16F88, 4
    #config Osc = INT, MCLRE_OFF

    ' All these work
    #define Test0 b'11111111'
    #define Test1 0b11111111
    #define Test2 0B11111111
    #define Test3 255
    #define Test4 0xFF
    #define Test5 0xff
    #define Test6 0Xff

    # Proof
    dir porta Out

    porta = test0
    porta = test1
    porta = test2
    porta = test3
    porta = test4
    porta = test5
    porta = test6</screen>
<simpara>You can assigned values/numbers with all the methods shown above (for constants and variables) but please be aware that you must Use '0' not '00'. One zero equates to zero and two zeros will give you an unassigned variable.</simpara>
<simpara><emphasis role="strong">Constants:</emphasis></simpara>
<simpara>A few critical constants are defined within Great Cow BASIC , you can re-use these constants. They include:</simpara>
<screen>    #define ON 1       ' These are defined in System.h
    #define OFF 0
    #define TRUE 255
    #define FALSE 0

    #define OSC = 1    ' These are defined in TIMER.H
    #define EXT = 2    ' and, are used by InitTimer0 command
    #define EXTOSC = 3</screen>
</section>
<section xml:id="_setting_variables">
<title>Setting Variables</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>Variable</emphasis> = <emphasis>data</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal><emphasis>Variable</emphasis></literal> will be set to <literal><emphasis>data</emphasis></literal>.<?asciidoc-br?>
<literal><emphasis>data</emphasis></literal> can be either a fixed value (such as 157), another variable, or a sum.</simpara>
<simpara>All unknown byte variables are assigned Zero. A variable with the name of <emphasis role="strong">Forever</emphasis> is not defined by Great Cow BASIC and therefore defaults to the value of zero.</simpara>
<simpara>If <literal><emphasis>data</emphasis></literal> is a fixed value, it must be an integer between 0 and 255 inclusive.</simpara>
<simpara>If <literal><emphasis>data</emphasis></literal> is a calculation, then it may have any of the following operands:</simpara>
<screen>    + (add)
    - (subtract, or negate if there is no value before it)
    * (multiply)
    / (divide)
    % (modulo)
    &amp; (and)
    | (or)
    # (xor)
    ! (not)
    = (equal)
    &lt;&gt; (not equal)
    &lt; (less than)
    &gt; (greater than)
    &lt;= (less than or equal)
    &gt;= (more than or equal)</screen>
<simpara>The final six operands are for checking conditions.  They will return FALSE (0) if the condition is false, or TRUE (255) if the condition is true.</simpara>
<simpara>The <literal>And</literal>, <literal>Or</literal>, <literal>Xor</literal> and <literal>Not</literal> operators function both as bitwise and logical operators.</simpara>
<simpara>Great Cow BASIC understands order of operations. If multiple operands are present, they will be processed in this order:</simpara>
<screen>    Brackets
    Unary operations (not and negate)
    Multiply/Divide/Modulo
    Add/Subtract
    Conditional operators
    And/Or/Xor</screen>
<simpara>There are several modes in which variables can be set. Great Cow BASIC will automatically use a different mode for each calculation, depending on the type of variable being set. If a byte variable is being set, byte mode will be used; if a word variable is being set, word mode will be used. If a byte is being set but the calculation involves numbers larger than 255, word mode can be used by adding [WORD] to the start of one of the values in the calculation. This is known as casting - refer to the Variables article for more information.</simpara>
<simpara>Divide or division:  Great Cow BASIC support division.  Division can set the global system variable SysCalcTempX to the remainder of the division. However the following simple rules apply.
 . If both of the parameters of the division are constants, the compiler will do the calculation itself and use the result rather than making the microcontroller work out the same thing every time.  So, if there are two constants used, the microcontroller division routine does not get used, and SysCalcTempX does not get set.
 . If either of the parameters of the division are variables, the compiler will ensure the microcontroller do es the calculation as the result could be different every time.  So, in the this case the microcontroller division routine does get used, and SysCalcTempX is set.</simpara>
<simpara>If you prefer, you can add <literal>Let</literal> to the start of the line. It will not alter the execution of the program, but is included for those who are used to including it in other BASIC dialects.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program is to illustrate the setting of variables.
    Chipmunk = 46        'Sets the variable Chipmunk to 46
    Animal = Chipmunk    'Sets the variable Animal to the value of the variable Chipmunk
    Bear = 2 + 3 * 5     'Sets the variable Bear to the result of 2 + 3 * 5, 17.
    Sheep = (2 + 3) * 5  'Sets the variable Sheep to the result of (2 + 3) * 5, 25.
    Animal = 2 * Bear    'Sets the variable Animal to twice the value of Bear.

    LargeVar = 321       'LargeVar must be set as a word - see DIM.
    Temp = LargeVar / [WORD]5 'Note the use of [WORD] to ensure that the calculation is performed correctly</screen>
</section>
<section xml:id="_variable_lifecycle">
<title>Variable Lifecycle</title>
<simpara><emphasis role="strong">Explanation</emphasis></simpara>
<simpara>Within Great Cow BASIC you can use variables. This section details the Variable Lifecycle when using variables.</simpara>
<simpara><emphasis role="strong">Variable rules - with #Option Explicit</emphasis></simpara>
<simpara>As shown below in the rule without #Option Explicit but ALL variables MUST be defined including bytes variables.</simpara>
<simpara><emphasis role="strong">Variable rules - without #Option Explicit</emphasis></simpara>
<simpara>Scope - every variable is global from an addressing/usage point of view.</simpara>
<simpara>Once a variable is defined, and then the variable it is used the variable persists.</simpara>
<simpara>Aliasing - You can reduce memory usage by Aliasing.  Remember all variables are global so you must be careful.</simpara>
<simpara>If there are two variables with the same name, they will be placed in the same memory location. You can reuse the same variable name in two subs/functions, and you can make the variables different types, but writing to the variable in one sub will overwrite the value from the other sub, see the example below.</simpara>
<simpara>As a general guide define any shared variables near the start of the program for easier readability.</simpara>
<simpara>All variables should be initialised with a desired initialisation value.  Do not assume the initialisation value is Zero.</simpara>
<simpara>Variables local to particular subroutines are not implemented.</simpara>
<simpara><emphasis role="strong">Specific rules to spefic variable types</emphasis></simpara>
<simpara>All variables are global.  Bit variables defined in subs/function are global.</simpara>
<simpara>Byte variables do not need to be defined using the DIM statement.  See #Option Explicit above.  Just to clarify byte is default type, this means:</simpara>
<screen>    Dim MainVar As Byte is unnecessary.
    MainVar = 128    automatic defines the MainVar variable</screen>
<simpara>Bit, Word, Longs, Integers and Strings variables must be defined.</simpara>
<simpara>All variables are global, but, if they are defined inside a particular subroutine then their type is not, see the example below:</simpara>
<simpara>Example code:</simpara>
<screen>    Dim MainVar As Byte
    Dim OtherVar As Word

    MainVar = 128
    OtherVar = 514

    DemoSub
    'At this point:
    'MainVar is a byte, value 128
    'OtherVar is a word, value 514
    'Counter is a byte, value 2
    '(Byte is default type, but location shared with that of Counter in DemoSub. High byte ignored)

    Sub DemoSub
        Dim Counter As Word
        Counter = 2050
        'At this point:
        'MainVar and OtherVar as byte and word, as in main routine
        'Counter is a word, value 2050
    End Sub</screen>
<simpara>In DemoSub, Counter is a word. But anywhere else in the program it is a byte unless otherwise specified.   If the variable is used/read in the main routine, it will be treated as a byte, and only the low 8 bits will be returned. In this example the low 8 bits of 2050 are 2.</simpara>
<simpara>The main reason for keeping the type inside the subroutine was for the following scenario:
A subroutine uses a temporary variable of type byte, and relies on it overflowing.</simpara>
<simpara>Another subroutine uses a temporary variable of the same name, but of word type.</simpara>
<simpara>If the first subroutine is already in the program, and then the second one is added, the behaviour of the first one will not change at all due to the addition of the second one.</simpara>
<simpara>The handling of variable types using this method minimises the size of the generated assembly code.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="__option_explicit">Option Explicit</link></simpara>
</section>
<section xml:id="_dim">
<title>Dim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis role="strong"><emphasis>For Variables &gt; 1 byte:</emphasis></emphasis>
    Dim <emphasis>variable</emphasis>[, <emphasis>variable2</emphasis> [, <emphasis>variable3</emphasis> ]] [As <emphasis>type</emphasis> ] [Alias <emphasis>othervar</emphasis> [, <emphasis>othervar2</emphasis> ]] [At <emphasis>location</emphasis> ]

    <emphasis role="strong"><emphasis>For Arrays:</emphasis></emphasis>
    Dim <emphasis>array</emphasis>(<emphasis>size</emphasis>) [At <emphasis>location</emphasis>]</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Dim has two uses, both of which involve large variables. It can be used to define arrays, bit variables and all variables larger than 1 byte.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>The <literal>Dim</literal> variable command is used to inform Great Cow BASIC of variables that are larger than 1 byte, or to create alternate names for other variables.</simpara>
<simpara>The <literal>Dim array</literal> command also sets up array variables. The maximum array size is determined by the parameter <literal><emphasis>size</emphasis></literal> is dynamically allocated by the compiler and depends on the specific chip used, as well as the complexity of the program.</simpara>
<simpara>The limit on array size varies dependent on the chip type. The 12F/16F series of chips the array limit is 80 elements. For the Atmel AVR or an 18F there is no limit other than free RAM however Great Cow BASIC limits the array size to 10,000 elements. If a memory limit is reached, the compiler will give an error message.</simpara>
<simpara><literal><emphasis>type</emphasis></literal> specifies the type of variable that is to be created. Different variable types can hold values over different ranges, and use different amounts of RAM. See the <link linkend="_variables">Variables</link> article for more information.</simpara>
<simpara>When multiple variables are included on the one line, Great Cow BASIC will set them all to the type that is specified at the end of the line. If there is no type specified, then Great Cow BASIC will make the variable a byte.</simpara>
<simpara><literal>Alias</literal> creates a variable using the same memory location as one or more other variables. It is mainly used internally in Great Cow BASIC to treat system variables as a word. For example, this command is used to create a word variable, made up from the two memory locations used to store the result of an A/D conversion:</simpara>
<simpara>A variable can be placed at a specific location in the data memory of the chip using the At option. <literal><emphasis>location</emphasis></literal> will be used whether it is a valid location or not, but a warning will be generated if Great Cow BASIC has already allocated the memory, or if the memory does not appear to be valid. This can be used for peripherals that have multi byte buffers in RAM.</simpara>
<screen>    Dim ADResult As Word Alias ADRESH, ADRESL</screen>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will set up an array, and a word variable

    dim DataList(10)
    dim Reading as word

    Reading = 21978
    DataList(1) = 15

    dim stringvariable as string</screen>
<simpara><emphasis role="strong">For more help, see:</emphasis><link linkend="_serprint">SerPrint</link> articles as these articales show how to use Dim to create string variables and <link linkend="_variables">Variables</link> for more details in creating and managing strings lengths.</simpara>
</section>
<section xml:id="_bcdtodec_gcb">
<title>BcdToDec_GCB</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    BcdToDec_GCB ( ByteVariable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>Support Bytes only.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Converts numbers from Binary Coded Decimal format to decimal.</simpara>
<simpara>You can add this function. Just add this to your Great Cow BASIC program and then call it when you need it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    Function BcdToDec(va) as byte
        BcdToDec=(va/16)*10+va%16
    End Function</screen>
<simpara><emphasis role="strong">Also see</emphasis> <link linkend="_dectobcd_gcb">DecToBcd_GCB</link></simpara>
</section>
<section xml:id="_dectobcd_gcb">
<title>DecToBcd_GCB</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen> DectoBcd( ByteVariable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Converts numbers from Decimal to Binary Coded Decimal format. Support Bytes only.</simpara>
<simpara>You can add this function. Just add this to your Great Cow BASIC program and then call it when you need it.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    Function DecToBcd(va) as Byte
       DecToBcd=(va/10)*16+va%10
    End Function</screen>
<simpara><emphasis role="strong">Also see</emphasis> <link linkend="_bcdtodec_gcb">BcdToDec_GCB</link></simpara>
</section>
<section xml:id="_rotate">
<title>Rotate</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Rotate <emphasis>variable</emphasis> {Left | Right} [Simple]</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Rotate</literal> command will rotate <literal><emphasis>variable</emphasis></literal> one bit in a specified direction. The bit shifted will be placed in the Carry bit of the Status register (<literal>STATUS.C</literal>). <literal>STATUS.C</literal> acts as a ninth bit of the variable that is being rotated.</simpara>
<simpara><literal><emphasis>variable</emphasis></literal> supports Bytes, Word and Long variables.</simpara>
<simpara>When a variable is <emphasis role="strong">rotated right</emphasis>, the bit in the <literal>STATUS.C</literal> location is placed into the MSB of the variable being rotated, and the LSB of the variable is placed into STATUS.C location.</simpara>
<simpara>When <emphasis role="strong">rotated left</emphasis> the opposite occurs. The MSB of the variable is shifted to the <literal>STATUS.C</literal> bit and the LSB of the variable will contain what was previously in the <literal>STATUS.C</literal> bit location.</simpara>
<simpara>This table shows the operation of the <literal>Rotate Left</literal> command</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong"><emphasis>variable</emphasis></emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">STATUS.C</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Values at start:</simpara></entry>
<entry align="left" valign="top"><simpara>b'01110011'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left</simpara></entry>
<entry align="left" valign="top"><simpara>b'11100110'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left again</simpara></entry>
<entry align="left" valign="top"><simpara>b'11001100'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left third time</simpara></entry>
<entry align="left" valign="top"><simpara>b'10011001'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>As you may notice the STATUS.C bit added a 0 to the rotation. So this will take 9 shifts left to get back to the original value.</simpara>
<simpara><emphasis role="strong">Simple option</emphasis></simpara>
<simpara>Many times you want to rotate the variable around like the STATUS.C bit wasn’t there so the MSB of the variable fills the LSB of the variable on Rotate Left or the LSB fills the MSB on Rotate Right. That is where the SIMPLE option comes in. It adds a hidden step that shifts the STATUS.C bit twice so the bit moves from one end of the variable to the other.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Command</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong"><emphasis>variable</emphasis></emphasis></entry>
<entry align="center" valign="top"><emphasis role="strong">STATUS.C</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Values at start:</simpara></entry>
<entry align="left" valign="top"><simpara>b'01110011'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left</simpara></entry>
<entry align="left" valign="top"><simpara>b'11100110'</simpara></entry>
<entry align="center" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left again</simpara></entry>
<entry align="left" valign="top"><simpara>b'11001101'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Rotate Left third time</simpara></entry>
<entry align="left" valign="top"><simpara>b'10011011'</simpara></entry>
<entry align="center" valign="top"><simpara>1</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Notes:
The carry is also called SREG bit C, or simply C flag on AVR.</simpara>
<simpara>In some cases the Status.C or C flag may already be set because of prior operations in your program.
Therefore, it may be necessary to clear the C flag before using <literal>Rotate</literal>.
Use <literal>Set C Off</literal> before using the <literal>Rotate</literal> command to clear the flag.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will use Rotate to show a chasing LED.
    '8 LEDs should be connected to PORTB, one on each pin.

    #chip 16F819, 8
    #config osc = int

    'Set port direction
    Dir PORTB Out

    'Set initial state of port (bits 0 and 4 on)
    PORTB = b'00010001'

    'Chase
    C = 0
    Do
        Rotate PORTB Right Simple
        Wait 250 ms
    Loop</screen>
</section>
<section xml:id="_set">
<title>Set</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Set <emphasis>variable.bit</emphasis> {On | Off}</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The purpose of the Set command is to turn individuals bits on and off.</simpara>
<simpara>The Set command is most useful for controlling output ports, but can also be used to set variables.</simpara>
<simpara>Often when controlling output ports, Set is used in conjunction with constants. This makes it easier to adapt the program for a new circuit later.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Blink LED sample program for Great Cow BASIC
    'Controls an LED on PORTB bit 0.

    'Set chip model and config options
    #chip 16F84A, 20

    'Set a constant to represent the output port
    #define LED PORTB.0

    'Set pin direction
    Dir LED Out

    'Main routine
    Do
        Set LED On
        Wait 1 sec
        Set LED OFF
        Wait 1 sec
    Loop</screen>
</section>
<section xml:id="_swap4">
<title>SWAP4</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SWAP4( VariableA)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>Support Bytes only.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that swaps (or exchanges) nibbles (or the 8 bits of a byte in nibbles).</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim ByteVariable as Byte

    ' Set variable to  0x12
    ByteVariable = 0x12

    ByteVariable = Swap4( ByteVariable )

    HSerPrint hex(ByteVariable)

    ' Would return 0x21</screen>
</section>
<section xml:id="_swap">
<title>SWAP</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    SWAP( VariableA, VariableB)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara>Support Bytes and Words only.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that swaps (or exchanges) one byte or word for another. SWAP support the use of byte and word variables.</simpara>
</section>
</section>
<section xml:id="_string_manipulation">
<title>String Manipulation</title>
<simpara>This is the String Manipulation section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<simpara><link linkend="_asc">Asc</link>,
<link linkend="_bytetobin">bytetobin</link>,
<link linkend="_chr">chr</link>,
<link linkend="_fill">fill</link>,
<link linkend="_hex">hex</link>,
<link linkend="_instr">instr</link>,
<link linkend="_lcase">lcase</link>,
<link linkend="_left">left</link>,
<link linkend="_leftpad">leftpad</link>,
<link linkend="_len">len</link>,
<link linkend="_mid">mid</link>,
<link linkend="_pad">pad</link>,
<link linkend="_right">right</link>,
<link linkend="_rtrim">rtrim</link>,
<link linkend="_str">str</link>,
<link linkend="_trim">trim</link>,
<link linkend="_ucase">ucase</link>,
<link linkend="_val">val</link>,
<link linkend="_wordtobin">wordtobin</link> or
<link linkend="_concatenation">concatenation</link></simpara>
<section xml:id="_asc">
<title>Asc</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    byte<emphasis>var</emphasis>= ASC(string, [position] )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Returns the character code of the character at the specified position in a string.</simpara>
<simpara><literal>ASC</literal> returns the character code of a particular character in the string.  If the string is an ANSI string, the returned value will be in the range of 0 to 255. This function DOES NOT support UNICODE.</simpara>
<simpara>The optional position parameter determines which character is to be checked. The first character is one, the second two, etc. If the position parameter is missing, the first character is presumed.</simpara>
<simpara><literal>CHR</literal> is the natural complement of <literal>ASC</literal>. <literal>CHR</literal> produces a one-character string corresponding to its ASCII.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>If the string passed is null (zero-length) or the position is zero or greater than the length of the string the returned value will be 0.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    charpos = ASC( "ABCD" )     ' Returns 65

    charpos = ASC( "ABCD", 2 )  ' Returns 66</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_chr">Chr</link></simpara>
</section>
<section xml:id="_bytetobin">
<title>ByteToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = ByteToBin(<emphasis>bytevar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>ByteToBin</literal> function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Supports BYTE variables only.  For WORD variables use <literal>WordToBin</literal></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    string = ByteToBin( 1 )   ' Returns "00000001"

    string = ByteToBin( 254 ) ' Returns "11111110"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_wordtobin">WordToBin</link></simpara>
</section>
<section xml:id="_chr">
<title>Chr</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = CHR(<emphasis>bytevar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>CHR</literal> function creates a string of a ANSI (1-byte) character.</simpara>
<simpara><literal>ASC</literal> is the natural complement of <literal>CHR</literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    <emphasis>string</emphasis> = CHR( 65 )   ' Returns "A"

    <emphasis>string</emphasis> = CHR( 66 )   ' Returns "B"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_asc">Asc</link></simpara>
</section>
<section xml:id="_fill">
<title>Fill</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> =  Fill ( byte_value_of_the_new_length , pad_character )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The Fill function is used to create string to a specific length that is of a specific character.</simpara>
<simpara>The length of the string is specified by the first parameter.
The character used to pad the string is specified by the second parameter, this parameter is optional as the " "(space) character is assumed.</simpara>
<simpara>A typical use is to fill a string to be displayed on an LCD or serial terminal.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F886


    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
   #define USART_TX_BLOCKING



    HserPrint Fill ( 16, "<emphasis role="strong">" ) ;will print a string of '<emphasis role="strong"></emphasis></emphasis><emphasis role="strong"><emphasis role="strong"></emphasis><emphasis role="strong"></emphasis></emphasis>*'
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_asc">Asc</link></simpara>
</section>
<section xml:id="_hex">
<title>Hex</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = Hex(<emphasis>number</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Hex</literal> function will convert a number into hexadecimal format. The input <literal><emphasis>number</emphasis></literal> should be a byte variable, or a fixed number between 0 and 255 inclusive. After running the function, the string variable <literal><emphasis>stringvar</emphasis></literal> will contain a 2 digit hexadecimal number.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Send EEPROM data over serial connection
    'Uses Hex to display as hexadecimal
    For CurrentLocation = 0 to 255
        'Send location
        HSerPrint Hex(CurrentLocation)
        HSerPrint ":"
        'Read byte and send
        EPRead CurrentLocation, CurrByte
        HSerPrint Hex(CurrByte)
        'Send carriage return/line feed
        HSerPrintCRLF
    Next</screen>
<simpara>When using the functions <literal>Hex()</literal> do not leave space between the function call and the left brace. You will get a compiler error that is meaningless.</simpara>
<screen>    ' use this, note this is no space between the Hex and the left brace!
    Hex(number_variable)
    ' do not use, note the space!
    Hex (number_variable)</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_str">Str</link>, <link linkend="_val">Val</link></simpara>
</section>
<section xml:id="_instr">
<title>Instr</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>location</emphasis> = Instr(<emphasis>source</emphasis>, <emphasis>find</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Instr</literal> function will search one string to find the location of another string within it. <literal><emphasis>source</emphasis></literal> is the string to search inside, and <literal><emphasis>find</emphasis></literal> is the string to find. The function will return the location of <literal><emphasis>find</emphasis></literal> within <literal><emphasis>source</emphasis></literal>, or 0 if <literal><emphasis>source</emphasis></literal> does not contain <literal><emphasis>find</emphasis></literal>.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the location of "world" within the string
    'Will return 8, because "w" in world is the 8th character
    'of "Hello, world!"
    HSerPrint Instr(TestData, "world")
    HSerPrintCRLF

    'Display the location of "planet" within the string
    'Will display 0, because "planet" does not occur inside
    'the string "Hello, world!"
    HSerPrint Instr(TestData, "planet")
    HSerPrintCRLF</screen>
</section>
<section xml:id="_lcase">
<title>LCase</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = LCase(<emphasis>source</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>LCase</literal> function will convert all of the letters in the string <literal><emphasis>source</emphasis></literal> to lower case, and return the result.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in lower case
    'Will display "hello, world!"
    HSerPrint LCase(TestData)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_ucase">UCase</link></simpara>
</section>
<section xml:id="_left">
<title>Left</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = Left(<emphasis>source</emphasis>, <emphasis>count</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Left</literal> function will extract the leftmost <literal><emphasis>count</emphasis></literal> characters from the input string <literal><emphasis>source</emphasis></literal>, and return them in a new string.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the leftmost 5 characters
    'Will display "Hello"
    HSerPrint Left(TestData, 5)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_mid">Mid</link>, <link linkend="_right">Right</link></simpara>
</section>
<section xml:id="_leftpad">
<title>LeftPad</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LeftPad(<emphasis>string_variable</emphasis>,<emphasis>byte_value_of_the_new_length</emphasis>,<emphasis>pad_character</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The LeftPad function is used to create string to a specific length that is extended with a specific character to the left hand side of the string.</simpara>
<simpara>The length of the string is specified by the second parameter.</simpara>
<simpara>The character used to pad the string is specified by the third parameter.</simpara>
<simpara>A typical use is to pad a string to be displayed on a serial terminal or LCD.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 18F2520, 8


    DIR PORTA 0x03


    ' make port C as output
    Dir PortC 0x0


    'Defines (Constants)
    #define LCD_SPEED fast
    #define LCD_IO 4
    #define LCD_NO_RW
    #define LCD_Enable PORTc.0
    #define LCD_RS PORTc.1
    #define LCD_DB4 PORTa.5
    #define LCD_DB5 PORTa.4
    #define LCD_DB6 PORTa.3
    #define LCD_DB7 PORTa.2
    '''--------------------------------------------
    '''-------End of board-specific settings-------
    '''--------------------------------------------


    '''DEMO for padding strings left with
    '''1st character of a given string.
    '''if no string is given, blanks are used


    ; ---- variables
    DIM inString as string * 5
    DIM outString1 as String
    DIM outString2 as String

    ; ---- main body of program begins here

    inString = "12345"

    outString1 = PADleft(inString, 9, "*#o")
    outString2 = PADleft(inString, 9)

    'show results on LCD-Display
    cls

    print instring
    print " "
    print outstring1
    locate 1,0
    print instring
    print " "
    print outstring2

    end</screen>
</section>
<section xml:id="_len">
<title>Len</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis>= Len( string )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Len</literal> function returns an byte value which is the length of a phrase or a sentence, including the empty spaces. The format is:</simpara>
<screen>    target_byte_variable = Len("Phrase")</screen>
<simpara>or another example. This code will loop through the for-next loop 12 times as determined by the length of the string:<?asciidoc-br?></simpara>
<screen>    ' create a test string of 12 characters
    dim teststring as string * 12

    teststring = "0123456789AB"
    for loopthrustring = 1 to len(teststring)
       hserprint mid(teststring, loopthrustring , 1)
    next</screen>
</section>
<section xml:id="_ltrim">
<title>Ltrim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = LTRIM(<emphasis>stringvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Ltrim</literal> function will trim the 7-bit ASCII space character (value 32) from the LEFT hand side of a string.</simpara>
<simpara>Use <literal>Ltrim</literal> on text that you have received from another source that may have irregular spacing at the left hand end of the string.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_trim">Trim</link>, <link linkend="_rtrim">Rtrim</link></simpara>
</section>
<section xml:id="_mid">
<title>Mid</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = Mid(<emphasis>source</emphasis>, <emphasis>start</emphasis>, <emphasis>count</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Mid</literal> function is used to extract characters from the middle of a string variable. <literal><emphasis>source</emphasis></literal> is the variable to extract from, <literal><emphasis>start</emphasis></literal> is the position of the first character to extract, and <literal><emphasis>count</emphasis></literal> is the number of characters to extract. If <literal><emphasis>count</emphasis></literal> is not specified, all characters from <literal><emphasis>start</emphasis></literal> to the end of the source string will be returned.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "The cat sat on the mat"

    'Extract "cat". The c is at position 5, and 3 letters are needed
    HSerPrint "The animal is a "
    HSerPrint Mid(TestData, 5, 3)

    'Extract the action. "sat" starts at position 9.
    HSerPrint "The animal "
    HSerPrint Mid(TestData, 9)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_left">Left</link>, <link linkend="_right">Right</link></simpara>
</section>
<section xml:id="_pad">
<title>Pad</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    out_string = Pad( <emphasis>string_variable</emphasis>, <emphasis>byte_value_of_the_new_length</emphasis>, <emphasis>pad_character</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Pad</literal> function is used to create string to a specific length that is extended with a specific character.</simpara>
<simpara>The length of the string is specified by the second parameter.  The character used to pad the string is specified by the third parameter.</simpara>
<simpara>A typical use is to pad a string to be displayed on a LCD display.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Defibe a string
    Dim TestData As String * 16
    TestData = "Location"

    HSerPrint TestData   ;will print a string of 8 characters
    HSerPrintCRLF
    Pad ( TestData, 16, "*" )
    HSerPrint TestData   ;will print a string of 'Location********'
HSerPrintCRLF</screen>
</section>
<section xml:id="_right">
<title>Right</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>output</emphasis> = Right(<emphasis>source</emphasis>, <emphasis>count</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Right</literal> function will extract the rightmost <literal><emphasis>count</emphasis></literal> characters from the input string <literal><emphasis>source</emphasis></literal>, and return them in a new string.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_BLOCKING

    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the rightmost 6 characters
    'Will display "world!"
    HSerPrint Right(TestData, 6)
    HSerPrintCRLF</screen>
</section>
<section xml:id="_rtrim">
<title>Rtrim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = Rtrim(<emphasis>stringvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Rtrim</literal> function will trim the 7-bit ASCII space character (value 32) from the RIGHT hand side of a string.</simpara>
<simpara>Use <literal>Rtrim</literal> on text that you have received from another source that may have irregular spacing at the right hand end of the string.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_trim">Trim</link>, <link linkend="_ltrim">Ltrim</link></simpara>
</section>
<section xml:id="_str">
<title>Str</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = Str(<emphasis>number</emphasis>)     'supports Byte and Word

    'Use the following to support Long and Integer numbers
    <emphasis>stringvar</emphasis> = Str32(<emphasis>long number</emphasis>)     'supports Long number

    <emphasis>stringvar</emphasis> = StrInteger(<emphasis>integer number</emphasis>)     'supports Integer number</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Str</literal> function will convert a number into a string. <literal><emphasis>number</emphasis></literal> can be any byte or word variable, or a fixed number between 0 and 65535 inclusive.&#160;&#160;For Long numbers use <literal>Str32</literal> and for Integer numbers use <literal>StrInteger</literal>.</simpara>
<simpara>The string variable <literal><emphasis>stringvar</emphasis></literal> will contain the same number, represented as a string.&#160;&#160;The length of the string returned is 5, 10 or 6 characters for Byte &amp; Word, Long and Integer respectively.</simpara>
<simpara>This function is especially useful if a number needs to added to the end of a string, or if a custom data sending routine has been created but only supports the output of string variables.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Take an A/D reading
    SensorReading = ReadAD(AN0)

    'Create a string variable
    Dim OutVar As String

    'Fill string with sensor reading
    OutVar = Str(SensorReading)

    'Send
    HSerPrint OutVar
    HSerPrintCRLF

    When using the functions STR() do not leave space between the function
    call and the left brace. You will get a compiler error that is
    meaningless.

    ' use this, note this is no space between the STR and the left brace!
    STR(number_variable)
    ' do not use, note the space!
    STR (number_variable)</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Example2:</emphasis></simpara>
<screen>    '''
    '''
    '''
    '''
    '''************************************************************************
    '''
    '''  PIC: 16F18855
    '''  Compiler: GCB
    '''  IDE: GCB@SYN
    '''
    '''  Board: Xpress Evaluation Board
    '''  Date: June 2016
    '''
    ' ----- Configuration
      'Chip Settings.
      #chip 16f18855,32
      #Config FEXTOSC_OFF, RSTOSC_HFINT32
      #Config WRT_OFF, CPD_ON, MCLRE_ON
      #option Explicit

    ; ----- Define Hardware settings

      '' -------------------LATA-----------------
      '' Bit#:  -7---6---5---4---3---2---1---0---
      '' LED:   ---------------|D5 |D4 |D3 |D2 |-
      ''-----------------------------------------
      ''

      'Set the PPS of the RS232 ports.
      UNLOCKPPS
        RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
      LOCKPPS

    ; ----- Constants
      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      #define LEDD2 PORTA.0
      #define LEDD3 PORTA.1
      #define LEDD4 PORTA.2
      #define LEDD5 PORTA.3
      Dir     LEDD2 OUT
      Dir     LEDD3 OUT
      Dir     LEDD4 OUT
      Dir     LEDD5 OUT


      #define Potentiometer       PORTA.4
      DIR     Potentiometer In

      #define SWITCH_DOWN         0
      #define SWITCH_UP           1
      #define SWITCH              PORTA.5
      Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long
    dim integervarP, integervarN,integervar as Integer

    ; ----- Main body of program commences here.
    bytevar = 0xff
    wordvar = 0xffff
    longvar = 0xffffffff
    integervarP = 127
    integervarN = -127
    integervar = 0

    do
       wait 100 ms

       HSerPrint str( bytevar )
       HSerPrintCRLF
       HSerPrint str( wordvar )
       HSerPrintCRLF
       HSerPrint str32( longvar )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarP )
       HSerPrintCRLF
       HSerPrint StrInteger( integervarN )
       HSerPrintCRLF
       HSerPrint StrInteger( integervar )
       HSerPrintCRLF
       wait 100 ms
       HSerPrintCRLF

       wait 1 s
    loop
    end

; ----- Support methods.  Subroutines and Functions</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">See Also</emphasis> <link linkend="_hex">Hex</link>, <link linkend="_val">Val</link></simpara>
</section>
<section xml:id="_trim">
<title>Trim</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <emphasis>stringvar</emphasis> = Trim(<emphasis>stringvar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Trim</literal> function will trim the 7-bit ASCII space character (value 32) from text.</simpara>
<simpara><literal>Trim</literal> removes all spaces from text except for single spaces between words. Use <literal>Trim</literal> on text that you have received from another source that may have irregular spacing at the left or right hand ends of the string.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_ltrim">Ltrim</link>, <link linkend="_rtrim">Rtrim</link></simpara>
</section>
<section xml:id="_ucase">
<title>UCase</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <emphasis>output</emphasis> = UCase(<emphasis>source</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>UCase</literal> function will convert all of the letters in the string <literal><emphasis>source</emphasis></literal> to upper case, and return the result.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Fill a string with a message
    Dim TestData As String
    TestData = "Hello, world!"

    'Display the string in upper case
    'Will display "HELLO, WORLD!"
    HSerPrint UCase(TestData)
    HSerPrintCRLF</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_lcase">LCase</link></simpara>
</section>
<section xml:id="_val">
<title>Val</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    var = Val(<emphasis>string</emphasis>)   'Supports Byte and Word numbers

    'use the following for strings that represent Long numbers
    var = Val32(<emphasis>string</emphasis>)   'Supports Long numbers</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Val</literal> function will extract a number from a string variable, and store it in a word variable. One potential use is reading numbers that are sent in ASCII format over a serial connection.
<?asciidoc-br?>
<?asciidoc-br?>
The <literal>Val32</literal> function will extract a long number from a string variable, and store it in a long variable.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example1:</emphasis></simpara>
<screen>    'Program for an RS232 controlled dimmer
    'Set chip model
    #chip 16F1936

    'Set up hardware serial connection
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING


    'Set pin directions for USART and PWM

    'Variable for output level
    Dim OutputLevel As Word

    'Variables for received bytes
    Dim DataIn As String
    DataInCount = 0

    'Main Loop
    Do
        'Get serial byte
        Wait Until USARTHasData
        HSerReceive InByte

        'Process latest byte
        'Enter key?
        If InByte = 13 Then
            'Convert output level to numeric variable
            OutputLevel = Val(DataIn)

            'Output
            HPWM 1, 32, OutputLevel

            'Clear output buffer for next command
            DataIn = ""
            DataInCount = 0
        End If

        'Number?
        If InByte &gt;= 48 and InByte &lt;= 57 Then
            'Add to end of DataIn string
            DataInCount += 1
            DataIn(DataInCount) = InByte
            DataIn(0) = DataInCount
        End If
    Loop</screen>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara><emphasis role="strong">Example2:</emphasis></simpara>
<screen>    ' ----- Configuration
    'Chip Settings.
    #chip 16f18855,32
    #Config FEXTOSC_OFF, RSTOSC_HFINT32
    #Config WRT_OFF, CPD_ON, MCLRE_ON

    ; ----- Define Hardware settings

    '' -------------------LATA-----------------
    '' Bit#:  -7---6---5---4---3---2---1---0---
    '' LED:   ---------------|D5 |D4 |D3 |D2 |-
    ''-----------------------------------------
    ''

    'Set the PPS of the RS232 ports.
    UNLOCKPPS
      RC0PPS = 0x0010     'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011     'RC1-&gt;EUSART:RX;
    LOCKPPS

    ; ----- Constants
    #define USART_BAUD_RATE 19200
    #define USART_TX_BLOCKING

    #define LEDD2 PORTA.0
    #define LEDD3 PORTA.1
    #define LEDD4 PORTA.2
    #define LEDD5 PORTA.3
    Dir     LEDD2 OUT
    Dir     LEDD3 OUT
    Dir     LEDD4 OUT
    Dir     LEDD5 OUT


    #define Potentiometer       PORTA.4
    DIR     Potentiometer In

    #define SWITCH_DOWN         0
    #define SWITCH_UP           1
    #define SWITCH              PORTA.5
    Dir SWITCH                  In

    ; ----- Variables
    dim bytevar as Byte
    dim wordvar as Word
    dim longvar as long

    bytevar = 0
    wordvar = 0
    longvar = 0



    ; ----- Main body of program commences here.

     #option Explicit

     do
         wait 100 ms

         bytevar = Val( "255" )
         HSerPrint bytevar
         HSerPrintCRLF

         wordvar = Val( "65535" )
         HSerPrint wordvar
         HSerPrintCRLF

         longvar = Val32( "65536" )
         HSerPrint longvar
         HSerPrintCRLF 2

         wait 1 s
      loop
    end

  ; ----- Support methods.  Subroutines and Functions</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_hex">Hex</link>, <link linkend="_str">Str</link></simpara>
</section>
<section xml:id="_wordtobin">
<title>WordToBin</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>  <emphasis>stringvar</emphasis> = WordToBin(<emphasis>bytevar</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis>
Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>WordToBin</literal> function creates a string of a ANSI (8-byte) characters.
The function converts a number to a string consisting of ones and zeros that represents the binary value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    <emphasis>string</emphasis> = WordToBin(1)       ' Returns "0000000000000001"

    <emphasis>string</emphasis> = WordToBin(37654)   ' Returns "1001001100010110"</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_bytetobin">ByteToBin</link></simpara>
</section>
<section xml:id="_concatenation">
<title>Concatenation</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>stringvar</emphasis> = variable1 + variable2</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The method joins two variables into another variable.</simpara>
<simpara>This method does not change the existing strings, but returns a new string containing the text of the joined variables.</simpara>
<simpara>Concatenation joins the elements of a specified values using the specified separator between each variable.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    timevariable = 999
    <emphasis>stringvar</emphasis> = "Time = " + timevariable ' Returns Time = 999</screen>
</section>
</section>
<section xml:id="_miscellaneous_commands">
<title>Miscellaneous Commands</title>
<simpara>This is the Miscellaneous Commands section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_dir">
<title>Dir</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Dir <emphasis>port.bit</emphasis> {In | Out}               <emphasis role="strong"><emphasis>(Individual Form)</emphasis></emphasis>
    Dir <emphasis>port</emphasis> {In | Out | <emphasis>DirectionByte</emphasis>}  <emphasis role="strong"><emphasis>(Entire Port Form)</emphasis></emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Dir</literal> command is used to set the direction of the ports of the microcontroller chip. The individual form sets the direction of one pin at a time, whereas the entire port form will set all bits in a port.</simpara>
<simpara>In the individual form, specify the port and bit (ie. <literal>PORTB.4</literal>), then the direction, which is either In or Out.</simpara>
<simpara>The entire port form is similiar to the <literal>TRIS</literal> instruction offered by some Microchip PIC microcontrollers. To use it, give the name of the port (<emphasis>i.e.</emphasis> <literal>PORTA</literal>), and then a byte is to be written into the <literal>TRIS</literal> variable. This form of the command is for those who are familiar with the Microchip PIC microcontrollers internal architecture.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
Entire port form will work differently on Atmel AVR microcontrollers when a value other than IN or OUT is used. Atmel AVR microcontrollers use 0 to indicate in and 1 to indicate out, whereas Microchip PIC microcontrollers use 0 for out and 1 for in. When IN and OUT are used there are no compatibility issues.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program sets PORTA bits 0 and 1 to in, and the rest to out.
    'It also sets all of PORTB to output, except for B1.
    'Individual form is used for PORTA:
    DIR PORTA.0 IN
    DIR PORTA.1 IN
    DIR PORTA.2 OUT
    DIR PORTA.3 OUT
    DIR PORTA.4 OUT
    DIR PORTA.5 OUT
    DIR PORTA.6 OUT
    DIR PORTA.7 OUT
    'Entire port form used for B:
    DIR PORTB b'00000010'

    'Entire port form used for C:
    DIR PORTC IN</screen>
</section>
<section xml:id="_getuserid">
<title>GetUserID</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers that support UserIDs.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Reads the memory location and returns the ID for a specific microcontroller.</simpara>
<simpara>If the microcontroller does not support GetUSerID then the following message will be issued during compilation <literal>Warning: GetUserID not supported by this microcontroller</literal>.</simpara>
<simpara>The method reads the memory location 0x8000 + Index and returns it as a Word value, where the Index 0x00 to 0x0B as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Address</entry>
<entry align="left" valign="top">Function</entry>
<entry align="left" valign="top">Read</entry>
<entry align="left" valign="top">Write</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>8000h-8003h</simpara></entry>
<entry align="left" valign="top"><simpara>User IDs</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8006h/8005h</simpara></entry>
<entry align="left" valign="top"><simpara>Device ID/Revision ID</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8007h-800Bh</simpara></entry>
<entry align="left" valign="top"><simpara>Configuration Words 1 through 5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Refer to your particular Device Datasheet to confirm the address table</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>      #chip 16F1455
      #Config WRT_OFF, MCLRE_ON

      #include &lt;GetUserID.h&gt;

      #define USART_BAUD_RATE 19200
      #define USART_TX_BLOCKING

      'Implement ANSI escaope code for serial terminal NOT using a LCD!
      #define ESC   chr(27)
      #define CLS   HSerPrint(ESC+"[2J")
      #define HOME  HSerPrint(ESC+"[H")
      #define Print HSerPrint

      CLS
      HOME

      dim UserIDRegister as word

      For Index = 0 to 0xF
        UserIDRegister  = GetUserID(Index)
        HserPrint "80" + hex(NVIndex)
        HserPrint " : "
        HserPrint hex( UserIDRegister_H )
        HserPrint hex( UserIDRegister    )
      Next Index

    End</screen>
</section>
<section xml:id="_pot">
<title>Pot</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Pot <emphasis>pin, output</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>Pot</literal> makes it possible to measure an analog resistance with a digital port, with the addition of a small capacitor. This is the required circuit:</simpara>
<simpara><inlinemediaobject>
<imageobject>
<imagedata fileref="./images/potb1.JPG"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</inlinemediaobject></simpara>
<simpara>The command works by using the microcontroller pin to discharge the capacitor, then measuring the time taken for the capacitor to charge again through the resistor.</simpara>
<simpara>The value for the capacitor must be adjusted depending on the size of the variable resistor. The charging time needs to be approximately 2.5 ms when the resistor is at its maximum value. For a typical 50 k potentiometer or LDR, a 50 nf capacitor is required.</simpara>
<simpara>This command should be used carefully. Each time it is inserted, 20 words of program memory are used on the chip, which as a rough guide is more than 15 times the size of the Set command.</simpara>
<simpara><literal><emphasis>pin</emphasis></literal> is the port connected to the circuit. The direction of the pin will be dealt with by the <literal>Pot</literal> command.</simpara>
<simpara><literal><emphasis>output</emphasis></literal> is the name of the variable that will receive the value.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will beep whenever a shadow is detected
    'A potentiometer is used to adjust the threshold

    #chip 16F628A, 4
    #config INTOSC_OSC_NOCLKOUT

    #define ADJUST PORTB.0
    #define LDR PORTB.1
    #define SoundOut PORTB.2

    Dir SoundOut Out

    Do
        Pot ADJUST, Threshold
        Pot LDR, LightLevel
        If LightLevel &gt; Threshold Then
            Tone 1000, 100
        End If
    Loop</screen>
<simpara><emphasis role="strong">See also</emphasis>  <link xlink:href="http://ladyada.net/library/rccalc.html">ladyada.net/library/rccalc.html</link> or <link xlink:href="http://web.archive.org/web/20100818230450/http://www.cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi">cvs1.uklinux.net/cgi-bin/calculators/time_const.cgi</link>
for calculating capacitor value. These sites are not associated with Great Cow BASIC.</simpara>
</section>
<section xml:id="_pulseout">
<title>PulseOut</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseOut <emphasis>pin</emphasis>, <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseOut</literal> command will set the specified pin high, wait for the specified amount of time, and then set the pin low again. The pin is specified in the same way as it is for the Set command, and the time is the same as for the <literal>Wait</literal> command.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program flashes an LED on GPIO.0 using PulseOut
    #chip 12F629, 4
    #config INTRC_OSC_NOCLKOUT

    Dir GPIO.0 Out
    Do
        PulseOut GPIO.0, 1 sec 'Turn LED on for 1 sec
        Wait 1 sec             'Wait 1 sec with LED off
    Loop</screen>
</section>
<section xml:id="_pulseoutinv">
<title>PulseOutInv</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseOutInv <emphasis>pin,</emphasis> <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseOutInv</literal> command will set the specified pin low, wait for the specified amount of time, and then set the pin high. The pin is specified in the same way as it is for the <literal>Set</literal> command, and the time is the same as for the <literal>Wait</literal> command.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program flashes an LED on GPIO.0 using PulseOutInv
    #chip 12F629, 4
    #config INTRC_OSC_NOCLKOUT

    Dir GPIO.0 Out
    Do
        PulseOutInv GPIO.0, 1 sec     'Turn LED off for 1 sec
        Wait 1 sec                    'Wait 1 sec with LED on
    Loop</screen>
</section>
<section xml:id="_pulsein">
<title>PulseIn</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseIn <emphasis>pin</emphasis>, <emphasis>user_variable</emphasis>, <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseIn</literal> command will monitor the specified pin when the pin is high, and then measure the high time. It will store the time in the user variable.
The user variable must be a WORD if returned units are expected to be &gt; 255  (Example: Pulse is 500 ms)</simpara>
<simpara>PulseIn is not recommended for accurate measurement of microsecond pulses</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 12F629, 4
    #config INTRC_OSC_NOCLKOUT

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = Off        'Wait for next positive edge to start measuring
    Loop

    Pulsein GPIO.0, TimeResult, ms</screen>
</section>
<section xml:id="_pulseininv">
<title>PulseInInv</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    PulseInInv <emphasis>pin</emphasis>, <emphasis>user_variable</emphasis>, <emphasis>time units</emphasis></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseIn</literal> command will monitor the specified pin when the pin is low, and then measure the low time. It will store the time in the user variable.
The user variable must be a WORD if returned units are expected to be &gt; 255  (Example: Pulse is 500 ms)</simpara>
<simpara>PulseInInv is not recommended for accurate measurement of microsecond pulses.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #chip 12F629, 4
    #config INTRC_OSC_NOCLKOUT

    Dir GPIO.0 In
    Dim TimeResult as WORD

    Do while GPIO.0 = On        'Wait for next negative edge to start measuring
    Loop

    PulseinInv GPIO.0, TimeResult, ms</screen>
</section>
<section xml:id="_peek">
<title>Peek</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <emphasis>OutputVariable</emphasis> = Peek (<emphasis>location</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Peek</literal> function is used to read information from the on-chip RAM of the microcontroller.</simpara>
<simpara><literal><emphasis>location</emphasis></literal> is a word variable that gives the address to read. The exact range of valid values varies from chip to chip.</simpara>
<simpara>This command should not normally be used, as it will make the porting of code to another chip very difficult.</simpara>
<simpara><emphasis role="strong">Example #1 :</emphasis></simpara>
<screen>    'This program will read and check a value from PORTA
    'This specific peek will only work on some microcontrollers
    Temp = Peek(5)
    IF Temp.2 ON THEN SET green ON
IF Temp.2 OFF THEN SET red ON</screen>
<simpara><emphasis role="strong">Example #2</emphasis></simpara>
<screen>    ' This subroutine will toggle the pin state.
    ' You must change the parameters for your specific chip.
    ' Usage as show in examples below.
    '
    '      Toggle @PORTE, 2 ' equates to RE1.
    '      Wait 100  ms
    '      Toggle @PORTE, 2
    '      Wait 100 ms


    ' Port , Pin address in Binary
    ' Pin0 = 1
    ' Pin1 = 2
    ' Pin2 = 4
    ' Pin3 = 8
    '
    ' You can toggle any number of pins.
    ' Toggle @PORTE, 0x55
    Sub Toggle ( In DestPort As word, In DestBit )
          Poke DestPort, Peek(DestPort) xor DestBit
    End sub</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_poke">Poke</link></simpara>
</section>
<section xml:id="_poke">
<title>Poke</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    Poke(<emphasis>location</emphasis>, <emphasis>value</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Poke</literal> command is used to write information to the on-chip RAM of the microcontroller.</simpara>
<simpara><literal><emphasis>location</emphasis></literal> is a word variable that gives the address to write. The exact range of valid values varies from chip to chip.
<literal><emphasis>value</emphasis></literal> is the data to write to the location.</simpara>
<simpara>This command should not normally be used, as it will make the porting of code to another chip very difficult.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<screen>    'This program will set all of the PORTB pins high
    POKE (6, 255)</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F88

    Do Forever
        FlashPin @PORTB, 8
        Wait 1 s
    Loop

    Sub FlashPin (In DestVar As word, In DestBit)
        Poke DestVar, Peek(DestVar) Or DestBit
        Wait 1 s
        Poke DestVar, Peek(DestVar) And Not DestBit
    End Sub</screen>
<simpara>Using @ before the name of a variable (including a special function register) will give you the address of that variable, which can then be stored in a word variable and used by <literal>Peek</literal> and <literal>Poke</literal> to indirectly access the location.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_peek">Peek</link></simpara>
</section>
<section xml:id="_weak_pullups">
<title>Weak Pullups</title>
<simpara><literal>Weak pullups</literal> provide a method to within many microcontrollers such as the Atmel Atmel AVR and Microchip PIC microcontrollers to support internal/selectable pull-ups for convenience and reduced parts count.</simpara>
<simpara>If you require <literal>Weak pullups</literal> these internal pull-ups can provide a simple solution.</simpara>
<simpara>If you need your weak pull-ups to exactly control current (rare for most microcontroller applications), then you should consider 10k resistors (5V/10K = 500uA)  Why? If you review in the microcontroller data sheet, there is no resistance given for the weak pull-ups. That is because they are not weak pull-resistors they are weak pull-up consisting of what appear to be high- resistance channel pFETs.  Their channel resistance will vary with temperature and between parts; not easy to characterize.</simpara>
<simpara>The data sheet gives a current range for the internals as 50-400uA (at 5V).</simpara>
<simpara>PORTs can have an individually controlled weak internal pull-up. When set, each bit of the appropriate Microchip PIC register enables the corresponding pin pull-up. There is a master bit within a specific register bit that enables pull- ups on all pins which also have their corresponding weak pull bit set.   Also when set, there is a weak pull register bit to disable all weak pull-ups.</simpara>
<simpara>The weak pull-up is automatically turned off when the port pin is configured as an output.  The pull-ups are disabled on a Power-on Reset.</simpara>
<simpara>Each specific microcontroller has different registers/bits for this functionality.</simpara>
<simpara>You should review the datasheet for the method for a specific microcontroller.</simpara>
<simpara>The following code demonstrates how to set the weak pull-ups available on port B of an 18F25K20.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'A program to show the use of weak pulled-ups on portb.
    'Set chip model
    #chip 18F25k20,16 'at 16 MHz
    'Switch Low-Volt-Programming:
    #config LVP = Off
    #config MCLR = Off

    Set RBPU = 0 'enabling Port B pullups in general.
    SET WPUB1 = 1 'portb.1 pulled up
    Set WPUB2 = 1 'portb.2
    Set WPUB3 = 1 'portb.3
    Set WPUB4 = 1 'portb.4

    Dir Portb in
    Dir Portc out

    do
        portc.1 = portb.1 'in pin 22, out pin 12
        portc.2 = portb.2 'in pin 23, out pin 13
        portc.3 = portb.3 'in pin 24, out pin 14
        portc.4 = portb.4 'in pin 25, out pin 15

    loop 'jump back to the start of the program

    'main line ends here
    end</screen>
<simpara>Also, see I2C Slave Hardware for an example using a 16F microcontroller.</simpara>
</section>
</section>
<section xml:id="_maths">
<title>Maths</title>
<simpara>This is the Maths section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_abs">
<title>Abs</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    integer_variable = Abs( integer_variable )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Abs</literal> function will compute the absolute value of a integer number therefore in the range of -32678 to 32768.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    absolute_value = Abs( -127 )  ' Will return 127
    absolute_value = Abs( 127 )   ' Will return 127 also. :-)</screen>
</section>
<section xml:id="_average">
<title>Average</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    integer_variable = Average(<emphasis>byte_variable1</emphasis> , <emphasis>byte_variable2</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that returns the average of two numbers. This only supports byte variables.</simpara>
<simpara>Provides a very fast way to calculate the average of two 8 bit numbers.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen> average_value = Average(8,4)   ' Will return 6</screen>
</section>
<section xml:id="_difference">
<title>Difference</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    <literal>Difference ( word_variable1 , word_variable2 )</literal> or
    <literal>Difference ( byte_variable1 , byte_variable2 )</literal></screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A function that returns the difference between of two numbers. This only supports byte or word variables.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    Difference( 8 ,4 ) ' Will return 4
    Difference( 0xff01 , 0xfffa ) ' Will return 0xf9 or 249d</screen>
</section>
<section xml:id="_logarithms">
<title>Logarithms</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Great Cow BASIC support logarithmic functions through the include file &lt;maths.h&gt;.</simpara>
<simpara>These functions compute base 2, base e and base 10 logarithms accurate to 2 decimal places, +/- 0.01.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. Or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara>The input arguments are word-sized integers, 1 to 65535. Remember, logarithms are not defined for non-positive numbers. It is the calling program&#8217;s responsibility to avoid these. Output values are also word-sized.</simpara>
<simpara>Local variables consume 9 bytes, while the function parameters consume another 4 bytes, for a grand total of 13 bytes of RAM used. The lookup table takes 35 words of program memory.</simpara>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_log10">Log10</link>, <link linkend="_log2">Log2</link>, <link linkend="_loge">Loge</link></simpara>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
<section xml:id="_log2">
<title>Log2</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    returned_word_variable = Log2 ( <emphasis>word_value</emphasis> )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Log2</literal> command will return the base-2 logarithm, to 2 decimal places.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim log_value as word
    log_value = log2 ( 10 )   'return 3321 equate to 3.321</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_loge">
<title>Loge</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    returned_word_variable = Loge ( <emphasis>word_value</emphasis> )</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Loge</literal> command will return the base-e logarithm, to 2 decimal places.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim log_value as word
    log_value = loge ( 10 )</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_log10">
<title>Log10</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    returned_word_variable = Log10 (<emphasis>word_value</emphasis>)</screen>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers.</simpara>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>Log10</literal> command will return the base-10 logarithm, to 2 decimal places.</simpara>
<simpara>The values returned are fixed-point numbers, with two decimal places assumed on the right. or if you prefer, think of the values as being scaled up by 100.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    dim log_value as word
    log_value = log10 ( 10 )      'return 230 equate to 2.30</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
</section>
<section xml:id="_power">
<title>Power</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    power( base, exponent )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This function raises a base to an exponent, i.e, <literal>power(base,exponent)</literal>. Calculation powers will become large, in terms of long numbers, you must ensure the program manage numbers remain within range of the defined variables.</simpara>
<simpara>The <literal>base</literal> and <literal>exponent</literal> are Byte sized numbers in this method.<?asciidoc-br?>
The returned result is a Long.<?asciidoc-br?>
Non-negative numbers are assumed throughout.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
0 raised to 0 is meaningless and should be avoided, but, any other non-zero base raised to 0 is handled correctly.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Thomas Henry -- 5/2/2014

    ;----- Configuration

    #chip 16F88, 8              ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally
    #config osc=int             ;use internal clock
    #include &lt;maths.h&gt;          ;required maths.h

    ;----- Constants

    #define LCD_IO 4            ;4-bit mode
    #define LCD_RS PortB.2      ;pin 8 is LCD Register Select
    #define LCD_Enable PortB.3  ;pin 9 is LCD Enable
    #define LCD_DB4 PortB.4     ;DB4 on pin 10
    #define LCD_DB5 PortB.5     ;DB5 on pin 11
    #define LCD_DB6 PortB.6     ;DB6 on pin 12
    #define LCD_DB7 PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW 1         ;Ground the RW line on LCD

    ;----- Variables

    dim i, j as byte

    ;----- Program

    dir PortB out               ;all outputs to the LCD
    for i = 1 to 10             ;do all the way from
      for j = 0 to 9            ;1^0 on up to 10^9
        cls
        print i
        print "^"
        print j
        print "="
        locate 1,0
        print power(i,j)        ;here's the invocation
        wait 1 S
      next j
    next i</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_sqrt">
<title>Sqrt</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    word_variable = sqrt ( <emphasis>word</emphasis> )</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>A square root routine for Great Cow BASIC. The function only involves bit shifting, addition and subtraction, which makes it fast and efficient.</simpara>
<simpara>This method required a word variable as the input and a word variable as the output. The method will handle arguments of up to 4294.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all microcontrollers, required MATHS.H include file.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ;Demo: Show the first 100 square roots to 2 decimal places.
    ;This uses the maths.h include file.

    ;----- Configuration

    #chip 16F88, 8                  ;PIC16F88 running at 8 MHz
    #config mclr=off                ;reset handled internally
    #config osc=int                 ;use internal clock
    #include &lt;maths.h&gt;              ;required maths.h

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6 on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim length as byte
    dim i as word
    dim valStr, outStr as string

    ;----- Program

    dir PortB out       ;all outputs to the LCD

    for i = 0 to 100   ;print first 100 square roots
      cls
      print "sqrt("
      print i
      print ")="

      valStr = str(sqrt(i))         ;format decimal nicely
      length = len(valStr)

      select case length
       case 1:
          outStr = "0.00"           ;zero case
       case 3:
          outStr = left(valStr,1)+ "."+right(valStr,2)
        case 4:
          outStr = left(valStr,2)+ "."+right(valStr,2)
        case 5:
          outStr = left(valStr,3)+ "."+right(valStr,2)
      end select

      print outStr                  ;display results
      wait 2 S
    next i</screen>
<simpara><emphasis role="strong">Supported in &lt;MATHS.H&gt;</emphasis></simpara>
</section>
<section xml:id="_trigonometry_sine_cosine_and_tangent">
<title>Trigonometry Sine, Cosine and Tangent</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    byte_variable = sin( <emphasis>word_variable</emphasis> )

    byte_variable = cos( <emphasis>word_variable</emphasis> )

    byte_variable = tan( <emphasis>word_variable</emphasis> )</screen>
<simpara><emphasis role="strong">Explanation</emphasis>:</simpara>
<simpara>Great Cow BASIC supports Three Primary Trigonometric Functions</simpara>
<simpara>Great Cow BASIC supports the following functions, sin(x), cos(x), tan(x), where x is a signed integer representing an angle measured in a whole number of degrees. The output values are also integers, represented as fixed point decimal fractions.</simpara>
<simpara><emphasis role="strong">Details:</emphasis></simpara>
<simpara>The sine, cosine and tangent functions are available for your programs simply by including the header file offering the precision you need.</simpara>
<screen>    #INCLUDE &lt;TRIG2PLACES.H&gt; gives two decimal places
    #INCLUDE &lt;TRIG3PLACES.H&gt; gives three decimal places
    #INCLUDE &lt;TRIG4PLACES.H&gt; gives four decimal places</screen>
<simpara>In fixed point representation, the decimal point is assumed. For example, with two places of accuracy, sin(60) returns 87, which you would interpret as 0.87. With three places, 866 is returned, to be interpreted as 0.866, and so on. Another way of thinking of this is to consider the two-place values as scaled up by 100, the three-place values scaled up by 1000 and the four-place values scaled up by 10,000.</simpara>
<simpara>Sine and cosine are always defined, but remember that tangent fails to exist at 90 degrees, 270 degrees and all their coterminal angles. It is the responsibility of the calling program to avoid these special values.</simpara>
<simpara>Note that the tangent function is not available to four decimal places, since its value grows so rapidly, exceeding what the Integer data type can represent.</simpara>
<simpara>These routines are completely general. The input argument may be positive, negative or zero, with no restriction on the size. Further observe that lookup tables are used, so the routines are very fast, efficient and accurate.</simpara>
<simpara><emphasis role="strong">Example:_Show the trigonometric values to three decimal places.</emphasis></simpara>
<screen>    ;----- Configuration
    #chip 16F88, 8                  ;PIC16F88 running at 8 MHz
    #config mclr=off                ;reset handled internally
    #config osc=int                 ;use internal clock
    #include &lt;Trig3Places.h&gt;

    ;----- Constants

    #define LCD_IO      4           ;4-bit mode
    #define LCD_RS      PortB.2     ;pin 8 is LCD Register Select
    #define LCD_Enable  PortB.3     ;pin 9 is LCD Enable
    #define LCD_DB4     PortB.4     ;DB4 on pin 10
    #define LCD_DB5     PortB.5     ;DB5 on pin 11
    #define LCD_DB6     PortB.6     ;DB6 on pin 12
    #define LCD_DB7     PortB.7     ;DB7 on pin 13
    #define LCD_NO_RW   1           ;ground the RW line on LCD

    ;----- Variables

    dim i as integer
    dim outStr, valStr as string

    ;----- Program

    dir PortB out                   ;all outputs to the LCD

    for i = -720 to 720             ;arguments from -720 to 720
      cls
      print "sin("                  ;print the label
      print i                       ;and the argument
      print ")="                    ;and closing parenthesis
      locate 1,0
      printTrig(sin(i))             ;print value of the sine
      wait 500 mS                   ;pause to view

      cls                           ;do likewise for cosine
      print "cos("
      print i
      print ")="
      locate 1,0
      printTrig(cos(i))
      wait 500 mS                   ;pause to view
      cls                           ;do likewise for tangent
      print "tan("
      print i
      print ")="
      locate 1,0
      printTrig(tan(i))
      wait 500 mS                   ;pause to view
    next i

    sub printTrig(in value as integer)
      ;print decently formatted trig results

      outStr = ""                   ;assume positive (no sign)

      if value &lt; 0 then             ;handle negatives
        outStr = "-"                ;prefix a minus sign
        value = -1 * value          ;but work with positives
      end if

      valStr = str(value)
      length = len(valStr)
      select case length
        case 1:
          outStr = outStr + "0.00" + valStr
        case 2:
          outStr = outStr + "0.0" + valStr
        case 3:
          outStr = outStr + "0." + valStr
        case 4:
          outStr = outStr + left(valStr,1) + "." + right(valStr,3)
        case 5:
          outStr = outStr + left(valStr,2) + "." + right(valStr,3)
      end select
      print outStr
    end sub</screen>
</section>
<section xml:id="_trigonometry_atan">
<title>Trigonometry ATAN</title>
<simpara><emphasis role="strong">Syntax</emphasis>:</simpara>
<screen>    byte_variable = atan (<emphasis>x_vector</emphasis>,<emphasis>y_vector</emphasis>)</screen>
<simpara><emphasis role="strong">Explanation</emphasis>:</simpara>
<simpara>Great Cow BASIC supports Three Primary Trigonometric Functions.</simpara>
<simpara><emphasis role="strong">Details:</emphasis></simpara>
<simpara>Great Cow BASIC supports the following functions ATan( x, y) where x and y are the vectors.  The function returns a word representing the angle measured in a whole number of degrees.</simpara>
<simpara>The function also returns a global variable NegFlag with returns the quadrant of the angle.</simpara>
<literallayout class="monospaced">Quadrant 1 = 0 to 89 +
Quadrant 2 = 90 to 179 +
Quadrant 3 = 180 to 269 +
Quadrant 4 = 270 to 359 +</literallayout>
<simpara>This ATan function is a fast XY vector to integer degree algorithm developed in Jan 2011, see www.RomanBlack.com and sSee <link xlink:href="http://www.romanblack.com/integer_degree.htm">http://www.romanblack.com/integer_degree.htm</link></simpara>
<simpara>The function converts any XY values including 0 to a degree value that should be within +/- 1 degree of the accurate value without needing large slow trig functions like ArcTan() or ArcCos().</simpara>
<simpara>At least one of the X or Y values must be non-zero. This is the full version, for all 4 quadrants and will generate the angle in integer degrees from 0-360. Any values of X and Y are usable including negative values provided they are between -1456 and 1456 so the 16bit multiply does not overflow.</simpara>
</section>
</section>
<section xml:id="_peripheral_pin_select">
<title>Peripheral Pin Select</title>
<simpara>This is the Peripheral Pin Select section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_peripheral_pin_select_for_microchip_microcontrollers">
<title>Peripheral Pin Select for Microchip microcontrollers.</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>Peripheral Pin Select (PPS) enables the digital peripheral I/O pins to be changed to support mapping of external pins to different pins.</simpara>
<simpara>In older 8-bit Microchip devices, a peripheral was hard-wired to a specific pin (example: PWM1 output on pin RC5).</simpara>
<simpara>PPS allows you to choose from a number of output and input pins to connect to the digital peripheral.</simpara>
<simpara>This can be extremely useful for routing circuit boards.</simpara>
<simpara>There are cases where a change of I/O position can make a circuit board easier to route Sometimes mistakes are found too late to fix so having the option to change a pinout mapping in software rather than creating a new printed circuit board can be very helpful.</simpara>
<simpara>You <emphasis role="strong">must</emphasis> use both commands <literal>UnLockPPS</literal> and <literal>LockPPS</literal> to complete any PPS changes.
Great Cow BASIC includes these two macros to ensure this process is handled correctly.</simpara>
<simpara>Also, see <link xlink:href="http://microchip.wikidot.com/8bit:pps">http://microchip.wikidot.com/8bit:pps</link> for more information.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Please check configuration before using on an alternative microcontroller.

    #chip 16f18855,32
    #option explicit
    #config RSTOSC_HFINT32

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      LOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      UnLockPPS
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see: <link linkend="_unlockpps">UnlockPPS</link> and <link linkend="_lockpps">LockPPS</link>.</emphasis></simpara>
</section>
<section xml:id="_unlockpps">
<title>UnLockPPS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    UNLOCKPPS</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop  inadvertent changes.</simpara>
<simpara>PPS selections are unlocked by setting by the use of the <literal>UnLockPPS</literal> command.</simpara>
<simpara>Using this command will ensure the special sequence of Microchip assembler is handled correctly.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers only.</simpara>
<screen>    #chip 16f18855,32
    #option explicit
    #config RSTOSC_HFINT32

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      LOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      UnLockPPS
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see: <link linkend="_lockpps">LockPPS</link></emphasis>.</simpara>
</section>
<section xml:id="_lockpps">
<title>LockPPS</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    LOCKPSS</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Peripheral Pin Select (PPS) has an operation mode in which all input and output selections can be prevented to stop  inadvertent changes.</simpara>
<simpara>PPS selections are locked by setting by the use of the <literal>LockPPS</literal> command.</simpara>
<simpara>Using this command will ensure the special sequence of Microchip assembler is handled correctly.</simpara>
<simpara><emphasis role="strong">Command Availability:</emphasis></simpara>
<simpara>Available on all Microchip microcontrollers only.</simpara>
<screen>    #chip 16f18855,32
    #option explicit
    #config RSTOSC_HFINT32

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      LOCKPPS
        RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
        RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

        SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
        SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
        RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
        RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
      UnLockPPS
    End Sub</screen>
<simpara><emphasis role="strong">For more help, see: <link linkend="_unlockpps">UnlockPPS</link>.</emphasis></simpara>
</section>
</section>
</section>
<section xml:id="_compiler_directives">
<title>Compiler Directives</title>
<simpara>This is the Compiler Directives section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="__chip">
<title>#chip</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #chip <emphasis>model</emphasis>, <emphasis>speed</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#chip</literal> directive is used to specify the chip model and speed that Great Cow BASIC must compile for. <literal><emphasis>model</emphasis></literal> is the model of the microcontroller chip - something along the lines of "16F819". <literal><emphasis>speed</emphasis></literal> is the speed of the chip in MHz, and is required for the delay and PWM routines.</simpara>
<simpara>If <literal>speed</literal> is not present the compiler will select a frequency default frequency that should work.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>If the chip has an internal oscillator, the compiler will use that and pick the highest speed it supports.</simpara>
</listitem>
<listitem>
<simpara>If the chip does not have an internal oscillator, then Great Cow BASIC will assume that the chip is being run at its maximum possible clock speed using an external crystal.</simpara>
</listitem>
<listitem>
<simpara>If you are using an external crystal then you must specify a chip frequency.</simpara>
</listitem>
</orderedlist>
<simpara>When using an AVR, there is not need to specify "AT" before the name.</simpara>
<simpara><emphasis role="strong">Examples:</emphasis></simpara>
<screen>    #chip 12F509, 4
    #chip 18F4550, 48
    #chip 16F88, 0.125
    #chip tiny2313, 1
    #chip mega8, 16</screen>
<simpara><emphasis role="strong">Setting Other Clock frequencies:</emphasis></simpara>
<simpara>Some alternative compilers allow value of the clock speed to be set with the numerical value in Hertz (<emphasis>i.e.</emphasis> 24576000). This can be useful when using the clock frequencies other than standard frequencies.</simpara>
<simpara>Great Cow BASIC requires clock speeds to be specified in MHz, but will accept decimal points. For example, if you wanted to run a 16F1827 at 24576000 Hz, you would write the following:</simpara>
<screen>    #chip 16F1827, 24.576</screen>
</section>
<section xml:id="__config">
<title>#config</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #config <emphasis>option1</emphasis>, <emphasis>option2</emphasis>, ... , <emphasis>optionN</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#config</literal> directive is used to specify configuration options for the chip. There is a detailed explanation of <literal>#config</literal> in the Configuration section of help.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_configuration">Configuration</link></simpara>
</section>
<section xml:id="__define">
<title>#define</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #define <emphasis>Find</emphasis> <emphasis>Replace</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#define</literal> will search through the program for <literal><emphasis>Find</emphasis></literal>, and replace it with the value given for <literal><emphasis>Replace</emphasis></literal>.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_constants">Defines</link></simpara>
</section>
<section xml:id="__if">
<title>#if</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #if <emphasis>Condition</emphasis>
      ...
    #endif</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#if</literal> directive is used to prevent a section of code from compiling unless <literal><emphasis>Condition</emphasis></literal> is true.</simpara>
<simpara><literal><emphasis>Condition</emphasis></literal> has the same syntax as the condition in a normal Great Cow BASIC if command. The only difference is that it uses constants instead of variables.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'This program will pulse an adjustable number of pins on PORTB
    'The number of pins is controlled by the FlashPins constant
    #chip 16F88, 8

    'The number of pins to flash
    #define FlashPins 2

    'Initialise
    Dir PORTB Out

    'Main loop
    Do
        #if FlashPins &gt;= 1
            PulseOut PORTB.0, 250 ms
        #endif
        #if FlashPins &gt;= 2
            PulseOut PORTB.1, 250 ms
        #endif
        #if FlashPins &gt;= 3
            PulseOut PORTB.2, 250 ms
        #endif
        #if FlashPins &gt;= 4
            PulseOut PORTB.3, 250 ms
        #endif
    Loop</screen>
</section>
<section xml:id="__ifdef">
<title>#ifdef</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #ifdef <emphasis>Constant</emphasis> | <emphasis>Constant Value</emphasis> | Var(<emphasis>VariableName</emphasis>)
      ...
    #endif</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#ifdef</literal> directive is used to selectively enable sections of code.</simpara>
<simpara>There are several ways in which it can be used:</simpara>
<itemizedlist>
<listitem>
<simpara>Checking if a constant is defined<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Checking if a constant is defined and has a particular value<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Checking if a system variable exists<?asciidoc-br?></simpara>
</listitem>
<listitem>
<simpara>Checking if a system bit has been defined</simpara>
</listitem>
</itemizedlist>
<simpara>The advantage of using <literal>#ifdef</literal> rather than an equivalent series of <literal>IF</literal> statements is the amount of code that is downloaded to the chip. <literal>#ifdef</literal> controls what code is compiled and downloaded, <literal>IF</literal> controls what is run once on the chip. <literal>#ifdef</literal> should be used whenever the value of a constant is to be checked.</simpara>
<simpara>Great Cow BASIC also supports the <literal>#ifndef</literal> directive - this is the opposite of the <literal>#ifdef</literal> directive - it will remove code that <literal>#ifdef</literal> leaves, and vice versa.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
The code in the following sections will not compile, as it is missing <literal>#chip</literal> directives and <literal>Dir</literal> commands. It is intended to act as an example only.</simpara>
<simpara><emphasis role="strong">Example 1: <emphasis>Enabling code if a constant is defined</emphasis></emphasis></simpara>
<screen>    #define Blink1

    #ifdef Blink1
        PulseOut PORTB.0, 1 sec
        Wait 1 sec
    #endif
    #ifdef Blink2
        PulseOut PORTB.1, 1 sec
        Wait 1 sec
    #endif</screen>
<simpara>This code will pulse <literal>PORTB.0</literal>, but not <literal>PORTB.1</literal>. This is because <literal>Blink1</literal> has been defined, but <literal>Blink2</literal> has not. If the line was added at the start of the program, then both pins would be pulsed.</simpara>
<screen>    #define Blink2</screen>
<simpara>The value of the constant defined is not important and can be left off of the <literal>#define</literal>.</simpara>
<simpara><emphasis role="strong">Example 2: <emphasis>Enabling code if a constant is defined and has a given value</emphasis></emphasis></simpara>
<screen>    #define PinsToFlash 2

    #ifdef PinsToFlash 1,2,3
    PulseOut PORTB.0, 1 sec
    #endif
    #ifdef PinsToFlash 2,3
    PulseOut PORTB.1, 1 sec
    #endif
    #ifdef PinsToFlash 3
    PulseOut PORTB.2, 1 sec
    #endif</screen>
<simpara>This program uses a constant called PinsToFlash that controls how many lights are pulsed. <literal>PORTB.0</literal> is pulsed when <literal>PinsToFlash</literal> is equal to 1, 2 or 3, <literal>PORTB.1</literal> is pulsed when <literal>PinsToFlash</literal> equals 2 or 3, and <literal>PORTB.2</literal> is flashed when <literal>PinsToFlash</literal> is 3.</simpara>
<simpara><emphasis role="strong">Example 3: <emphasis>Enabling code if a system variable is defined</emphasis></emphasis></simpara>
<screen>    #ifdef NoVar(ANSEL)
    SET ADCON1.PCFG3 OFF
    SET ADCON1.PCFG2 ON
    SET ADCON1.PCFG1 ON
    SET ADCON1.PCFG0 OFF
    #endif
    #ifdef Var(ANSEL)
    ANSEL = 0
    #endif</screen>
<simpara>The above section of code has been copied directly from a-d.h. It is used to disable the A/D function of pins, so that they can be used as standard digital I/O ports. If <literal>ANSEL</literal> is not declared as a system variable for a particular chip, then the program uses <literal>ADCON1</literal> to control the port modes. If <literal>ANSEL</literal> is defined, then the chip is newer and its ports can be set to digital by clearing <literal>ANSEL</literal>.</simpara>
<simpara><emphasis role="strong">Example 4: <emphasis>Enabling code if a system bit is defined</emphasis></emphasis></simpara>
<simpara>Similar to above, except with <literal>Bit</literal> and <literal>NoBit</literal> in the place of <literal>Var</literal> and <literal>NoVar</literal> respectively.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_constants">Defines</link>, <link linkend="__define">#define</link></simpara>
</section>
<section xml:id="__ifndef">
<title>#ifndef</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #ifndef <emphasis>Constant</emphasis> | <emphasis>Constant Value</emphasis> | Var(<emphasis>VariableName</emphasis>)
      ...
    #endif</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#ifndef</literal> directive is used to selectively enable sections of code. It is the opposite of the <literal>#ifdef</literal> directive - it will delete code in cases where <literal>#ifdef</literal> would leave it, and will leave code where <literal>#ifdef</literal> would delete it.</simpara>
<simpara><emphasis role="strong">See</emphasis> the <link linkend="__ifdef">#ifdef</link> article for more information.</simpara>
</section>
<section xml:id="__include">
<title>#include</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #include <emphasis>filename</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#include</literal> tells Great Cow BASIC to open up another file, read all of the subroutines and constants from it, and then copy them into the current program.</simpara>
<simpara>There are two forms of include; absolute and relative.</simpara>
<simpara>Absolute is used to refer to files in the <literal>..\GreatCowBASIC\include</literal>  directory. The name of the file is specified in between &lt; and &gt; symbols. For instance, to include the file <literal>srf04.h</literal>, the directive is:</simpara>
<screen>    #include &lt;srf04.h&gt;</screen>
<simpara>Relative is used to read files in the same folder as the currently selected program. Filenames are given enclosed in quotation marks, such as where <literal>mycode.h</literal> is the name of the file that is to be read.</simpara>
<screen>    #include "mycode.h"</screen>
<simpara><emphasis role="strong">NOTES:</emphasis>
It is not essential that the include file name ends in .h - the important thing is that the name given to Great Cow BASIC is the exact name of the file to be included.</simpara>
<simpara>Those who are familiar with <literal>#include</literal> in assembly or C should bear in mind that <literal>#include</literal> in Great Cow BASIC works differently to <literal>#include</literal> in most other languages - code is not inserted at the location of the <literal>#include</literal>, but rather at the end of the current program.</simpara>
</section>
<section xml:id="__script">
<title>#script</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #script
    [<emphasis>scriptcommand1</emphasis>]
    [<emphasis>scriptcommand2</emphasis>]
     ...
    [<emphasis>scriptcommandn</emphasis>]
    #endscript</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>#script</literal> block is used to create small sections of code which Great Cow BASIC runs during compilation.
A detail explanation and example are included in the Scripts article.</simpara>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_scripts">Scripts</link></simpara>
</section>
<section xml:id="__startup">
<title>#startup</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #startup <emphasis>SubName</emphasis>  [<emphasis>priority</emphasis>]</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#startup</literal> is used in include files to automatically insert initialization routines. If a define or subroutine from the file is used in the program, then the specified subroutine will be called.</simpara>
<simpara>The <literal>priority</literal> to #startup support the setting of the priority of the subroutines for all the libraries in a project.</simpara>
<simpara>Subroutines will be called in order from smallest to largest priority number.</simpara>
<literallayout class="monospaced">InitSys has priority 80, lowlevel communication routines have the priority of 90
All other subroutines defaults to 100.</literallayout>
<simpara><emphasis role="strong">Notes:</emphasis>
Limitations on this directive are:</simpara>
<simpara><literal>startup</literal> may only occur once within a source file.</simpara>
<simpara>No parameters can be passed the the subroutine that is specificed.</simpara>
<simpara><emphasis role="strong">Example 1:</emphasis></simpara>
<simpara>This example from the hardware I2C library set the subroutine with the priority of 90.</simpara>
<screen>    #startup HIC2Init, 90</screen>
<simpara><emphasis role="strong">Example 2:</emphasis></simpara>
<simpara>This example from would be included in user code to ensure the PPS setting are set prior to use of the MSSP or USART.</simpara>
<screen>    #chip 16f18855,32
    #option explicit
    #config RSTOSC_HFINT32

    'Set the PPS of the I2C and the RS232 ports.
    #startup InitPPS, 85
    Sub InitPPS
      RC0PPS = 0x0010       'RC0-&gt;EUSART:TX;
      RXPPS  = 0x0011       'RC1-&gt;EUSART:RX;

      SSP1CLKPPS = 0x14     'RC3-&gt;MSSP1:SCL1;
      SSP1DATPPS = 0x13     'RC4-&gt;MSSP1:SDA1;
      RC3PPS = 0x15         'RC3-&gt;MSSP1:SCL1;
      RC4PPS = 0x14         'RC4-&gt;MSSP1:SDA1;
    End Sub</screen>
</section>
<section xml:id="__mem">
<title>#mem</title>
<simpara><emphasis role="strong">This directive is obsolete</emphasis>.</simpara>
<simpara>Great Cow BASIC determines the amount of memory on a chip automatically, and will ignore the <literal>#mem</literal> directive.</simpara>
<simpara>It is recommended that this directive is removed from all programs.</simpara>
</section>
<section xml:id="_other_directives">
<title>Other directives</title>
<simpara>The built-in <literal>#defines</literal> are used to support the <literal>#IFDEF</literal> command set are as follows. The table also shows which <literal>#defines</literal> are supported as string in HSerPrint, SerPrint and other string related commands.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Directive</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Description</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Output Usage</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Returns</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>ChipADC</literal></simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of A/D inputs on the current chip</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipEEprom</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of Bytes in EEPROM memmory</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipIO</literal></simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of general purpose IO pins</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipMHz</literal></simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The microcontroller clock speed</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipName</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF Only</simpara></entry>
<entry align="left" valign="top"><simpara>The microcontroller type</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipNameStr</literal></simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The microcontroller name</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipPins</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of microcontroller pins.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipRam</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The RAM size</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipFamily</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>See the table below</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ChipWords</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Number</simpara></entry>
<entry align="left" valign="top"><simpara>#IFDEF &amp; Output commands</simpara></entry>
<entry align="left" valign="top"><simpara>The number of WORDS in Flash memmory</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Var()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable</simpara></entry>
<entry align="left" valign="top"><simpara>True if a register is declared (or false if not declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>Var(register_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NoVar()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable</simpara></entry>
<entry align="left" valign="top"><simpara>True if a register is NOT declared (or false if declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>NoVar(register_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Bit()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable</simpara></entry>
<entry align="left" valign="top"><simpara>True if a bit is declared (or false if not declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>Bit(bit_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>NoBit()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable</simpara></entry>
<entry align="left" valign="top"><simpara>True if a bit is NOT declared (or false if declared) in the currently specficied microcontroller&#8217;s .dat file.
</simpara><simpara>NoBit(bit_name)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Allof()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable</simpara></entry>
<entry align="left" valign="top"><simpara>True if all defines are declared:
</simpara><simpara><literal>AllOf(define1, define2, …)</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>OneOf()</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Not applicable</simpara></entry>
<entry align="left" valign="top"><simpara>True if one of the defines is declared:
</simpara><simpara><literal>OneOf(define1, define2, …)</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
All entries stated in the [ChipData] section of a specific microcontroller data files are added to program as constants.
These entries have Chip added to the entry - so <emphasis role="strong">Pins</emphasis>=28 in the specific microcontroller data data file creates a constant with the name Chip<emphasis role="strong">Pins</emphasis> and the value 28 in the user program.
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>This table shows the ChipFamily constants mapped to the microcontroller architecture.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">ChipFamily Value</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Microcontroller Characteristics</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V0E class microcontrollers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V1E class microcontrollers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V2E class microcontrollers</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>130</simpara></entry>
<entry align="left" valign="top"><simpara>AVR core version V3E class microcontrollers but essentially the mega32u6 only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>Baseline devices. 12 Bit instruction set</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>Mid-range core devices. 14 Bit instruction set with enhanced instruction set class</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15 plus familyVariant=1</simpara></entry>
<entry align="left" valign="top"><simpara>Mid-range core devices. 14 Bit instruction set with enhanced instruction set  and with large memory capability class</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>High end core devices. 16 Bit instruction set, memory addressing architecture and an extended instruction set.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
<section xml:id="_compiler_options">
<title>Compiler Options</title>
<simpara>This is the Compiler Options section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="__option_explicit">
<title>#Option Explicit</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option explicit</screen>
<simpara>This option ensures that all variables are dimensioned in the user program.  The scope is the user code only and no other code space like .h or include files.</simpara>
<simpara><literal>#option explicit</literal> requires all variables,including bytes, in the user program to be defined.</simpara>
<simpara>Variables can be defined and not used within your user program.  Unused variables will not allocate memory.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16f877a

    'Example command
    #option explicit

    dim myuserflag as byte

    myuserflag = true</screen>
<simpara><emphasis role="strong">For more help, see</emphasis> <link linkend="_variable_lifecycle">Variable Lifecycle</link></simpara>
</section>
<section xml:id="__option_noconfig">
<title>#Option NoConfig</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option NoConfig</screen>
<simpara>This option will prevent the generated assembler from generating _Config items.</simpara>
<simpara><literal>#option NoConfig</literal> is used when using a bootloader.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16f877a

    'Example command
    #option NoConfig

    'User Code......</screen>
</section>
<section xml:id="__option_bootloader">
<title>#Option Bootloader</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option bootloader <emphasis>address</emphasis></screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara><literal>#option bootloader</literal> prevents the overwriting of any pre-loaded bootloader code, vectors, etc. below the <literal><emphasis>address</emphasis></literal> and have all Great Cow BASIC code start at <literal><emphasis>address</emphasis></literal>.</simpara>
<simpara>A bootloader is a program that stays in the microcontroller and communicates with the PC, typically through the serial interface. The bootloader receives a user program from the PC and writes it in the flash memory, then launches this program in execution. Bootloaders can only be used with those microcontrollers that can write their flash memory through software.</simpara>
<simpara>The bootloader itself must be written into the flash memory with an external programmer.</simpara>
<simpara>In order for the bootloader to be launched after each reset, a <literal>goto bootloader</literal> instruction must exist somewhere in the first 4 instructions; There are two types of bootloaders, some that require that the user reallocate the code and others that by themselves reallocate the first 4 instructions of the user program to another location and execute them when the bootloader exits.</simpara>
<simpara>The diagram below shows the architecture of a bootloader. The left hand is the operation of the instructions without a bootloader. The right hand shows the initial instruction of goto the bootoader, then, when the bootloader has initialised the execution of the start code.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/optionbootloaderb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>See <link xlink:href="https://sourceforge.net/projects/tinypicbootload/files/">example bootload software.</link></simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    #option bootloader 0x800</screen>
</section>
<section xml:id="__option_nocontextsave">
<title>#Option NoContextSave</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option NoContextSave</screen>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Interrupts can occur at almost any time, and may interrupt another command as it runs. To ensure that the interrupted command can continue properly after the interrupt, some temporary variables (the context) must be saved.
Normally Great Cow BASIC will do this automatically, but in some cases it may be necessary to prevent this. If porting some existing assembly code to Great Cow BASIC, or creating a bootloader using Great Cow BASIC that will call another program,</simpara>
<simpara><literal>NoContextSave</literal> can be used to prevent the context saving code from being added automatically.</simpara>
<simpara>Be very careful using this option - it is very easy to cause random corruption of variables. If creating your own context saving code, you may need to save several variables. These are:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>For Microchip PIC microcontrollers 12F/16F: W, STATUS, PCLATH</simpara>
</listitem>
<listitem>
<simpara>For Microchip PIC microcontrollers 12F1/16F1/18F: W, STATUS, PCLATH, PCLATU, BSR</simpara>
</listitem>
<listitem>
<simpara>For Atmel AVR microcontrollers: All 32 registers</simpara>
</listitem>
</orderedlist>
<simpara>Other variables may also need to be saved, depending on what commands are used inside the interrupt handler.   Everything that is saved will also need to be restored manually when the interrupt handler finishes.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    ' This shows an example that could be used by a bootloader to call some application code.

    ' The application code must deal with context save and restore
    ' Suppose that application code starts at location 0x100, with interrupt vector at 0x108

    'Chip model
    #chip 18F2620

    'Do not save context automatically
    #option NoContextSave

    'Main bootloader routine
    Set PORTB.0 On
    'Do other stuff to make this an actual bootloader and not a trivial example
    'Transfer control to application code
    goto 0x100

    'Interrupt routine - this will be placed at the interrupt vector
    Sub Interrupt
        'If any interrupt occurs, jump straight to application interrupt vector
        goto 0x108
    End Sub</screen>
</section>
<section xml:id="__option_nolatch">
<title>#Option NoLatch</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option nolatch</screen>
<simpara>This option disables PORTx to LATx redirection.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>The Great Cow BASIC compiler will  redirect all I/O pin writes from PORTx to LATx registers on 16F1/18F Microchip PIC microcontrollers.</simpara>
<simpara>The Microchip PIC mid-range microcontrollers use a sequence known as <emphasis role="strong">Read-Modify-Write</emphasis> (RMW) when changing an output state  (1 or 0) on a pin.  This can cause unexpected behavior under certain circumstances.</simpara>
<simpara>When your program changes the state on a specific pin, for example RB0 in PORTB, the microcontroller first <emphasis role="strong">READs</emphasis> all 8 bits of the PORTB register which represents the states of all 8 pins in PORTB (RB7-RB0).</simpara>
<simpara>The microcontroller then stores this data in the MCU. The bit associated with RB that you&#8217;ve commanded to <emphasis role="strong">MODIFY</emphasis>  is changed, and then the microcontrollers <emphasis role="strong">WRITEs</emphasis> all 8 bits (RB7- RB0) back to the PORTB register.</simpara>
<simpara>During the first reading of the PORT register, you will be reading the actual state of the physical pin.  The problem arises when an output pin is loaded in such a way that its logic state is affected by the load. Instances of such loads are LEDs without current-limiting resistors or loads with high capacitance or inductance.</simpara>
<simpara>For example, if a capacitor is attached between pin and ground, it will take a short while to charge when the pin is set to 1.  On the other hand, if the capacitor is discharged, it acts like a short circuit, forcing the pin to '0' state,  and, therefore, a read of the PORT register will return 0, even though we wrote a 1 to it.</simpara>
<simpara>Great Cow BASIC resolves this issue using the LATx register when writing to ports, rather than using PORTx registers.  Writing to a LATx register is equivalent to writing to a PORTx register, but readings from LATx registers return
the data value held in the port latch, regardless of the state of the actual pin. So, for reading use PORTx.</simpara>
<simpara><emphasis role="strong">Note:</emphasis></simpara>
<simpara>You can use the <literal>#option nolatch</literal> if problems occur with compiler redirection.</simpara>
</section>
<section xml:id="__option_volatile">
<title>#Option Volatile</title>
<simpara><emphasis role="strong">Syntax:</emphasis></simpara>
<screen>    #option volatile `bit`</screen>
<simpara>This option ensure port setting are glitch-free.</simpara>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>#option volatile bit where bit is an IO bit, like PORTB.0 appended.</simpara>
<simpara>This will cause the compiler to set the bit without any glitches when copying a value from another variable, but will increase code size slightly.</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>    'Set chip model
    #chip 16f877a

    'Example command
    #option volatile portb.0

    dir portb.0 out

    do forever

      portb.0 = !portb.0

    loop</screen>
</section>
</section>
<section xml:id="_using_assembler">
<title>Using Assembler</title>
<simpara>This is the Using Assembler section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_assembler_overview">
<title>Assembler Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>You can use microcontroller assembler code within your Great Cow BASIC code.</simpara>
<simpara>You can put the assembler code inline in with your source code. The assembler code will be passed through to the assembly file associated with your project.</simpara>
<simpara>Great Cow BASIC should recognise all of the commands in the microcontroller datasheet.</simpara>
<simpara>The commands should be in lower case, this is good practice, and have a space or tab in front of the command.</simpara>
<simpara>Even if the mnemonics are not being formatted properly, <literal>gputils/MPASM</literal> should still be capable of assembling the source code.</simpara>
<simpara>Format commands as follows:</simpara>
<simpara><emphasis role="strong">Example:</emphasis></simpara>
<screen>  btfsc STATUS,Z
  bsf PORTB,1</screen>
</section>
</section>
<section xml:id="_macros">
<title>Macros</title>
<simpara>This is the Macros section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_macros_overview">
<title>Macros Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis></simpara>
<simpara>You can use macros within your Great Cow BASIC code.</simpara>
<simpara>Macros are similar to subroutines. But during compilation, everything is inserted inline. This may increase the code size slightly, but it also reduces stack usage.</simpara>
<simpara>Parameters are handled in a similar way to how constants are handled, so there is a lot more freedom when passing things in to a macro. (Unlike subs or functions, where everything must be stored in a variable.)</simpara>
<simpara>For example, for <literal>PulseOut</literal> one parameter is a pin, and the other is a time length like "500 ms". Neither of those parameters could be stored in a variable, but passing them in as macro parameters is possible.</simpara>
<simpara><emphasis role="strong">Demonstration Program:</emphasis></simpara>
<screen>    'PulseOut Macro
    macro Pulseout (Pin, Time)
        Set Pin On
        Wait Time
        Set Pin Off
    end macro</screen>
</section>
<section xml:id="_example_macros">
<title>Example Macros</title>
<simpara>This is the Example Macros section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_measuring_a_pulse_width">
<title>Measuring a Pulse Width</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>The demomstration shows how a macro can be used to optimised code by compiling code inline.</simpara>
<simpara>When the measurement of a pulse width to sub-microsecond resolution is required for instance measuring the high or low pulse width of an incoming analog signal a comparator can be combined with a timer to provide the pulse width.</simpara>
<simpara>Microchip PIC has published a "Compiled Tips 'N Tricks Guide" that explains how to do certain tasks with Microchip PIC 8-bit microcontrollers.</simpara>
<simpara>This guide provides the steps that need to be taken to perform the task of measuring a pulse width.  The guide provides guidance on measuring a pulse width using Timer 1 and the CCP module.  This guidance was used as the basis for the Great Cow BASIC port the shown below.  The guidance was generic and in this example  polling the CCP flag bit was more convenient than using an interrupt.</simpara>
<simpara>In this demonstration shown below, a 16F1829 microcontroller operating at 32 Mhz uses the internal oscillator. The demomstration code is based on a macro that uses Timer1 and CCP4. However, any of the four CCP modules could be used, the 16F1829 microcontroller has four CCP module.</simpara>
<simpara>The timer resolution of this method uses a timer Prescaler of 1:8 and a microcontroller frequency of 32 MHz giving a pulse width resolution is 1ms.  With the timer Prescaler of 1:2 and the microcontroller frequency of 32MHz the resolution is 250 ns.</simpara>
<simpara>The accuracy is dependent upon the accuracy of the system clock, but oscilliscope measurements have show an accuracy of +- 1us from 3us to 1000us.</simpara>
<simpara>In this demonstration the following was implemented</simpara>
<itemizedlist>
<listitem>
<simpara>Using Great Cow BASIC a macro to ensure the generated assembler is inline to ensure the timing is consistent and no sub routines are called.</simpara>
</listitem>
<listitem>
<simpara>Another microcontroller was used to generate the pulses to be measured</simpara>
</listitem>
<listitem>
<simpara>A TEK THS730A oscilliscope was used to measure/verify pulse widths</simpara>
</listitem>
<listitem>
<simpara>A 4x20 LDC module with an I2C Backpack was used to display the results. However, as an alternative, a serial output<?asciidoc-br?>
to a terminal program to view the data could be used</simpara>
</listitem>
</itemizedlist>
<simpara>This demonstration could be improved by adding code to poll the TIMER1 overflow flag. IF the timer overflows, then either no
pulse was detected or the pulse was longer than allowed by the prescaler/OSC settings. In this case, return a value of zero for pulse width.</simpara>
<simpara><emphasis role="strong">Usage:</emphasis></simpara>
<simpara>To get positive pulse width use:</simpara>
<screen>    PULSE_IN</screen>
<simpara><literal>PULSE_IN</literal> returns a global word variable Pulse_Width</simpara>
<simpara><emphasis role="strong">Demonstration Program:</emphasis></simpara>
<screen>    #Chip 16F1829, 32
    #CONFIG MCLRE = OFF

    'Setup Software I2C
    #define I2C_MODE Master
    #define I2C_DATA PORTA.2
    #define I2C_CLOCK PORTC.0
    #define I2C_DISABLE_INTERRUPTS ON

    'Set up LCD
    #define LCD_IO 10
    #define LCD_SPEED FAST
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    'Note: This example can be improved by adding code to poll the 'TIMER1 overflow flag. IF the timer overflows, then either no 'pulse was detected or the pulse was longer than allowed by the 'prescaler/OSC settings. In this case, return a value of zero 'for pulse width.

    CLS
    PRINT "Pulse Width Test"
    DIM PULSE_WIDTH AS WORD
    DIR PORTC.6 IN

    'Setup timer
    'Set timer1 using PS1_2 gives 250ns resolution
    InitTimer1 OSC, PS1_8
    wait 1 s
    CLS

    'MAIN PROGRAM LOOP
    DO
      PULSE_IN    'Call the Macro to get positive pulse width.
      Locate 0,0
      PRINT Pulse_Width
      PRINT "    "
      wait 1 s
    Loop

    MACRO PULSE_IN  'Measure Pulse Width
      'Configure CCP4  to Capture rising edge
       CCP4CON = 5   'Set to 00000101
       StartTimer 1
       CCP4IF = 0

       do while CCP4IF = 0    'Wait for rising edge
       loop

       TMR1H = 0: TMR1L = 0   'Clear timer to zero
       CCP4IF = 0             'Clear flag


       'Configure CCP4 to Capture Falling Edge
       CCP4CON = 4  '00000100'

       do while CCP4IF = 0   'Wait for falling edge
       loop

       StopTimer 1            'Stop the time
       Pulse_Width = TIMER1   'Save the timer value
       CCP4IF = 0             'Clear the CCP4 flag
    End MACRO</screen>
<simpara>Also see <link linkend="_macros_overview">Macros Overview</link></simpara>
</section>
<section xml:id="_implementing_a_method_with_a_pin_name_as_a_parameter">
<title>Implementing a method with a Pin name as a parameter</title>
<simpara><emphasis role="strong">Introduction</emphasis></simpara>
<simpara>A constant such as a Pin name cannot be passed to a sub routine or a function.  This is a constraint of Great Cow BASIC.</simpara>
<simpara>A macro can be used to implement a method of passing a constant to reusable code section.</simpara>
<simpara>The example shown below implements a button press routine and takes an input port constant and prints the result on an LCD display.</simpara>
<simpara><emphasis role="strong">Note:</emphasis>
A macro will use more program memory as the macro will be compiled as inline code. Therefore, for every use of the macro will use additional program memory - the same amount of program memory for each call to the macro.</simpara>
<simpara><emphasis role="strong">Demonstration Program:</emphasis></simpara>
<screen>    #chip 16F877a, 16
    #define Button PORTC.1    ' Switch on PIN 14 via 10K pullup resistor
    DIR Button In
    wait 1 sec

    'USART settings
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING

    ;======== MAIN PROGRAM LOOP ================
    HSerPrint "Button Test"
    HSerPrintCRLF 2
    Do
       Test_button ( button )
    Loop
    ;==========================================

    Macro Test_button (Button)
       if Button = ON then
          wait 10 ms          'debounce
          ButtonCount = 0


           Do While Button = On
               Wait 10 ms
               ButtonCount += 1
           Loop


           if ButtonCount &gt; 5  then
               if ButtonCount &gt; 50 then   'Long push
                   hserprint "Long push"
               else                       'Short push
                   hserprint "Short push"
               end if
               HSerPrintCRLF
           end if
           wait 1 s
       end if
    End Macro</screen>
<simpara>Also see <link linkend="_macros_overview">Macros Overview</link></simpara>
</section>
</section>
</section>
<section xml:id="_example_programs">
<title>Example Programs</title>
<section xml:id="_flashing_leds_and_an_interrupt">
<title>Flashing LEDs and an Interrupt</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This code implements four flashing LEDs. This is based on the Microchip PIC Low Pin Count Demo Board.</simpara>
<simpara>The example program will blink the four red lights in succession. Press the Push Button Switch, labeled <emphasis role="strong">SW1</emphasis>, and the sequence of the lights will reverse. Rotate the potentiometer, labeled <emphasis role="strong">RP1</emphasis>, and the light sequence will blink at a different rate.</simpara>
<simpara>This implements an interrupt for the switch press, reads the analog port and set the LEDs.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    #chip 18F14K22, 32
    #config OSC = IRC, MCLRE_OFF

    'Works with the low count demo board

    'Set the input pin direction
        #define SwitchIn1 PORTa.3
        Dir SwitchIn1 In

    #define LedPort PORTc
        DIR PORTC OUT

    'Setup the ADC  pin direction
        Dir PORTA.0 In
        dim ADCreading as word


    'Setup the input pin direction
        #define IntPortA PORTA.1
        Dir IntPortA In

    'Variable and constants
        #define intstate as byte
        intstate = 0
        #define minwait 1

        dim ccount as byte
        dim leddir as byte

        ccount = 8
        leddir = 0

        SET PORTC = 15
        WAIT 1 S

        SET PORTC = 0

    'Setup the Interrupt
        Set IOCA.3 on
        Dir porta.3 in
        On Interrupt PORTABCHANGE Call Setir

    'Set initial LED direction
        setLedDirection

    DO FOREVER


        INTON
        ADCreading = ReadAD10(AN0)
        if ADCreading &lt; minwait then ADCreading = minwait

        'Set LEDs
        Set PortC = ccount
        wait ADCreading ms

        if leddir = 0 then
          rotate ccount left simple
          'Restart LED position
          if ccount = 16 then
              ccount = 128
          end if

        end if

        if leddir = 1 then
          rotate ccount Right simple
          'Restart LED position
          if ccount = 128 then
            ccount = 8
          end if

        end if
        'Reset interrupt - this may be been reset so set to zero so interrupt can operate.
        intstate = 0

    Loop


    'Interrupt routine.
    sub Setir

        if IntPortA  = 0 and intstate = 0 then
          intstate = 1
          wait while SwitchIn1 = 0
          setLedDirection
        end if


    end sub

    sub setLedDirection

      'Set LED values
      select case leddir

        case 0
          leddir = 1
          ccount  = 8

        case 1
          leddir = 0
          ccount = 1

        end select

    End Sub</screen>
<simpara><emphasis role="strong">See Also</emphasis> <link linkend="_interrupts">Interrupts</link>, <link linkend="_readad10">ReadAD10</link></simpara>
</section>
<section xml:id="_flashing_led_with_timing_parameters">
<title>Flashing LED with timing parameters</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This is an example of how to define a subroutine.</simpara>
<simpara>When called, this subroutine will blink an LED for the number of times and duration as determined by the input parameters.</simpara>
<simpara>The syntax of the subroutine is:</simpara>
<screen>    ' Flash_LED (numtimes, OnTime, (optional) OffTime)
    ' Where numtimes is from 1 - 255 and OnTime/OffTime is
    ' from 0 - 65535 ms. If OffTime is not entered, then
    ' OffTime = OnTime.

    Sub Flash_LED (in numtimes, in OnTime as WORD, Optional OffTime as WORD = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub</screen>
<simpara>Shown below is a working example program using a Microchip PIC 18F25K22.</simpara>
<simpara>Change Settings/PORTS as needed for other Chips.</simpara>
<simpara>Connect an LED to the LED pin via a 1K series resistor.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    #chip 18F25K22, 16
    #config OSC = INTIO67, MCLRE = OFF, XINST = OFF
    #define LED PORTC.1       'Led on PIN 14 via 1K resistor
    DIR LED OUT
    wait 1 sec

    ;======== MAIN PROGRAM LOOP ================
    Do
       Flash_LED ( 3,250 )        '3 Flashes 250 ms equal on/off time
       Wait 2 Sec
       Flash_LED ( 5,250,500 )    '5 flashes On 250 ms / off 500 ms
       Wait 2 Sec
       Flash_LED ( 10,100 )       '10 rapid flashes
       Wait 2 Sec
    Loop
    ;==========================================

    Sub Flash_LED (in numtimes, in OnTime as WORD, optional OffTime as word = OnTime)
        repeat numtimes
            set LED on
            wait OnTime ms
            set LED OFF
            wait OffTime ms
        end repeat
    End Sub</screen>
</section>
<section xml:id="_generate_accurate_pulses">
<title>Generate Accurate Pulses</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>The <literal>PulseOut</literal> Command is a reliable method for generating pulses if accuracy is not critical,
the <literal>PulseOut</literal> command uses a calculation of the clock to speed for the timing .</simpara>
<simpara>If you need better accuracy and resolution then an alternative approach is required.</simpara>
<simpara>To generate pulses in the 100 us to 2500 us range with an accuracy of +- 1us over this range is practical using the approach shown in this example.</simpara>
<simpara>This example code works on a midrange PIC16F690 operating at 8Mhz.
However, it should work on any Microchip PIC microcontroller, but may need some minor modifications.</simpara>
<simpara><emphasis role="strong">Usage:</emphasis></simpara>
<screen>    Pulse_Out_us ( word_value )</screen>
<simpara><emphasis role="strong">How It Works:</emphasis></simpara>
<simpara><literal>Timer1</literal> is loaded with a preset value based upon the variable passed to the sub routine.
The timer (<literal>Timer1</literal>) is started and the pulse pin (the output pin) is set high.
When <literal>Timer1</literal> overflows the Timer1 interrupt flag bit (<literal>TMR1IF</literal>) is set.  This causes the program to
exit a polling loop and set the pulse Pin off. Then, <literal>Timer1</literal> is stopped and <literal>TMRIF</literal> flag is cleared and the sub routine exits.</simpara>
<simpara>This method supports delays between 5 us and 65535 us and uses Timer1.</simpara>
<simpara><emphasis role="strong">Test Results:</emphasis></simpara>
<simpara>These tests were completed using a Saleae Logic Analyzer.</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top"><emphasis role="strong">Pulse setting</emphasis></entry>
<entry align="left" valign="top"><emphasis role="strong">Time Results</emphasis></entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (2500)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>2501.375 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (1000)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>1000.750 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (100)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>100. 125 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us (10)</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>10.125 us</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>Pulse_Out_us with less then 4</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Unreliable results</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;**************************************
    ; Code:  Output an accurate pulse
    ; Author: William Roth 03/13/2015
    ;**************************************

    #chip 16F690,8

    ; ---- Define Hardware settings
    ; ---- Define I2C settings - CHANGE PORTS AS REQUIRED
    #define I2C_MODE Master
    #define I2C_DATA PORTB.4
    #define I2C_CLOCK PORTB.6
    #define I2C_DISABLE_INTERRUPTS ON

    ; ---- Set up LCD - Using I2C LCD Backpack
    #define LCD_IO 10
    #define LCD_I2C_Address_1 0x4e ; default to 0x4E
    ; ----  May need to use SLOW or MEDIUM if your LCD is a slower device.
    #define LCD_SPEED Medium
    #define LCD_Backlight_On_State  1
    #define LCD_Backlight_Off_State 0

    CLS
    ; ---- USART settings
    #define USART_BAUD_RATE 38400
    #define USART_TX_BLOCKING
    DIR PORTB.7 OUT

    ; ---- Setup Pulse parameters
    #define PulsePin PORTC.4
    Dim Time_us As WORD
    Dir PulsePin Out     'Pulsout pin
    Set PulsePin off

    ; ---- Setup Timer
    InitTimer1 Osc, PS1_2  'For 8Mhz Chip
    'InitTimer1 Osc, PS1_4, 'For 16 Mhz Chip
    TMR1H = 0: TMR1L = 0   'Clear timer1
    TMR1IF = 0  'Clear timer1 int flag
    TMR1IE = on 'Enable timer1 Interrupt (Flag only)

    ' **** This is the MAIN loop *****
    Do
        PULSE_OUT_US (2500)  'Measured as 2501.375 us
        wait 19 ms
        Pulse_Out_US (1000)  'Measured as 1000.750 us
        wait 19 ms
        Pulse_Out_US (100)   'Measured as 100.125 us
        wait 19 ms
        Pulse_Out_US (10)    'Measured as 10.125 us
        Wait 19 ms
    loop

    SUB PULSE_OUT_US (IN Variable as WORD)
    TMR1H = 65535 - Variable_H      'Timer 1 Preset High
    TMR1L = (65535 - Variable) + 4  'Timer 1 Preset Low
    Set TMR1ON ON                'Start timer1
    Set PulsePin ON               'Set Pin high
    Do While TMR1IF = 0      'Wait  for Timer1 overflow
        Loop
    Set PulsePin off          ' Pin Low
    Set TMR1ON OFF            ' Stop timer 1
    TMR1IF = 0             'Clear the Int flag
    END SUB</screen>
<simpara>Also see <link linkend="_pulseout">PulseOut</link></simpara>
</section>
<section xml:id="_graphical_lcd_demonstration">
<title>Graphical LCD Demonstration</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This demonstration code shows the set of commands supported by Great Cow BASIC.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F877a,16

    #include &lt;glcd.h&gt;

    'Setup the GLCD
    #Define glcd_rw PORTD.3       'RW pin on LCD
    #Define glcd_reset PORTD.4    'Reset pin on LCD
    #Define glcd_cs1 PORTD.1      'CS1, CS2 can be reversed
    #Define glcd_cs2 PORTD.2      'CS1, CS2 are be reversed
    #Define glcd_rs PORTD.5       'D/I pin on LCD
    #Define glcd_enable PORTD.4   'E pin on LCD
    #Define glcd_db0 PORTB.0  'D0
    #Define glcd_db1 PORTB.1  'D1
    #Define glcd_db2 PORTB.2  'D2
    #Define glcd_db3 PORTB.3  'D3
    #Define glcd_db4 PORTB.4  'D4
    #Define glcd_db5 PORTB.5  'D5
    #Define glcd_db6 PORTB.6  'D6
    #Define glcd_db7 PORTB.7  'D7 on LCD

    'Specify the type of GLCD
    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64
    #define GLCD_PROTECTOVERRUN

    wait 1 s
    GLCDCLS
    GLCDPrint 0, 1, "Great Cow BASIC "
    wait 1 s
    GLCDCLS

    rrun = 0
    dim msg1 as string * 16

    do forever

      GLCDCLS
      Box 18,30,28,40
      Line 0,0,127,63
      Line 0,63,127,0
      wait 1 s

      FilledBox 18,30,28,40
      wait 1 s

      GLCDCLS

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,1)              'upper left
        Circle(117,10,10,1)             'upper right
        Circle(63,31,10,1)              'center
        Circle(63,31,20,1)              'center
        Circle(10,53,10,1)              'lower left
        Circle(117,53,10,1)             'lower right
        wait 1 s

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        FilledCircle(10,10,10,1)         'upper left
        FilledCircle(117,10,10,1)        'upper right
        FilledCircle(63,31,10,1)         'center
        FilledCircle(63,31,20,1)         'center
        FilledCircle(10,53,10,1)         'lower left
        FilledCircle(117,53,10,1)        'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,0,10,1)                 'upper left
        Circle(117,0,10,1)                'upper right
        Circle(63,31,10,1)                'center
        Circle(63,31,20,1)                'center
        Circle(10,63,10,1)                'lower left
        Circle(117,63,10,1)               'lower right
        wait 1 s

        GLCDCLS
        GLCDDrawString 0,10,"Hello" 'Print Hello
        wait 1 s
        GLCDDrawString 0,10, "ASCII #:"    'Print ASCII #:
        Box 18,30,28,40                    'Draw Box Around ASCII Character
        for char = 0x30 to 0x39            'Print 0 through 9
          GLCDDrawString 16, 20 , Str(char)+"  "
          GLCDdrawCHAR 20, 30, char
          wait 250 ms
        next
        line 0,50,127,50                    'Draw Line using line command
        for xvar = 0 to 80                  'Draw line using Pset command
            pset xvar,63,on
        next
        FilledBox 18,30,28,40               'Draw Box Around ASCII Character '
        wait 1 s
        GLCDCLS
        GLCDDrawString 0,10,"End  "
        wait 1 s
        GLCDCLS

        workingGLCDDrawChar:
        dim gtext as string
        gtext = "KS0108"

            for xchar = 1 to gtext(0)      'Print 0 through 9
              xxpos = (1+(xchar*6)-6)
              GLCDDrawChar xxpos , 0 , gtext(xchar)
           next

        GLCDDrawString  1, 9, "Great Cow BASIC @2014"
        GLCDDrawString  1, 18,"GLCD 128*64"
        GLCDDrawString  1, 27,"Using GLCD.H from GCB"
        GLCDDrawString  1, 37,"Using GLCD.H GCB@2014"
        GLCDDrawString  1, 45,"GLCDDrawChar method"
        GLCDDrawString  1, 54,"Test Routines"

        wait 1 s
        GLCDCLS

        msg1 = "Run = " +str(rrun)
        rrun++
        GLCDPrint 0, 3, msg1
        wait 1 s
        GLCDCLS

    loop</screen>
<simpara><emphasis role="strong">For more help, see</emphasis>
<link linkend="_graphical_lcd_demonstration">Graphical LCD Demonstration</link>,
<link linkend="_glcdcls">GLCDCLS</link>,
<link linkend="_glcddrawchar">GLCDDrawChar</link>, <link linkend="_glcdprint">GLCDPrint</link>,
<link linkend="_glcdreadbyte">GLCDReadByte</link>,
<link linkend="_glcdwritebyte">GLCDWriteByte</link>, <link linkend="_pset">Pset</link></simpara>
</section>
<section xml:id="_infrared_remote">
<title>InfraRed Remote</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Great Cow BASIC support interfacing with IR remote controls. The header file contains explanations, for both hardware and software.</simpara>
<simpara>This has been tested on many different IR sensors, and different remote controls.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<simpara>The example is expected to work with most any IR sensor running at a 38 kHz carrier frequency.</simpara>
<screen>    ;This demo prints the device number and key number sent by
    ;a Sony compatible IR remote control unit to an LCD

    ;Thomas Henry --- 4/23/2014

    #chip 16F88, 8                    ;PIC16F88 running at 8 MHz
    #config mclr=off                  ;reset handled internally
    #config osc=int                   ;use internal clock
    #include &lt;SonyRemote.h&gt;           ;include the header file

    ;----- Constants

    #define LCD_IO      4             ;4-bit mode
    #define LCD_RS      PortB.2       ;pin 8 is Register Select
    #define LCD_Enable  PortB.3       ;pin 9 is Enable
    #define LCD_DB4     PortB.4       ;DB4 on pin 10
    #define LCD_DB5     PortB.5       ;DB5 on pin 11
    #define LCD_DB6     PortB.6       ;DB6 on pin 12
    #define LCD_DB7     PortB.7       ;DB7 on pin 13
    #define LCD_NO_RW   1             ;ground RW line on LCD

    #define IR_DATA_PIN PortA.0       ;sensor on pin 17

    ;----- Variables

    dim device, button as byte

    ;----- Program

    dir PortA in                      ;A.0 is IR input
    dir PortB out                     ;B.2 - B.6 for LCD

    do
      readIR_Remote(device, button)   ;wait for button press

      cls                             ;show device code
      print "Device: "
      print device

      locate 1,0
      print "Button: "                ;show button code
      print button

      wait 10 mS                      ;ignore any repeats
    loop                              ;repeat forever</screen>
<simpara><emphasis role="strong">See also <link linkend="_sonyremote_h">SonyRemote.h</link></emphasis>.</simpara>
<section xml:id="_sonyremote_h">
<title>SonyRemote.h</title>
<simpara><emphasis role="strong">Explanation:</emphasis>
Sony IR Remote Control Library for Great Cow BASIC</simpara>
<simpara>This include file will let you easily read and use the infrared signals from a Sony compatible television remote control. In particular, the remote control transmits a pulse modulated signal, the sensor detects this, and the subroutine in this header file decodes the signal, returning two numbers: one representing the device (television, VCR, DVD, tuner, etc.), while the the other returns the key which has been depressed (VOL+, MUTE, channel numbers 0 through 9, etc.).</simpara>
<simpara>This has been tested and confirmed with a fixed remote control purchased surplus for $2.00 from All Electronics, as well as an universal remote control, set to Sony mode.</simpara>
<simpara>Moreover it has also been tested with a Panasonic IR sensor and a Vishay sensor, both purchased surplus for about fifty cents.</simpara>
<simpara>Every combination performed well, and it is probably the; case that most any garden variety 38 kHz IR sensor will work. The only tricky bit is making sure you get the pinout for your sensor correct; search out the datasheet for whichever device you use.</simpara>
<simpara>There are only three pins: Ground Vcc Data</simpara>
<simpara>It is essential to filter the power applied to the Vcc pin. Do this by connecting a 100 ohm resistor from the +5V power supply to the Vcc pin, and bridge the pin to ground with a 4.7uF electrolytic capacitor.</simpara>
<simpara>The Data pin requires a 4.7k pullup resistor.</simpara>
<simpara>There is only one constant required of the calling program. It indicates which port line the IR sensor is connected to. For example,</simpara>
<screen>    #DEFINE IR_DATA_PIN PORTA.0</screen>
<simpara>There is one subroutine:</simpara>
<screen>    readIR_Remote(IR_rem_dev, IR_rem_key)</screen>
<simpara>The values returned are, respectively, the device number mentioned earlier and the key that is currently pressed. Both are byte values.</simpara>
<simpara>Seventeen local bytes are consumed, and two bytes are used for the output parameters. That&#8217;s a grand total of nineteen bytes required when invoking this subroutine.</simpara>
<simpara><emphasis role="strong">Header File</emphasis></simpara>
<screen>    sub readIR_Remote(out IR_rem_dev as byte, out IR_rem_key as byte)
      dim IR_rem_count, IR_rem_i as byte
      dim IR_rem_width(12) as byte            ;pulse width array

      do
        IR_rem_count = 0                      ;wait for start bit
        do while IR_DATA_PIN = 0              ;measure width (active low)
          wait 100 uS                         ;24 X 100 uS = 2.4 mS
          IR_rem_count++
        loop
      loop while IR_rem_count &lt; 20            ;less than this so wait

      for IR_rem_i = 1 to 12                  ;read/store the 12 pulses
        do
          IR_rem_count = 0
          do while IR_DATA_PIN = 0            ;zero = 6 units = 0.6 mS
            wait 100 uS                       ;one = 12 units = 1.2 mS
            IR_rem_count++
          loop
        loop while IR_rem_count &lt; 4           ;too small to be legit

        IR_rem_width(IR_rem_i) = IR_rem_count ;else store pulse width
      next IR_rem_i

      IR_rem_key = 0                          ;command built up here
      for IR_rem_i = 1 to 7                   ;1st 7 bits are the key
        IR_rem_key = IR_rem_key / 2           ;shift into place
        if IR_rem_width(IR_rem_i) &gt; 10 then   ;longer than 10 mS
           IR_rem_key = IR_rem_key + 64       ;so call it a one
        end if
      next

      IR_rem_dev = 0                          ;device number built up here
      for IR_rem_i = 8 to 12                  ;next 5 bits are device number
        IR_rem_dev = IR_rem_dev / 2
        if IR_rem_width( IR_rem_i ) &gt; 10 then
           IR_rem_dev = IR_rem_dev + 16
        end if
      next
    end sub</screen>
</section>
</section>
<section xml:id="_midpoint_circle_algorithm">
<title>Midpoint Circle Algorithm</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Great Cow BASIC can draw circles using the midpoint circle algorithm. The midpoint circle algorithm determines the points needed for drawing a circle.
The algorithm is a variant of <link xlink:href="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham&#8217;s line algorithm</link>, and is thus sometimes known as Bresenham&#8217;s circle algorithm, although not actually invented by <link xlink:href="https://en.wikipedia.org/wiki/Jack_Elton_Bresenham">Jack E. Bresenham</link>.</simpara>
<simpara>The example program below show the midpoint circle algorithm within Great Cow BASIC.</simpara>
<simpara><emphasis role="strong">Example Output on GLCD Device:</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/midpointcirclealgorithmb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<screen>    'Midpoint Circle algorithm
    'Chip model
    #chip 16F886, 8             ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally
    #config osc=int             ;use internal clock

    #include &lt;glcd.h&gt;

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64

    ;----- Program

    Do forever

        GLCDDrawString 30,0,"ChipMhz@"
        GLCDDrawString 78,0, str(ChipMhz)
        Circle(10,10,10,0)            ;upper left
        Circle(117,10,10,0)           ;upper right
        Circle(63,31,10,0)            ;center
        Circle(63,31,20,0)            ;center
        Circle(10,53,10,0)            ;lower left
        Circle(117,53,10,0)           ;lower right
        GLCDDrawString 30,54,"PIC16F886"

    loop</screen>
</section>
<section xml:id="_i2c_master_hardware">
<title>I2C Master Hardware</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to read and write data from an EEPROM device using the serial protocal called I2C.<?asciidoc-br?></simpara>
<simpara>This program uses the hardware I2C module within the microcontroller.  If your microcontroller does not have a hardware I2C module then please use the software I2C Great Cow BASIC ibrary.</simpara>
<simpara>This program has three sections.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Read a single byte from the EEPROM</simpara>
</listitem>
<listitem>
<simpara>Write and read a page of 64 bytes to and from the EEPROM, and</simpara>
</listitem>
<listitem>
<simpara>Finally display the contents of the EEPROM.</simpara>
</listitem>
</orderedlist>
<simpara>This program has an interrupt driven serial handler to capture and manage input from a serial terminal.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    'Change the microcontroller, frequency and config to suit your needs.
    #chip 16F1937, 32
    #config Osc = intOSC, MCLRE_ON, PLLEN_ON, VCAPEN_OFF

    'Required Library to read and write to an EEPROM
    #include &lt;I2CEEPROM.h&gt;

    ' Define I2C settings - CHANGE PORTS
    #define HI2C_BAUD_RATE 400
    #define HI2C_DATA PORTC.4
    #define HI2C_CLOCK PORTC.3
    'I2C pins need to be input for SSP module for Microchip PIC devices.
    Dir HI2C_DATA in
    Dir HI2C_CLOCK in
    'I2C MASTER MODE
    HI2CMode Master

    ' THIS CONFIG OF THE SERIAL PORT WORKS WITH max232 THEN TO PC
    ' USART settings
    #define USART_BAUD_RATE 9600
    Dir PORTc.6 Out
    Dir PORTc.7 In
    #define USART_DELAY 5 ms
    #define USART_TX_BLOCKING
    wait 500 ms

    'Create a Serial Interrupt Handler
    On Interrupt UsartRX1Ready Call readUSART

    ' Constants etc required for the serial Buffer Ring
    #define BUFFER_SIZE 32
    #define bkbhit (next_in &lt;&gt; next_out)
    ' Required Variables for the serial Buffer Ring
    Dim buffer(BUFFER_SIZE)
    Dim next_in as byte: next_in = 1
    Dim next_out as byte: next_out = 1


    Dim syncbyte as Byte
    wait 125 ms

    ' Read ONE byte from the EEPROM
    dim DeviceID as byte
    dim EepromAddress, syscounter as word
    #define EEpromDevice 0xA0

    'Master Main Loop
    location = 0
    'Define our array
    dim outarray(64), inarray(64)

    do
        HSerPrintCRLF 2
        HSerPrint "Commence Array Write and Read"
        'Populate the array
        for tt = 1 to 64
            outarray(tt) = tt
        next

        'Library write call is: eeprom_wr_array(device_number, page_size, address, array_name, number_of_bytes)
        eeprom_wr_array(EEpromDevice, 64, location, outarray, 64)


        'Library read call is: eeprom_rd_array(device_number, address, array_name, number_of_bytes)
        eeprom_rd_array(EEpromDevice, location, inarray, 64)

        'Show results of the read of the I2C EEPROM
        HSerPrintCRLF 2
        for tt = 1 to 64

            if outarray(tt) &lt;&gt; inarray(tt) then
               Hserprint "!"
               HSerPrint inarray(tt)
            else
               HSerPrint inarray(tt)
            end if
            HSerPrint ","
        next

        HSerPrintCRLF 2
        HSerPrint "Commence Write and Read a single byte":HSerPrintCRLF
        HSerPrint "Read value should be "
        HSerPrint  str(location):HSerPrintCRLF
        HSerPrint "Read = "
        'Use library to write and read from the I2C EEPROM
        eeprom_wr_byte (EEpromDevice, location, location)
        eeprom_rd_byte (EEpromDevice, location, bbyte )

        HSerPrint bbyte
        location++
        HSerPrintCRLF 2

        'Show the connnected I2C devices on the Serial terminal.
        HI2CDeviceSearch
        HSerPrint "Commence Dump of the EEPROM"
        validateEEPROM
    Loop
    End


    'Show the attached I2C devices
    sub HI2CDeviceSearch
        'Assumes serial is operational
        HSerPrintCRLF
        HSerPrint "I2C Device Search"
        HSerPrintCRLF 2
        for deviceID = 0 to 255
        HI2CStart
        HI2CSend ( deviceID )
        if HI2CAckPollState = false then
            HSerPrint   "ID: 0x"
            HSerPrint   hex(deviceID)
            HSerSend 9
            testid = deviceID | 1
            select case testid
                 case 49
                      Hserprint "DS2482_1Channel_1Wire Master"
                 case 65
                      Hserprint "Serial_Expander_Device"
                 Case 73
                       Hserprint "Serial_Expander_Device"
                 case 161
                      Hserprint "EEProm_Device_Device"
                 case 163
                      Hserprint "EEProm_Device_Device"
                 case 165
                      Hserprint "EEProm_Device_Device"
                 case 167
                      Hserprint "EEProm_Device_Device"
                 case 169
                      Hserprint "EEProm_Device_Device"
                 case 171
                      Hserprint "EEProm_Device_Device"
                 case 173
                      Hserprint "EEProm_Device_Device"
                 case 175
                      Hserprint "EEProm_Device_Device"
                 case 209
                      Hserprint "DS1307_RTC_Device"
                 case 249
                      Hserprint "FRAM_Device"
                 case else
                      Hserprint "Unknown_Device"
            end select
            HI2CSend ( 0 )
            HI2CSend ( 0 )
            HSerPrintCRLF
        end if
        HI2CStop
        next
        HSerPrint   "End of Device Search"
        HSerPrintCRLF 2
    end sub

    'Validation EEPROOM code
    sub validateEEPROM
        EepromAddress = 0
        HSerPrintCRLF 2
        HSerPrint "Hx"
        HSerPrint hex(EepromAddress_h)
        HSerPrint hex(EepromAddress)
        HSerPrint " "

        for EepromAddress = 0 to 0xffff
            'Read from EEPROM using a library function
            eeprom_rd_byte EEPromDevice, EepromAddress, objType

            HSerPrint hex(objType)+" "
            if ((EepromAddress+1) % 8 ) = 0 then
                HSerPrintCRLF
                HSerPrint "Hx"
                syscounter = EepromAddress + 1
                HSerPrint hex(syscounter_h)
                HSerPrint hex(syscounter)
                HSerPrint " "
            end if
            'Has serial data been received
            if bkbhit then
                syschar = bgetc
                select case syschar
                    case 32
                        do while bgetc = 32
                        loop
                    case else
                        HSerPrintCRLF
                        HSerPrint "Done"
                        exit sub
                end select
            end if
        next
        HSerPrintCRLF
        HSerPrint "Done"
    end Sub


    ' Start of Serial Support functions
    ' Required to read the serial port
    ' Assumes serial port has been initialised
    Sub readUSART
        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        if ( next_in = next_out ) then  ' buffer is full!!
            next_in = temppnt
        end if
    End Sub

    ' Serial Support functions
    ' Get characters from the serial port
    function bgetc
        wait while !(bkbhit)
        bgetc = buffer(next_out)
        next_out=(next_out+1) % BUFFER_SIZE
    end Function</screen>
</section>
<section xml:id="_i2c_slave_hardware">
<title>I2C Slave Hardware</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to control and display using a LCD the code for the keypad.</simpara>
<simpara>This program can be adaptedThis program uses the hardware I2C module within the microcontroller.  If your microcontroller does not have a hardware I2C module then please use the software I2C Great Cow BASIC ibrary.  for most microcontrollers.</simpara>
<simpara>This program also has an interrupt driven I2C handler to manage the I2C from the Start event.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    'Code for the keypad and LCD Microchip PIC microcontroller on the Microlab board v2
    'microcontroller is responsible for:
    ' - Reading keypad
    ' - Displaying data on LCD
    ' - communication with main Microchip PIC microcontroller via I2C
    ' - providing 5 keypad lines to main Microchip PIC microcontroller (for compatibility)
    ' - receiving remote control signals for button and keypad

    'This code has support for two keypad layouts. This is one possible layout:
    '0123
    '4567
    '89AB
    'CDEF
    'And this is the other possible layout:
    '123A
    '456E
    '789D
    'A0BC
    'Select the keypad layout by uncommenting one of these lines:
    '#define KEYPAD_KEYMAP KeypadMap0123
    #define KEYPAD_KEYMAP KeypadMap123F

    'Chip and config
    #chip 16F882, 8
    #config osc = INTOSCIO

    'Ports connected to keypad
    'Column ports need pullups, hence columns are on PORTB for built in weak pullups
    #define KEYPAD_COL_1 PORTB.4
    #define KEYPAD_COL_2 PORTB.5
    #define KEYPAD_COL_3 PORTB.6
    #define KEYPAD_COL_4 PORTB.7
    #define KEYPAD_ROW_1 PORTA.4
    #define KEYPAD_ROW_2 PORTA.3
    #define KEYPAD_ROW_3 PORTA.2
    #define KEYPAD_ROW_4 PORTA.1

    'Ports connected to LCD
    #define LCD_IO 4
    #define LCD_RW PORTA.7
    #define LCD_RS PORTA.6
    #define LCD_Enable PORTA.5
    #define LCD_DB4 PORTA.4
    #define LCD_DB5 PORTA.3
    #define LCD_DB6 PORTA.2
    #define LCD_DB7 PORTA.1
    #define BACKLIGHT PORTA.0

    'Button port (for remote control)
    #define BUTTON PORTB.0

    'Keypad ports connected to main Microchip PIC microcontroller
    'These are disabled when KeyoutDisabled = true
    #define KEYOUT_A PORTC.5
    #define KEYOUT_B PORTC.2
    #define KEYOUT_C PORTC.1
    #define KEYOUT_D PORTC.0
    #define KEYOUT_DA PORTB.1

    'I2C ports
    #define I2C_DATA PORTC.4
    #define I2C_CLOCK PORTC.3

    'RS232/USART settings
    'To do if/when remote support needed

    'Initialise
    Dir KEYOUT_A Out
    Dir KEYOUT_B Out
    Dir KEYOUT_C Out
    Dir KEYOUT_D Out
    Dir KEYOUT_DA Out

    Dir BACKLIGHT Out
    Dir BUTTON In 'Is an output, turn off by switching pin to Hi-Z

    'Initialise I2C Slave
    'I2C pins need to be input for SSP module
    Dir I2C_DATA In
    Dir I2C_CLOCK In
    HI2CMode Slave
    HI2CSetAddress 128

    'Buffer for incoming I2C messages
    'Each message takes 4 bytes
    Dim I2CBuffer(10)
    BufferSize = 0
    OldBufferSize = 0

    'Set up interrupt to process I2C
    On Interrupt SSP1Ready Call I2CHandler

    'Enable weak pullups on B4-7 (keypad col pins)
    NOT_RBPU = 0
    WPUB = b'11110000'

    'Key buffers
    '255 indicates no key, other value gives currently pressed key
    RemoteKey = 255
    OutKey = 255
    KeyoutDisabled = False 'False if KEYOUT lines used to send key

    'Main loop
    Do

        'Read keypad, send value
        CheckPressedKeys
        SendKeys

        'Check for I2C messages
        ProcessI2C

    Loop

    'This keymap table is for this arrangement:
    '0123
    '4567
    '89AB
    'CDEF
    Table KeypadMap0123
        3
        7
        11
        15
        2
        6
        10
        14
        1
        5
        9
        13
        0
        4
        8
        12
    End Table

    'This keymap table is for this arrangement:
    '123F
    '456E
    '789D
    'A0BC
    Table KeypadMap123F
        15
        14
        13
        12
        3
        6
        9
        11
        2
        5
        8
        0
        1
        4
        7
        10
    End Table

    Sub CheckPressedKeys
        'Subroutine to:
        ' - Read keypad
        ' - Check remote keypress
        ' - Decide which key to output

        'Read keypad
        If RemoteKey &lt;&gt; 255 Then
            OutKey = RemoteKey
        Else
            EnableKeypad
            OutKey = KeypadData

        End If

    End Sub

    Sub EnableKeypad
        'Disable LCD so that keypad can be activated
        Set LCD_RW Off 'Write mode, don't let LCD write

        'Re-init keypad
        InitKeypad

    End Sub

    Sub I2CHandler
        'Handle I2C interrupt
        'SSPIF doesn't trigger for stop condition, only start!

        'If buffer full flag set, read

        Do While HI2CHasData
            HI2CReceive DataIn

            'Sending code
            If BufferSize = 0 Then
                LastI2CWasRead = False
                'Detect read address
                If DataIn = 129 Then
                    LastI2CWasRead = True

                    HI2CSend OutKey

                    KeyoutDisabled = True
                    Dir KEYOUT_A In
                    Dir KEYOUT_B In
                    Dir KEYOUT_C In
                    Dir KEYOUT_D In
                    Dir KEYOUT_DA In

                    Exit Sub
                End If
            End If

            If BufferSize &lt; 10 Then I2CBuffer(BufferSize) = DataIn
            BufferSize += 1
        Loop

    End Sub

    Sub SendKeys

        'Don't run if not using KEYOUT lines
        If KeyoutDisabled Then Exit Sub

        'Send pressed keys
        If OutKey &lt;&gt; 255 Then
            'If there is a key pressed, set output lines
            If OutKey.0 Then
                KEYOUT_A = 1
            Else
                KEYOUT_A = 0
            End If
            If OutKey.1 Then
                KEYOUT_B = 1
            Else
                KEYOUT_B = 0
            End If
            If OutKey.2 Then
                KEYOUT_C = 1
            Else
                KEYOUT_C = 0
            End If
            If OutKey.3 Then
                KEYOUT_D = 1
            Else
                KEYOUT_D = 0
            End If

            KEYOUT_DA = 1
        Else
            'If no key pressed, clear data available line to main Microchip PIC microcontroller
            KEYOUT_DA = 0
        End If

    End Sub

    Sub ProcessI2C

        If HI2CStopped Then
            IntOff

            If LastI2CWasRead Then BufferSize = 0

            If BufferSize &lt;&gt; 0 Then
                OldBufferSize = BufferSize
                BufferSize = 0
            End If
            IntOn
        End If

        If OldBufferSize &lt;&gt; 0 Then

            CmdControl = I2CBuffer(1)

            'Set backlight
            If CmdControl.6 = On Then
                Set BACKLIGHT On
            Else
                Set BACKLIGHT Off
            End If

            'Set R/S bit
            LCD_RS = CmdControl.4

            'Send bytes to LCD
            LCDDataBytes = CmdControl And 0x0F
            If LCDDataBytes &gt; 0 Then
                For CurrSendByte = 1 To LCDDataBytes
                    LCDWriteByte I2CBuffer(LCDDataBytes + 1)
                Next
            End If
            'LCDWriteByte I2CBuffer(2)

            OldBufferSize = 0
        End If

    End Sub</screen>
</section>
<section xml:id="_rgb_led_control">
<title>RGB LED Control</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to drive an RGB LED to create 4096 different colors. Each of the three ;elements (red, green and blue) responds to 16 different levels. A value of 0 means the element never turns on, while a value of 15 means the element never shuts off. Values in between these two extremes vary the pulse width.</simpara>
<simpara>This program is an interrupt driven three channel PWM implementation.</simpara>
<simpara>The basic carrier frequency depends upon the microcontroller clock speed. For example, with an 8 MHz clock, the LED elements are modulated at about 260 Hz. The interrupts are generated by Timer 0. With an 8 MHz clock they occur about every 256 uS. The interrupt routine consumes about 20 uS.</simpara>
<simpara>Do not forget the current limiting resistors to the LED elements. A value of around 470 ohms is typical, but you may want to adjust the individual values, to balance the color response.</simpara>
<simpara>In this demonstration, three potentiometers are used to set the color levels using the slalom technique.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;----- Configuration
    #chip 16F88, 8                ;PIC16F88 running at 8 MHz
    #config mclr=off              ;reset handled internally
    #config osc=int               ;use internal clock
    ;----- Constants
    #define LED_R PortB.0         ;pin to red element
    #define LED_G PortB.1         ;pin to green element
    #define LED_B PortB.2         ;pin to blue element
    ;----- Variables
    dim redValue, greenValue, blueValue, ticks as byte
    ;----- Program
    dir PortA in                  ;three pots for inputs
    dir PortB out                 ;the LED outputs
    on interrupt Timer0Overflow call update
    initTimer0 Osc, PS0_1/2
    do
      redValue = readAD(AN0)/16   ;red -- 0 to 15
      greenValue = readAD(AN1)/16 ;green -- 0 to 15
      blueValue = readAD(AN2)/16  ;blue -- 0 to 15
    loop

    Sub update                    ;interrupt routine
      ticks++                     ;increment master timekeeper
      if ticks = 15 then          ;start of the count
        ticks = 0
        if redValue &lt;&gt; 0 then     ;only turn on if nonzero
          set LED_R on
        end if
        if greenValue &lt;&gt; 0 then
          set LED_G on
        end if
        if blueValue &lt;&gt; 0 then
          set LED_B on
        end if
      end if
      if ticks = redValue then    ;time to turn off red?
        set LED_R off
      end if
      if ticks = greenValue then  ;time to turn off green?
        set LED_G off
      end if
      if ticks = blueValue then   ;time to turn off blue?
        set LED_B off
      end if
    end sub</screen>
</section>
<section xml:id="_serial_rs232_buffer_ring">
<title>Serial/RS232 Buffer Ring</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>This program demonstrates how to create a serial input buffer ring.</simpara>
<simpara>This program program uses an interrupt event to capture the incoming byte value and place in the buffer ring. When a byte is received the buffer ring is incremented to ensuer the next byte is handled correctly.</simpara>
<simpara>Testing <literal>bkbhit</literal> will set to True when a byte has been received. Reading the function <literal>bgetc</literal> will return the last byte received.</simpara>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;Chip Settings
    #chip 16F1937,32
    #config LVP=OFF, BODEN=OFF, WDT=OFF, OSC=XT

    ' [change to your config] This is the config for a serial terminal
    ' turn on the RS232 and terminal port.
    ' Define the USART port
    #define USART_BAUD_RATE 9600
    #define USART_TX_BLOCKING
    #define USART_BLOCKING
    ' [change to your config] Ensure these port addresses are correct
    #define SerInPort PORTc.7
    #define SerOutPort PORTc.6
    'Set pin directions
    Dir SerOutPort Out
    Dir SerInPort In

    'This assumes you are using an ANSI compatible terminal.  Use PUTTY.EXE it is very easy to use.

    HSerPrint "Started: Serial between two devices"
    HSerSend 10
    HSerSend 13

    ' Pot port
    DIR PORTA.0 IN

    'Interrupt Handlers
    On Interrupt UsartRX1Ready Call readUSART

    ' Constants etc required for Buffer Ring
    #define BUFFER_SIZE 8
    #define bkbhit (next_in &lt;&gt; next_out)
    ;Variables
    Dim buffer( BUFFER_SIZE - 1 ) 'we will use element 0 in the array as part of out buffer
    Dim next_in as byte: next_in = 0
    Dim next_out as byte: next_out = 0
    Dim syncbyte as Byte

    syncbyte = 0x55 ' you can use 255 - your choice

    Do
        ' Send some info to another device
        Repeat 3
            HSerSend syncbyte
        end Repeat
        HSerprint readad(an0)

        do while bkbhit
        ' get three sync chars  then display the next char in buffer
            if bgetc = syncbyte and bgetc = syncbyte and bgetc = syncbyte then
                HSerPrint "sync'ed '"
                HSerPrint chr(bgetc)
                HSerSend 10
                HSerSend 13
            end if
        Loop
    Loop

    Sub readUSART
        buffer(next_in) = HSerReceive
        temppnt = next_in
        next_in = ( next_in + 1 ) % BUFFER_SIZE
        if ( next_in = next_out ) then  ' buffer is full!!
            next_in = temppnt
        end if
    End Sub

    function bgetc
        wait while !(bkbhit)
        bgetc = buffer(next_out)
        next_out=(next_out+1) % BUFFER_SIZE
    end Function</screen>
</section>
<section xml:id="_trigonometry_circle">
<title>Trigonometry Circle</title>
<simpara><emphasis role="strong">Explanation:</emphasis></simpara>
<simpara>Great Cow BASIC can draw circles on a Graphical LCD devcie using Great Cow BASIC library functions.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/trigonometrycirclesb1.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Demonstration program:</emphasis></simpara>
<screen>    ;Circle and filled circle commands on a graphic LCD.
    ;This uses the 2-place trigonometric routines found in the include file.

    ;Thomas Henry -- 4/17/2014

    ;----- Configuration

    #chip 16F88, 8              ;PIC16F88 running at 8 MHz
    #config mclr=off            ;reset handled internally
    #config osc=int             ;use internal clock

    #include &lt;GLCD.h&gt;
    #include &lt;Trig2Places.h&gt;

    ;----- Constants

    ;Pinout is shown for the LCM12864H-FSB-FBW
    ;graphical LCD available from Amazon.

    ;       +5V                 ;LCD pin 1
    ;       ground              ;LCD pin 2
    ;       Vo = wiper of pot   ;LCD pin 3
    #define GLCD_DB0 PORTB.0    ;LCD pin 4
    #define GLCD_DB1 PORTB.1    ;LCD pin 5
    #define GLCD_DB2 PORTB.2    ;LCD pin 6
    #define GLCD_DB3 PORTB.3    ;LCD pin 7
    #define GLCD_DB4 PORTB.4    ;LCD pin 8
    #define GLCD_DB5 PORTB.5    ;LCD pin 9
    #define GLCD_DB6 PORTB.6    ;LCD pin 10
    #define GLCD_DB7 PORTB.7    ;LCD pin 11
    #define GLCD_CS2 PORTA.0    ;LCD pin 12
    #define GLCD_CS1 PORTA.1    ;LCD pin 13
    #define GLCD_RESET PORTA.2  ;LCD pin 14
    #define GLCD_RW PORTA.3     ;LCD pin 15
    #define GLCD_RS PORTA.4     ;LCD pin 16
    #define GLCD_ENABLE PORTA.6 ;LCD pin 17
    ;       Vee = pot low side  ;LCD pin 18
    ;       backlight anode     ;LCD pin 19
    ;       backlight cathode   ;LCD pin 20

    #define GLCD_TYPE GLCD_TYPE_KS0108
    #define GLCD_WIDTH 128
    #define GLCD_HEIGHT 64

    ;----- Variables

    'None required.

    ;----- Program

    GLCDCLS

    circle(10,10,10)                  ;upper left
    circle(117,10,10)                 ;upper right
    filledcircle(63,31,10)            ;center
    circle(63,31,20)                  ;center
    filledcircle(10,53,10)            ;lower left
    filledcircle(117,53,10)           ;lower right</screen>
<simpara><emphasis role="strong">See also</emphasis> <link linkend="_trigonometry_sine_cosine_and_tangent">Trigonometry</link>, <link linkend="_circle">Circle</link>, <link linkend="_filledcircle">FilledCircle</link>,</simpara>
</section>
</section>
<section xml:id="_great_cow_graphical_basic">
<title>Great Cow Graphical BASIC</title>
<simpara>This is the Great Cow Graphical BASIC section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_code_documentation">
<title>Code Documentation</title>
<simpara>Documenting Great Cow BASIC is key for ease of use. This section is intended for developers only.</simpara>
<simpara>Documenting is the ability to read some extra information from comments in libraries.</simpara>
<simpara>Some comments that start with ''' have a special meaning, and will be displayed as tooltips or as information to the user. These tooltips helps inexperienced users to use extra libraries.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Great Cow BASIC uses ; (a semicolon) to show comments that it has placed automatically, and ' to indicate ones that the user has placed.  When loading a program, it will not load any that start with a ; (semi-colon).  The use of comments do not impact the users  but it worthy of note.</simpara>
</listitem>
<listitem>
<simpara>As for code documentation comments, Great Cow BASIC will load information about subroutines/functions and any hardware settings that need to be set.</simpara>
</listitem>
<listitem>
<simpara>For subroutines, a line before the Sub or Function line that starts with ''' will be used as a tooltip when the user hovers over the icon. A line that starts with '''@ will be interpreted differently, depending on what comes after the @. '''@param ParamName Parameter Description will add a description for the parameter. For a subroutine, this will show in the Icon Settings panel under the parameter when the user has selected that icon.</simpara>
</listitem>
<listitem>
<simpara>For functions, it will show at the appropriate time in the Parameter Editor wizard. '''@return Returned value applies to functions only. It will be displayed in the Parameter Editor wizard when the user is asked to choose a function.  An example of all this is given in srf04.h:</simpara>
</listitem>
</orderedlist>
<screen>    '''Read the distance to the nearest object
    '''@param US_Sensor Sensor to read (1 to 4)
    '''@return Distance in cm
    Function USDistance(US_Sensor) As Word</screen>
<orderedlist numeration="arabic" startingnumber="5">
<listitem>
<simpara>If a subroutine or command is used internally in the library, but Great Cow BASIC users should not see it, it can be hidden by placing '''@hide before the Sub or Function line. Another example from srf04.h:</simpara>
</listitem>
</orderedlist>
<screen>    '''@hide
    Sub InitUSSensor</screen>
<simpara>These should hopefully be pretty easy to add. It is also possible to add Hardware Settings. A particular setting can be defined anywhere in the file, using this syntax:</simpara>
<screen>    '''@hardware condition, display name, constant, value type</screen>
<simpara>These comments informs Great Cow BASIC when to show the setting. Normally, this is All, but sometimes it can include a constant, a space and then a comma separated list of values. display name is a friendly name for the setting to display. constant is the constant that must be set, and valuetype is the type that will be accepted for that constant&#8217;s value. To allow for multiple value types, enter a list of types with a | between them.</simpara>
<orderedlist numeration="arabic" startingnumber="6">
<listitem>
<simpara>Allowed types are:</simpara>
</listitem>
</orderedlist>
<screen>    free - Allows anything
    label - Allows any label
    condition - Allows a condition
    table - Allows a data table
    bit - Allows any bit from variable, or bit variable
    io_pin - Allows an IO pin
    io_port - Allows an entire IO port
    number - Allows any fixed number or variable
    rangex:y - Allows any number between x and y
    var - Allows any variable
    var_byte - Allows any byte variable
    var_word - Allows any word variable
    var_integer - Allows any integer variable
    var_string - Allows any string variable
    const - Allows any fixed number
    const_byte - Allows any byte sized fixed number
    const_word - Allows any word sized fixed number
    const_integer - Allows any integer sized fixed number
    const_string - Allows any fixed string
    byte - Allows any byte (fixed number or variable)
    word - Allows any word
    integer - Allows any integer
    string - Allows any string
    array - Allows any array</screen>
<orderedlist numeration="arabic" startingnumber="7">
<listitem>
<simpara>When the library is added the program, Great Cow BASIC will show a new device with the name of the library file on the Hardware Settings window. The user can then set the relevant constants without necessarily needing to see any code.  Adding a Great Cow BASIC library to Great Cow BASIC will not result in any changes to the library. Great Cow BASIC uses the information it reads to help edit the user&#8217;s program, but then the user&#8217;s program is passed to the compiler along with the unchanged library.</simpara>
</listitem>
<listitem>
<simpara>Hardware Settings are a bit more involved to add, but hopefully the bit of extra documentation for subroutines will be straight forward.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="_windows_net_support">
<title>Windows .NET Support</title>
<simpara>From Great Cow Graphical BASIC version 0.941 supports use on newer Windows versions without having the pre-requisite of .NET 3.5.</simpara>
</section>
</section>
<section xml:id="_great_cow_basic_for_linux">
<title>Great Cow BASIC for Linux</title>
<simpara>This is the Great Cow BASIC for Linux section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_overview_2">
<title>Overview</title>
<simpara><emphasis role="strong">Introduction:</emphasis>
Great Cow BASIC can be used when using the Linux Operating System.</simpara>
<simpara>This instructions are not distribution specific, but are for Linux only (not Windows).</simpara>
<simpara><emphasis role="strong">Instructions:</emphasis>
Complete the following steps to compile and install Great Cow BASIC for Linux:</simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>Install FreeBasic from your distributions repository or <link xlink:href="http://www.freebasic.net/wiki/CompilerInstalling">http://www.freebasic.net/wiki/CompilerInstalling</link></simpara>
</listitem>
<listitem>
<simpara>Download the "Great Cow BASIC - Linux Distribution" from SourceForge at <link xlink:href="https://sourceforge.net/projects/gcbasic/files/">https://sourceforge.net/projects/gcbasic/files/</link></simpara>
</listitem>
<listitem>
<simpara>Unrar/unpack <link xlink:href="mailto:GCB@Syn.rar">GCB@Syn.rar</link> to a location of your choice within your home directory (eg. within Downloads) with either a file manager or from a console.</simpara>
</listitem>
<listitem>
<simpara>From a console, change to the Great Cow BASIC Sources in the unpacked directory:</simpara>
</listitem>
</orderedlist>
<screen>   eg. cd ~/Downloads/GCB@Syn/GreatCowBasic/Sources/GCBASIC</screen>
<orderedlist numeration="arabic" startingnumber="5">
<listitem>
<simpara>Make sure that <literal>install.sh</literal> is set as executable (ie. <literal>chmod +x install.sh</literal>), and then execute: ./install.sh build</simpara>
</listitem>
<listitem>
<simpara>You will need root privileges for this step. You can switch user (su) to root, or optionally use <literal>sudo</literal>.</simpara>
</listitem>
</orderedlist>
<screen>   Execute: [sudo] ./install.sh install</screen>
<orderedlist numeration="arabic" startingnumber="7">
<listitem>
<simpara>If you su&#8217;d to root, use <literal>exit</literal> to drop back to your normal user. Then, be sure to follow the instructions given by the script for updating your path.</simpara>
</listitem>
<listitem>
<simpara>Confirm proper execution, and the version, of Great Cow BASIC by executing: gcbasic /version</simpara>
</listitem>
</orderedlist>
<simpara>Now you can create and compile GCB source files.</simpara>
<simpara><emphasis role="strong">Programming microcontrollers:</emphasis></simpara>
<simpara>To program your microcontroller with your Great Cow BASIC-created hex file, you will need additional software.</simpara>
<simpara>For Microchip PIC microcontroller programming, you might find what you need at: <link xlink:href="http://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120">http://www.microchip.com/DevelopmentTools/ProductDetails.aspx?PartNO=pg164120</link></simpara>
<simpara>For Atmel AVR microcontroller programming, you will need <literal>avrdude</literal>. It should be available in your distributions repository. If not, check here: <link xlink:href="http://www.nongnu.org/avrdude/">http://www.nongnu.org/avrdude/</link></simpara>
</section>
</section>
<section xml:id="_great_cow_basic_maintenance">
<title>Great Cow BASIC Maintenance</title>
<simpara>This is the Great Cow BASIC maintenance section of the Help file.  Please refer the sub-sections for details using the contents/folder view.</simpara>
<section xml:id="_great_cow_basic_maintenance_2">
<title>Great Cow BASIC Maintenance</title>
<simpara><emphasis role="strong">Introduction:</emphasis>
Great Cow BASIC maintenance covers the key processess that the developers use to maintain and build the solution.</simpara>
<simpara>This insights are not distribution specific</simpara>
<simpara><emphasis role="strong">Solution Architecture:</emphasis>
Complete the components are key for a complete solution:</simpara>
<orderedlist numeration="arabic" startingnumber="1">
<listitem>
<simpara>Great Cow BASIC installer</simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC chip specific .DAT files</simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC Help</simpara>
</listitem>
<listitem>
<simpara>Great Cow BASIC IDE</simpara>
</listitem>
</orderedlist>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Great Cow BASIC installer:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
The Great Cow BASIC installer used the InnoSoft installer with packaging completed using R2Build.<?asciidoc-br?></simpara>
<simpara>The process uses a Gold build structure.  The R2Build software creates four packages for Windows and one package for the Linus distribution.  The process is automated with automatic versioning and configuration.</simpara>
<simpara><?asciidoc-br?>
<?asciidoc-br?>
<emphasis role="strong">Great Cow BASIC chip specific .DAT files:</emphasis>
<?asciidoc-br?>
<?asciidoc-br?>
What are the .DAT files?</simpara>
<simpara>The DAT files are the Great Cow BASIC respresentation of capabilities of a specific microcontroller.&#160;&#160;The DAT is based upon a number of vendor sources and corrections/ommissions added by the Great Cow BASIC development team.&#160;&#160;The DAT file is exposed to the user program as a set of registers and register bits that can used to configure the program in terms of the microcontroller specifics.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
<simpara>The process to create the .DAT file for chips is as follows:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="2">
<colspec colname="col_1" colwidth="50*"/>
<colspec colname="col_2" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Step</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>Obtain the MPASM *.INC or the AVR *.XML files to be used. These files determine the scope of registers and register bits.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>For Microchip only.  Place the source INC files in the ..DAT\incfiles\OrgFiles.
</simpara><simpara>Process the file using 'Preprocess.bat'. &#160;&#160; This is an AWK text processor - you will required AWK.EXE in the executing folder.
</simpara><simpara>This preprocessing will examine all the INC files in the ..DAT\incfiles\OrgFiles folder.&#160;&#160;The resulting files will be placed in the ..DAT\incfiles folder.&#160;&#160;The resulting files will have the 'BITS' section sorted in port priority - this priority ensures the bits are assigned in the target DAT in the same order everytime.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>Update the database of support microcontrollers.&#160;&#160;This database contains the microcontroller configuration that Great Cow BASIC requires as the core information for the DAT files.
</simpara><simpara>The database is called <literal>chipdata.csv</literal> or <literal>avr_chipdata.csv</literal> for Microchip and AVR respectively.
- These files are comma delimited.&#160;&#160;The first row of data specifies the field name - these field names control the chip conversion program, see later notes.&#160;&#160;
</simpara><simpara>The database fields are controlled by the Great Cow BASIC development team and the specification of the database may change between release to support new capabilities.
</simpara><simpara>Database fields will the suffix of <literal>Variant</literal> such as PWMTimerVariant and SMTClockSourceVariant are microcontroller specific configuration settings to support the various microcontroller settings.&#160;&#160;These values of these <literal>variants</literal> is determined by the examination of the microcontrollers datasheet as this information is NOT specified in the source files.&#160;&#160;Variants are exposed in the user program with the prefix of Chip.&#160;&#160;If the variant is called <literal>PWMTimerVariant</literal> a constant caled <literal>ChipPWMTimerVariant</literal> will be exposed in the user program.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>Update the <literal>CriticalChanges.txt</literal> file, if required.&#160;&#160;The <literal>CriticalChanges.txt</literal> file contains changes the INC file during processing that are corrections or additions to the source files.
</simpara><simpara>The format of each line is the <literal>filename</literal> , <literal>Append (new line) or Replace</literal>, <literal>find</literal>, <literal>replace</literal>.
</simpara><simpara>Each line is comma delimited  and spaces are NOT critical.  &#160;&#160;Essentially, the processing with find a partial line and replace or append the whole line.
</simpara><simpara>example:  p16lf1615.inc,R,OSCFIE          EQU  H'0007',OSFIE           EQU  H'0007'&#160;&#160;&#160;&#160;
- so, when processing p16lf1615.inc find the line OSCFIE          EQU  H'0007' and replace with OSFIE           EQU  H'0007'.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>If required.  &#160;&#160;This is not normally edited. &#160;&#160; Update the <literal>18FDefaultASMConfig.txt</literal> to set the 18f configuration defaults.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>Maintain the conversion program.&#160;&#160;The conversion program may require maintenance. &#160;&#160;The programs are written in FreeBASIC and therefore require compilation.
</simpara><simpara>Examples of maintenance is-  a new variant field is required.&#160;&#160;The source program will need to be update to support the new variant - simply edit the source, compile and publish.&#160;&#160;Another example is the addition of new Interrupt - follow the same process to edit, compile and publish.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>Execute the program to convert the source files to the DAT files for Microchip or AVR.&#160;&#160;There are two programs for each architecture.
</simpara><simpara>Executing the conversion program without a parameter will process ALL the entries in the database (the csv file), passing a single parameter to the conversion program will only convert the single microcontroller.
</simpara><simpara>The conversion program will process as follow:
</simpara><simpara>a) Read the database for the chip specifics
</simpara><simpara>b) If a .DEV file or .INFO file is not present a routine called GuessDefaultConfig.  This method sets the bit(s).
</simpara><simpara>In all cases the default mask is sometimes specified for a particular config option and that is used for ASMConfig
</simpara><simpara>See the section below for the processing of a .DEV file.
</simpara><simpara>c) For all microcontrollers read the <literal>CriticalChanges.txt</literal> and process.
</simpara><simpara>d) For 18f microcontrollers read the <literal>18FDefaultASMConfig.txt</literal>.  This simply overwrites all options stated in 18FDefaultASMConfig.TXT  and marks this in the output DAT file.
</simpara><simpara>e) Create the output DAT file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>Test and publish the DAT file(s) to the distribution as required.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">An example the processing of a .DEV</emphasis>.</simpara>
<simpara>This is the 18F25K20 example.   For this microcontroller <literal>Disabled</literal> is default:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="./images/xml2.PNG" align="center"/>
</imageobject>
<textobject><phrase>graphic</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara role="text-left"><?asciidoc-br?>
<?asciidoc-br?>
Where the default is selected from the Info_Type.
<?asciidoc-br?>
<?asciidoc-br?></simpara>
</section>
</section>
</article>