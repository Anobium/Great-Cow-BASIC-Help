==  *Documentazione su Great Cow BASIC*

Il team di sviluppo di Great Cow BASIC al 2019

==  *Introduzione al Great Cow BASIC*

Benvenuto nell'Help di Great Cow BASIC. Questo file di aiuto ha lo scopo di fornire approfondimenti e conoscenza per usare Great Cow BASIC. Per informazioni sull'installazione di Great Cow BASIC e diversi altri programmi che potrebbero essere utili, per favore vedi http://url[Getting Started with Great Cow BASIC].

Se sei nuovo alla programmazione, dovresti provare i programmi dimostrativi di Great Cow BASIC, spiega tutto in modo graduale e non presuppone conoscenze preliminari. Se hai programmato in un'altra lingua, puoi seguire passo passo, i programmi dimostrativi, e il modo migliore per imparare. Se c'e qualcos'altro su cui hai bisogno di aiuto, visita http://url[sougeforge.net/forum?group_id=169286]

*Usare Great Cow BASIC*
-Completa l'installazione utilizzando i valori predefiniti:-seleziona tutti i programmatori ma non quelli in modalita portatile. Il programma di installazione avviera automaticamente l'IDE. Quando  viene aperto un file sorgente Great Cow BASIC, controlla il menu Strumenti IDE attraverso questo menu tu puoi accedere ai comandi con un click. Prova con il tasto destro del mouse: questo accedera alle stesse opzioni. I comandi IDE Tools ... (tasti funzione F5 - F8) avviano una utility e Great Cow BASIC chiama il file batch per la compilazione di codice sorgente e programmazione ("flash")(1) del microcontrollore target. Di default questi file batch sono chiamati flashAVR.bat (quando il chipmodel e un AVR) e flashPIC.bat (quando il chipmodel e un PIC) e un file batch per creare e programmare il tuo microcontrollore chiamato makeHEX.bat. Il chipmodel viene rilevato automaticamente dall'IDE.

* Modificando questi file batch e possibile configurare il software del programmatore per le proprie esigenze. Tutti i programmatori si trovano nella sottocartella GCB@Syn.

* Se e presente un file batch "FlashThis.bat" nella stessa cartella del file di origine, questo file batch e utilizzato per il flashing. Questo puo essere utile per il flashing specifico del progetto.

Il software per i programmatori incluso ed è:

*  Avrdude per AVR,

* PICPgm per PIC,

* PicKit2 e PicKit3,

* TinyBootLoader,

* Microchip Xpress Board e molti altri ancora.

(1) E necessario un programmatore adatto e le istruzioni dovrebbero essere incluse con il programmatore su come scaricare i programmi sul microcontrollore.

*Realease Formale del Compilatore Great Cow Basic  v0.98.04*

[width="100%",options="header,footer"]
|====================
|Reference  |Orario Stampa
|ASCIIDOCs rendered|2018-12-18
16:58:51 Ora Standard GMT
|Master ToC information|2018-11-19
08:38:50 GMT Standard Time
|====================

*Cambiamenti*

*Realease Formale di Great Cow Basic Compiler v0.98.04*

*Gli aggiornamenti HELP sono i seguenti:*

* Aggiunta nuova sezione NT7108C.

* Aggiornata la sezione G77D ST7735 per rimuovere i colori, aggiunti i colori TFT alla sezione panoramica di GLCD.

* Aggiunto supporto per il canale 8 PMW.

* Sezione PWM rivista per quanto riguarda i potenziali canali PWMN.

* Rivisto ST7735 GLCD per supportare OLED.

*Release 0.98.03*

* Aggiornata la sezione Randomize.
* Aggiunto il supporto PCA9685 alla sezione. Libreria.
* Sezione Libreria aggiornata per includere l'elenco completo dei driver di libreria.
* Aggiunto HPWM_CCPTimerN.
* Aggiunto GLCD ILI9326.
* Aggiunta la sezione macOS di Apple.
* Aggiunta la sezione optionReserveHighProg.
* Aggiunti test condizionali TRUE.
* Added LCD_IO_3.
* Aggiunta nuova sezione HEFM.
* Aggiunta nuova sezione SAFM.

*Release 0.98.02*

* Sezione chip aggiornata.

* Sezione del convertitore aggiornata per correggere lo stato deletetarget = y | n non purge = y | n

* Aggiunto HSerPrintStringCRLF

* Aggiornata la sezione HPWMUpdate per chiarire l'utilizzo del tipo di variabile.

* Aggiornato GLCDCLS per mostrare parametri aggiuntivi per i dispositivi GLCD a colori.

* Aggiunto il metodo di scala.

* Aggiunta costante LCD_WIDTH.

* Variabili di impostazione aggiornate.

* Aggiunta sezione di Nextion.

* Informazioni sul formato, corrette sulla pagina della riga di comando.

*Release 0.98.01*
* Aggiornata la sezione ILI9341 per i font OLED.

* Aggiornato I2C per il modulo I2C: nuove costanti e comandi.

* Aggiornato per il modello fisso PWM.

* Aggiornato per PWM a 10 bit con risoluzione e CCP / PWM con.

* DisableCCPFixedModePWM costante.

* Aggiunte pagine di contorno PWM a 16 bit.

* Revisionate le informazioni di ReadTable.

* Aggiunta sezione GLCD HX8347.

* Aggiunti nuovi comandi GLCDPrintString, GLCDPrintStringLN e GLCDLocateString.

*Release 0.98.00*

* #Define aggiornati esempi USART_TX_BLOCKING.

* Pagina delle condizioni, aggiornate con i vincoli noti dell'uso delle funzioni, come condizioni di prova

* Aggiornata la sezione SPI, aggiungendo il metodo FastHWSPIT Transfer.

* Sezione GLCD rivista per supportare SSD1306 128 * 32 pixel.

* Sezione ADC aggiornata per supportare tutte e tre le opzioni di lettura per ReadAD, ReadAD10 e ReadAD12.

* Sezione ingresso / uscita aggiornata per chiarire il supporto di AVR.

* Aggiunta sezione GLCD ILI9341.

* Aggiunta sezione GLCD ILI9486L.

* Sezione della tabella di ricerca aggiornata (Updated Lookup Table).

* Aggiornata la sezione OtherDirectives e aggiunte informazioni migliorate su ChipFamily.

* Aggiornata la sezione PWM per inserire il supporto per i canali PWM3 e PWM4.

* Sezione PWM riveduta per migliorare le informazioni.

* Aggiunta sezione HPWMUpdate.

* Sezione subroutine aggiornata con utilizzo della memoria per i 16F.

* Aggiunta la sezione 47xxx con una nuova sottosezione di memoria.

* Aggiunto PWM per la sezione AVR.

* Aggiornata la sezione altre direttive con le informazioni sui chip.

* Aggiunta sezione timer SMT.

* Sezione di manutenzione aggiornata.

* Sezione timer aggiornata di nuovo.

* Aggiornata la sezione PWM per includere le funzionalita di AVR

* Aggiornata la sezione On Interrupt, rimuovendo errori di battitura e aggiungendo altri esempi.

* Aggiornati i driver GCLD per aggiungere parametri per i colori.

* Aggiunta sezione FVR.

* STR aggiornato per includere STR32, STRInteger e un altro esempio.

* VAL aggiornato per includere Val32 e un altro esempio.

* Aggiornato la sezione GLCD per includere la configurazione di memoria insufficiente SSD1306 e la tabella delle funzionalita GLCD.

* Aggiornato la sezione GLCD per includere la configurazione di memoria bassa SSD1306 e SH1106 e aggiunto altri esempi.

* Aggiunto Ellipse e FilledEllipse.

* Aggiunto Triangolo e Filled Triangolo.

* Aggiunto il range di Select Case.

* Vincolo di stringa concatenato aggiornato.

* Informazioni aggiornate su LCD_Backlight per le modalita LCD 0, 4, 8 e 404.

* Aggiunte informazioni OLED solo alla sezione SSD1306. I font OLED sono supportati solo dal GLCD SSD1306 in questa versione.

* Aggiunto #SameVar e #SameBit.

* Aggiunto prefisso [canskip] a SettingVariables.

*Release 0.97.00*

* #Startup revisionata per documentare le ultime modifiche alla priorita delle subroutine di avvio.

* Aggiunta sezione di manutenzione.

* Rivisto inittimer 1,3,5 e 7 per supportare ulteriori sorgenti di clock.

* Aggiornate tutte le sezioni PPS per supportare #startup come metodo consigliato.

* Revisionato Pulsein e aggiunto PulseInInv.

* Aggiunto PORTCHANGE alla sezione OnInterrupt.

* Informazioni aggiornate sul compilatore per la cache TRISIO.

* HSerGetNum aggiornato per supportare variabili Long e aggiunto un esempio.

* Revisionato LCD_IO 2_74xx164 per aggiungere il collegamento allo schema elettrico.

* Aggiunto l'utilizzo dell'output ad altre direttive.

* Aggiunto il supporto per SDD1306 per SPI alla sezione GLCD.

* Aggiunta sezione GetUserID.

* Aggiunta la sezione Serial Software (ottimizzata).

*Release 0.96.00*

* Uso delle stringhe rivisto ed esempi di stringhe per mostrare l'uso delle virgolette all'interno di una stringa.

* Revisionato OtherDirectives per includere le costanti mancanti.

* Aggiunto DisplaySegment e Revised DisplayChar.

* Aggiornato initimer2 / 4 e 6 per mostrare i prescalers.

* Ripristinati operazioni bit a bit e SetWith per help.

*Release 0.95.010*

* Aggiunti miglioramenti a SerSend e SerPrint.

* Sezione 7 segmenti riveduta per fornire chiarezza, migliorare il codice e rimuovere gli errori.

* Sezione CCP e PWM riveduta per includere le funzionalita.

* Revisione della sezione ADC e aggiunta costante ADReadPreReadCommand.

*Release 0.95.009*

â€¢ Aggiunto il driver GLCD SH1106.

*Release 0.95.008*

* Solo numero di versione aggiornato.

*Release 0.95.007a*

* Aggiunto #option explicit.

* Aggiunta spiegazione variabile lifecycle.

* Sezione PlayRTTTL rivista e migliorata.

* Sezioni Wait e SPIMode riviste.

*Release 0.95.007*

* Aggiunte nuove funzionalita per supportare la gamma di microcontrollori 16F1885x.

* Nuovi comandi PMW: supporto per hardware PWM.

* Nuova opzione Initimer0 per supportare moduli timer a 8 e 16 bit.

* Nuove costanti disponibili ChipADC e ChipIO.

* Nuovi comandi per supportare PPS. LOCKPPS e UNLOCKPPS.

* Aggiunto comando I2CStartoccurred. Mancava dalla Guida.

* Ulteriori informazioni per gli script.

* Rimozione generale degli errori di battitura nei file della Guida.

* Aggiornato la sezione FnLSL rimuovendo l'errore.

* La rimozione di SetWith, FnEQUBit e FnNOTBit dovrebbe ora essere sostituita dalle operazioni incorporato nel compilatore. I bit vengono ora gestiti correttamente dall'operatore Not incorporato.

* Nuovo comando #option volatile. I pin sensibili possono essere contrassegnati come volatili e gli operatori di assegnazione nativi si imposteranno senza problemi, sostituendo SetWith.

* Aggiunte nuove sezioni sull'ottimizzazione del codice ADC e PWM.

* Aggiunto il nuovo comando I2C per il software I2C use_I2C_timeout.

*Release 0.95.006*

* Riscrittura completata del file di aiuto.

* Nuovo file di aiuto in PDF.

* Nuovo file di guida in XML.

* Nuovo file di aiuto in HTML5.

* Nuovo file di aiuto in HTML per Web.

* Sezione Linux riveduta.

* Sezione SPIMode rivista.

*Release 0.95.005a*

* Sezione hardware RS232 riveduta per migliorare la leggibilita.

*Release 0.95.005*

* Aggiunto LeftPad.

*Release 0.95.004*

* Aggiornati i comandi HSerial per supportare AVR 1, 2, 3 e 4.

*Release 0.95*

* Aggiunto set di comandi pullup debole.

* Aggiunto utilizzo della RAM durante la definizione della matrice.

* Aggiunto un nuovo metodo per usare una costante per definire una matrice.

* Aggiunte informazioni su come impostare l'indirizzo sui moduli mjkdz I2C LCD 1602.

* Aggiunte nuove costanti ChipWords e ChipEEPROM.

* Aggiunto un nuovo metodo di definizione della tabella.

* Aggiunte nuove funzionalita alle tabelle di ricerca.

* Aggiunte nuove funzionalita a READAD per i microcomputer AVR.

* Aggiunte istruzioni per compilare Great Cow BASIC sotto Linux.

* Aggiunto un nuovo comando per invertire un display GLCD KS0108.

* Aggiunto nuovo codice di esempio: FLASH_LED.

* Aggiunto come impostare la velocita del chip a velocita non standard.

* Aggiunto un nuovo parametro di comando al set di comandi hardware USART.

* Il set di comandi HI2C2.

* Aggiunto un nuovo set di comandi per la seconda porta USART.

* Aggiunto il nuovo set di comandi del driver GLCD ILI9340.

* Aggiunto il set di comandi del driver GLCD SDD1289.

* Aggiunto codice di esempio. Misurazione della durata dell'impulso alla risoluzione del sub-microsecondo.

* Generazione di impulsi accurati mediante una macro. Come passare un indirizzo di porta alla routine usando una macro.

* Aggiunta sezione di supporto .NET.

* Parametri del comando SPIMode rivisti.

* Aggiunto #option NoContextSave.

* Aggiunto su Intterupt: il gestore predefinito.

* Aggiunte nuove opzioni del compilatore sotto-sezione, spostate le opzioni dalle Direttive del compilatore.

* Aggiunto il nuovo supporto per i caratteri per GLCD.

* Aggiunto il nuovo supporto per i colori per GLCD.

* Aggiunto LCD_IO_1 e cambia LCD_IO_2 per supportare 74xx164 e 74xx174.

* Revisionata la maggior parte della sezione Timer per supportare le informazioni corrette.

* Aggiunto il supporto del controller touchscreen ADS7843.

* Aggiunto il set di comandi Play e PlayRTTL.

Aggiunto comando DIFFerence.

* Aggiunti tre metodi bit a bit. FnNotBit, FnLSL e FnLSR.

* Domande frequenti aggiornate con "come impostare una porta.

* Aggiunto il metodo bitwise FnequBit.

*  Aggiunti i dettagli di Timer6, Timer7, Timer8, Timer10 e Timer12 su On Interrupt.

* Aggiunto un nuovo esempio di on interrupt.

* Aggiunta la riga di comando / WX.

* Aggiunti HI2CWaitMSSP e HI2CWaitMSSPTimeout alla sezione I2C hardware.

* Parametri della riga di comando aggiornati.

* Aggiunto il comando Fill.

* Sezione Array rivisto.

* Aggiunto il comando ReadAD12.

* Aggiunta la spiegazione di dividere e divisione.

* Aggiunto Str32 e Val32.

* Aggiunto supporto per USART2. HSerReceive1 e HserReceive2.

* Aggiunto HserRecieveFrom.

* Aggiunto HserGetNum.HSertGetString.

* Aggiunta modalita di misurazione a canale singolo e modalita di misurazione del canale differenziale a ADC.

* Panoramica.

*Release 0.94b*

* Aggiunto il supporto HEFM.

* Aggiunto il supporto del driver GLCD SSD 1306.

*Release v0.91*

* Aggiunto USART_TX_BLOCKING.

* Aggiunto LCD_SPEED.

* Sezione LCD migliorata.

*Release v0.9ho*

* Aggiornamento del parametro passato alle routine secondarie.

* Sezione LCD nuova e rivista per includere LCD_IO 10 e 12.

* Rimuovere la LAT dove appropriato.

* LAT e stato deprecato. Il compilatore reindirizzera tutte le scritture pin I / O da PORTx a LATx registri su PIC 16F1 / 18F.

* Utilizzare #option nolatch se si verificano problemi.

* ADFormat modificato in deprecato.

* Aggiungi l'azione predefinita a #CHIP quando non viene specificata alcuna frequenza.

*Release v0.9h*

* Corretti gli errori nella sezione PWM e esempi migliorati.

*Release v0.9hn*

* Modifiche agli array. Il numero di elementi e ora limitato a 10.000 per dispositivi 12F e 16F o, la RAM disponibile.

* Tabelle di ricerca aggiornate per supportare i nuovi metodi di compilazione delle tabelle.

1. un singolo valore su ciascuna linea.

2. piu elementi su una singola riga separati da virgole.

3. Sono consentite costanti e calcoli all'interno delle voci della tabella di dati a riga singola.

* Repeat loop modificato per supportare EXIT REPEAT.

* Nuovo comando Pad. Il metodo Pad viene utilizzato per creare una stringa su una lunghezza specifica che viene estesa con un carattere specifico.

* Aggiunto il set di comandi DS18B20.

*v0.9hm*

* Aggiornato I2C - software e hardware. Il codice dimostrativo ora utilizza la scheda dimostrativa Chipino. Modificato nella sezione I2C seriale con questi nuovi esempi.

* Nuovi comandi funzionali:

LCDDisplayOn

LCDDisplayOff

LCDBackLight ( On | Off )

* I nuovi Define per supportare le funzionalita LCD sono:

-LCD_SPEED FAST

-LCD_SPEED MEDIUM

-LCD_SPEED SLOW

* Funzionalita Revisionata LCDHex supporta ora la stampa degli zeri iniziali quando il numero HEX e inferiore a 0x10. chiamare LCDHex come segue per assicurarsi che siano presenti zeri iniziali.

* LCDHex byte_value, LeadingZeroActive parameter called LeadingZeroActive.

* Nuovo supporto per i dispositivi GLCD PCD8544.

* Sezione GLCD modificata dell'aiuto per supportare il nuovo dispositivo.

*v0.9hl*

* HSERPRINTCLRF - Aggiunto parametro per ripetere il numero di CRLF inviato.

* Aggiunto set di comandi I2C hardware. Questa e una funzionalita riveduta per fornire supporto al modulo MSSP.

*0.9hk*

* File della guida aggiornato per correggere l'immissione di potenza, era nella sezione errata. Spostato nella sezione Matematica e altri errori minori.

* Correggere le informazioni del timer0. Revisionato per mostrare le costanti e il codice del timer e stato corretto.

*v0.9hj*

* Queste informazioni si riferiscono a Hot Release del 11 maggio.

*2014.* Dove la funzionalita non e supportata dalle versioni precedenti di GCB, effettuare l'aggiornamento. Alcune funzioni non
funzioneranno nelle versioni precedenti di Great Cow Basic.

* Nuovi comandi funzionali.

<<a-1,Circle>> Disegna un cerchio sullo schermo del GLCD.<<a-2,FilledCircle>> Riempie un cerchio sullo schermo del GLCD.<<a-3,Log>> function(s)
Power funzione.
registro funzione(i)
Comandi funzionali modificati.

<<a-4,Line>> Ora disegna linee tra due punti qualsiasi sul display GLCD.
#define GLCD_PROTECTOVERRUN .
Controlla il disegno di cerchi per impedire il superamento del cerchio a estremi di  isualizzazione.

#define Line OldLine.
Aggiungendo questa definizione si tornera alle vecchie routine di disegno a linee. Questo e stato aggiunto per compatibilita con le versioni precedenti.

Aiuto e revisioni dei file

Aggiunto <<a-5,PulseIn>>

Aggiunto PulseInAggiunto PulseIn

Aggiunto esempio di intestazione <<a-6,IR_Remote>>

Aggiunto esempio di dimostrazione e rivisto <<a-7,GLCD demonstration>>

Aggiunto esempio di controllo <<a-8,RGB LED Control>>
Aggiunta sezione per mostrare il metodo di documentazione inline,vedere Code Documentation

*v0.9hk*

* Metodo documentato per la documentazione GCGB.

Aggiunto MATHS.H.

Aggiunta la funzione SQRT.

*v0.9hi*

* Supporto per ST7735 documentato. Funzionalita aggiunta a GLCD.h.

* Supporto per dispositivo grafico ST7920 LCD 128 * 64.

* Sezione GLCD modificata per includere il dispositivo nuovo e uno non documentato.

* Nuovi comandi GLCD per il supporto di GLCD ST7920

ST7920GLCDEnableGraphics

ST7920GLCDDisableGraphics

ST7920GLCDClearGraphics

ST7920Locate

ST7920gTile

ST7920Tile

ST7920cTile

ST7920SetIcon

ST7920GraphicTest

ST7920LineHs

ST7920gLocate

ST7920linev

* Supporto documentato per GLCD ST7735.

* Revisionati i comandi GLCD con retro compatibilita:

GLCDCLS

GLCDPrint - supporta le modalita LCD e GLCD

GLCDDrawString - supporto per la gestione delle stringhe

GLCDDrawChar - Colore opzionale

Box

FilledBox

Line

PSet

GLCDReady

* InitGLCD, include la correzione per la routine di avvio per i

dispositivi KS0108

Le funzioni Private ST7920 possono essere utilizzate secondo necessita ..

ST7920WriteCommand

ST7920WriteData

ST7920WriteByte

ST7920gReaddata

ST7920GLCDReadByte

GLCDTimeDelay

* Informazioni test condizionali aggiornate.

* Informazioni aggiornate sul KeyPad.

* Informazioni aggiornate sulla tabella di ricerca.

* Aggiunte informazioni sulla macro.

* Aggiunta nuova sezione matematica Trig.

* Aggiunti due nuovi esempi di Circle

* Aggiunte altre informazioni sulle direttive.

* Aggiunti programmi di esempio.

* Cerchi punto medio.

* Cerchi per trigonometria.

*v0.9hg*

*  Pagine di visualizzazione GLCD ad anodi comuni  corrette.

*v0.9hf*

* Sezione 7 segmenti riveduta per supportare il catodo comune. Ci sono ora due opzioni disponibili.

*v0.9he*

* Nuovi comandi. Richiesto dopo marzo 2014 LCD.h:

LCDHOME, LCDSPACE, LCDCreateGraph, LCDCursor, LCDCmd

* Aggiunta della concatenazione.

* Aggiornato DisplayValue per mostrare il supporto per i valori HEX.

Richiesto dopo marzo 2014 7Segment.h.

*  Codice di esempio GLCD aggiornato per garantire che l'esempio

sia compilato senza file esterni.

* Aggiunti Trigonometria e l'applicazione di esempio

* Aggiornamento della panoramica LCD per includere il supporto LATx per una maggiore velocita di clock. Post richiesto Marzo 2014 LCD.h

*v0.9hd*

* Revisionato Ruota per chiarire i tipi di byte supportati.

*v0.9hc Mar 2014*

* Revisione di HSERPRINT per mostrare i numeri interi e i caratteri

lunghi sono supportati e il testo modificato e corretto.

* Aggiunti HserPrintByteCRLF e HserPrintCRLF

* Aggiunto esempio alla tabella sine

* TABELLA Revisionata per mostrare la limitazione rispetto all'utilizzo

di WORDS quando si posizionano TABLES in EEPROM

*v0.9hb Mar 2014*

* Aggiunto PulseOutInv

* I2CRestart

* Aggiungi nuove varianti per l'uso dei commenti

* Aggiunta sezione Assembler

*14 Gennaio*

* Nuovi comandi):

Len, Asc, Chr, Trim, Ltrim, Rtrim, Swap4, Swap, Abs, Average, Trim, Ltrim, Rtrim, Wordtobin, Bytetobin, GLCD, DectoBCD, BCDtoDec.

Uso delle variabili.

Altro su costanti e variabili.

Ringraziamenti.

*  Cambia in:

Str, Hex, Poke, Else, Readtable, Exit (era exitsub)

Parametri della riga di comando Domande frequenti

* Corretti errori di battitura.

*  Valore di ripetizione massimo REPEAT aggiornato.

* Aggiornamento della maggior parte delle pagine per il layout.

Risolti i collegamenti alle pagine esterne. Questa volta scaricato come pagine html complete, per POT e LC.

Aggiunto LABEL, Bootloader e revisione Selezione, aggiunto READAD10

Corretto Double SWAP

* v0.9hg*

*  Corrected GLCD Common Anode display pages

* v0.9hf*

* Revised 7 Segment section to support Common Cathode. Split 7 Segment entry to show the two options available.

*v0.9he*

* Nuovi comandi. Richiesto dopo marzo 2014 LCD.h:

LCDHOME, LCDSPACE, LCDCreateGraph, LCDCursor, LCDCmd

* Aggiunta della concatenazione

* Aggiornato DisplayValue per mostrare il supporto per i valori HEX.

Obbligatorio post marzo 2014 7Segment.h.

* Codice di esempio GLCD aggiornato per garantire che l'esempio sia compilato senza file esterni.

* Aggiunto Trigonometria e l'applicazione di esempio.

*  Aggiornamento della panoramica LCD per includere il supporto

LATx per una maggiore velocita di clock. Post richiesto Marzo 2014

LCD.h.

*v0.9hd*

* Revisionato Rotate per chiarire i tipi di byte supportati.

*v0.9hc Mar 2014*

* HSERPRINT rivisto per mostrare i numeri, integer e long sono supportati e il testo modificato e corretto.

* v0.9hb Mar 2014*

*  Added PulseOutInv
*  I2CRestart
*  Add new variants to use of Comments
*  Added Assembler Section

*14 Gennaio*

* Nuovi comandi):

Len, sc, Chr, Trim, Ltrim, Rtrim, Swap4, Swap, Abs, Average, Trim,

Ltrim, Rtrim, Wordtobin, Bytetobin, GLCD, DectoBCD, BCDtoDec

Uso delle variabili

Altro su costanti e variabili.

Ringraziamenti.

* Cambiati in:

Str, Hex, Poke, Else, Readtable, Exit (era exitsub)

Parametri della riga di comando Domande frequenti.

* Corretti errori di battitura.

* Valore di ripetizione massimo REPEAT aggiornato.

* Aggiornamento della maggior parte delle pagine per il layout.

Risolti i collegamenti alle pagine esterne. Questa volta scaricato

come pagine html complete, per POT e LC.

Aggiunto LABEL, Bootloader e revisione Selezione, aggiunto

READAD10.

Corretto Double SWAP.

* v0.9h*

* Pagine di visualizzazione degli anodi comuni GLCD corrette.

*v0.9h*

* Sezione 7 segmenti riveduta per supportare il catodo comune.

Dividi la voce di 7 segmenti per mostrare le due

opzioni disponibili.

*v0.9he*

* Nuovi comandi. Richiesto dopo marzo 2014 LCD.h:

LCDHOME, LCDSPACE, LCDCreateGraph, LCDCursor, LCDCmd.

* Aggiunta della concatenazione.

* Aggiornato DisplayValue per mostrare il supporto per i valori HEX.

Richiesto dopo marzo 2014.

7Segment.h

* Codice di esempio GLCD aggiornato per garantire che l'esempio.

sia compilato senza file esterni.

* Aggiunti Trigonometria e l'applicazione di esempio.

* Aggiornamento della panoramica LCD per includere il supporto.

LATx per una maggiore velocita di clock. Post richiesto.

Marzo 2014 LCD.h

*v0.9hd*

* Revisionato Rotate per chiarire i tipi di byte supportati.

*v0.9hc Mar 2014*

*  HSERPRINT rivisto per mostrare i numeri interi e i caratteri lunghi sono supportati e ha cambiato il testo corretta.

* Aggiunti HserPrintByteCRLF e HserPrintCRLF.

* Aggiunto esempio di tabella sinusoidale.

* TABELLA Revisionata per mostrare la limitazione rispetto all'utilizzo
di WORDS quando si inseriscono TABELLE in
EEPROM.

*v0.9hb Mar 2014*

* Aggiunto PulseOutInv.

* I2CRestart.

* Aggiungi nuove varianti per l'uso dei commenti.

* Aggiunta sezione Assembler 14 gennaio.

Nuovi comandi:

Len, sc, Chr, Trim, Ltrim, Rtrim, Swap4, Swap, Abs, Average, Trim,

Ltrim, Rtrim, Wordtobin, Bytetobin,

GLCD, DectoBCD, BCDtoDec

Usare le variabili

Altro su costanti e variabili

Ringraziamenti

* Cambiano in:

Str, Hex, Poke, Else, Readtable, Exit (era exitsub)

Parametri della riga di comando Domande frequenti

* Corretti errori di battitura.

* Valore di ripetizione massimo REPEAT aggiornato.

* Aggiornamento della maggior parte delle pagine per il layout.

Risolti i collegamenti alle pagine esterne. Questa volta scaricato

come pagine html complete, per POT e LC.

Aggiunto LABEL, Bootloader e revisione Select, aggiunto

READAD10

Corretto Double SWAP

*paremetri della riga di comando*

*Informazioni sui parametri della riga di comando*

GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:\{C|A}] [/V] [/L] [/NP] nomefile

GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/V] [/L] [/WX]  [/NP] nomefile

GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/V] [/L] [/WX] [/S:Use.ini] [/NP] nomefile

GCBASIC [/O:output.asm] [/A:assembler] [/P:programmer] [/K:{C|A}] [/V] [/L] [/WX]  [/S:Use.ini] [/F[O]] [/NP] nomefile

GCBASIC /version

[width="100%",options="header,footer"]
|====================
|*switch*  |*descrizione*  |*default*
|/:filename  |Imposta il nome del file assembly generato nel nome file.
  |Stesso nome del file di input, ma con estensione .asm.

|/A:assmber |File batch utilizzato per chiamare l'assemblatore (1). Se / A: GCASM è dato, Great Cow BASIC userà il suo assemblatore interno.
  |Il programma non verrà assemblato

|/P:programmer  |File batch utilizzato per chiamare il programmatore (1). Questo parametro viene ignorato se il programma non è assemblato.
  |File batch utilizzato per chiamare l'assemblatore (1). Se / A: GCASM è dato, Great Cow BASIC userà il suo assemblatore interno.

|/K:[C A]|Conserva il codice originale nell'output dell'assieme.  |Nessun codice originale lasciato in uscita.

|/V[:[O  F][1 T] |Modalità dettagliata: il compilatore fornisce informazioni più dettagliate sulle sue attività. / Vx sovrascriverà qualsiasi configurazione nel file utente ini |-

|/L  |Mostra la licenza e esci.   |-

|/NP  |Non mettere in pausa sugli errori. Utilizzare con IDE.   |Pausa quando si verifica un errore e attendere che l'utente preme un tasto.

|/WX  |Forza il compilatore per garantire che tutti i file inclusi siano validi.   |
|/version |Data di costruzione mostrata e versione del compilatore.   |

|/S  |Carica le impostazioni da un file specificato, piuttosto che utilizzare i valori predefiniti. |/S:use.ini

|/F[:[0 F][1T]  |Utilizzato per ignorare la compilazione quando non è necessario, il compilatore verificherà che le impostazioni di configurazione nel file già compilato corrispondano a quelle richieste per il programmatore. In caso contrario, una ricompilazione sarà forzata. Salta la compilazione se il file hex è aggiornato se ha la configurazione corretta. / F: x (F o 0) per forzare una nuova compilazione indipendentemente da ciò che ini specifica.   |

|/FO  |Utilizzato per ignorare solo la compilazione e il programma. Il compilatore verificherà che le impostazioni di configurazione nel file già compilato corrispondano a quelle richieste per il programmatore. In caso contrario, una ricompilazione sarà forzata.   |
|nome del file   |Il file da compilare.
|====================

(1) Per i / A: e / P: switches, ci sono opzioni speciali disponibili. Se %FILENAME% e presente, sara sostituito dal nome del file .asm.

%FN_NOEXT% verra sostituito dal nome del file .asm ma senza un'estensione e %CHIPMODEL% verra sostituito con il nome del chip. Il nome del chip sara uguale a quello sul file di dati del chip. Un
file batch per caricare l'ASM da Great Cow BASIC in MPASM. La riga di comando dovrebbe essere cosi:

 C:\progra~1\microc~1\mpasms~1\MPASMWIN /c- /o- /q+ /l- /x- /w1 %code%.asm

Un file batch da compilare in Great Cow BASIC quindi caricare l'ASM da Great Cow BASIC in GPASM.

La riga di comando dovrebbe essere cosi:

 gcbasic.exe %1 /NP /K:A /A:"..\gputils\bin\gpasm.exe %~d1%~p1%~n1.asm"

Per istruire MAKEHEX.BAT per utilizzare GPASM, hai installato

GPUTILS. Il file batch deve essere modificato come segue:

 REM Create the ASM
 gcbasic.exe /NP /K:A %1
 REM Use GPASM piping to the GCB error log
 gpasm.exe "%~d1%~p1%~n1.asm" -k -i -w1 >> errors.txt

Per riassumere, puoi utilizzare uno dei seguenti:

 gcbasic.exe filetocompile.gcb /A:GCASM /P:"icprog -L%FILENAME%" /V /O:compiled.asm

Great Cow BASIC compilerà il file, quindi assemblerà il programma

ed eseguira questo comando:

 "icprog -Lcompiled.hex"

Puoi anche creare / modificare il file gcbasic.ini:

 'Assembler settings
 Assembler = C:\Program Files\Microchip\MPASM Suite\mpasmwin
 AssemblerParams = /c- /o- /q+ /l+ /x- /w1 "%FileName%"
 'Programmer settings
 Programmer = C:\Program Files\WinPic\Winpic.exe
 ProgrammerParams = /device=PIC%ChipModel% /p "%FileName%"

Questo esempio utilizzera MPASM per assemblare il programma.

Avvia il programma specificato in assembler = line, e dargli questi

parametri:

 `/c- /o- /q+ /l+ /x- /w1 "compiled.asm"`

Quindi, chiamera il programmatore e assegnera questi parametri:

 `/device=PIC16F88 /p "compiled.hex"`

%ChipModel% verra rimpiazzato dal chip che stai usando, quindi questo chip Great Cow BASIC lo passera a WinPIC.

*Errorr.txt*

Il compilatore produce solo il file errors.txt se c'e un errore. La creazione del file errors.txt rende piu facile per gli IDE rilevare se il programma e stato compilato correttamente, se il file non e stato prodotto quindi l'IDE non sara in grado di presentare il messaggio di errore all'utente. Il file error.txt viene sempre prodotto nella stessa cartella del compilatore. Tipicamente:C: \ GCB @ Syn \ GreatCowBasic \ Errors.txt

== *Domande frequenti*
*Perchè non succede nulla quando eseguo GCBASIC.exe?*
Great Cow BASIC è un compilatore a linea di comando. Per compilare un file, puoi trascinarlo e rilasciarlo sul Icona GCBASIC.exe. Sono disponibili anche diversi ambienti di sviluppo integrati, o IDE Great Cow BASIC. Questi ti daranno un'area in cui puoi modificare il tuo programma e un pulsante da inviare il programma per il chip. Diversi sono elencati sul sito web di Great Cow BASIC.

*Quali microcontrollori Microchip PIC e Atmel AVR fanno il supporto di Great Cow BASIC?*
Si spera che tutti i microcontrollori a 8 bit Microchip PIC e Atmel AVR (quelli in PIC10, PIC12, PIC16 e Famiglie PIC18). Se trovi quello che Great Cow BASIC non funziona correttamente, per favore pubblicalo nella sezione Problemi del compilatore del forum di Great Cow BASIC.

*Case sensitive, Great Cow BASIC Ã¨ sensibile ai caratteri maiuscoli o minuscoli?*
No! Ad esempio, Set, SET, set, SeT, ecc. Sono tutti trattati allo stesso modo da Great Cow BASIC.

*Posso specificare il bit di una variabile e modificarli usando un'altra variabile?*
L'impostazione di una variabile con altre variabili è prevista. Great Cow BASIC supporta assegnazioni bit a bit. Come segue:

 portc.0 = !porta.1

Puoi anche usare una funzione di spostamento. Come in altri linguaggi, usando la funzione Shift FnLSL. UN esempio Ã¨:

 MyVar = FnLSL( 1, BitNum) è Equivalente a "MyVar = 1<<BitNum"

Per impostare un bit di una porta, per evitare glitches durante l'aggiornamento dell'output, utilizzare questo metodo.

 'aggiungere la seguente opzione per la porta specifica.
 #option volatile portc.0 ' poi nel tuo codice
 portc.0 = !porta.1

è possibile utilizzare questo metodo per impostare un bit di una porta. Inserito nel metodo SetWith, questo elimina anche qualsiasi problema durante l'aggiornamento, utilizzare questo metodo.

 SetWith(MyPORT, MyPORT OR FnLSL( 1, BitNum))

Per cancellare un bit di una porta, utilizzare questo metodo.

 MyPORT = MyPORT AND NOT FnLSL( 1, BitNum))

Per impostare un bit all'interno di un array, utilizzare questo metodo.

 video_buffer_A1(video_adress) = video_buffer_A1(video_adress) OR FnLSL( 1, BitNum)

Vedere anche <<a-9,Set>>, <<a-10,FnLSL>>, <<a-11,FnLSR>>  e <<a-12,Rotate>>

*TWhy e x la funzione non è implementata?*

Perchè non è stato pensato, o nessuno è stato in grado di implementarlo! Se ci sono delle caratteristiche che ti piacerebbe vedere in Great Cow BASIC, per favore pubblicali nella sezione "Open Discussion" del Forum di Great Cow BASIC. Oppure, se puoi, prova ad aggiungere la funzione da solo!

*Quando si utilizza un file include questo usa molta memoria?*
Quando si utilizzano i file include, in questo caso include <ds3231.h>, se non si utilizzano tutte le funzioni del file include, GCB sa di non includere le funzioni non utilizzate all'interno del file include durante la compilazione, o include tutto comunque. Ad esempio, se non utilizzo l'hardware I2C, tutto il codice relativo all'hardware I2C viene ancora compilato nel codice?

Great Cow BASIC compila solo funzioni e subroutine se vengono chiamate. Great Cow BASIC inizia a compilare dalla routine principale, quindi qualsiasi cosa chiamata da li. Ogni volta che trova una nuova subroutine chiamata, la compila e tutto ciò che chiama. Se una subroutine non è necessaria, non viene compilata.

*Il mio LCD non funzionerÃ  come previsto?*

Aggiungi. #define LCD_SPEED SLOW

Questo rallenterÃ  la scrittura sul display LCD.

*L'utilizzo della memoria di Atmel AVR è errata?*

I valori di memoria di Atmel AVR sono specificati in WORD in Great Cow BASIC. Il compilatore di Great Cow BASIC utilizza le Word, non i byte, per la coerenza tra microcontrollori Microchip PIC e Atmel AVR. Questo mantiene le parti del compilatore più semplici.

*Non riesco ad aprire il file di aiuto della finestra?*

Vedere http://url[digital.ni.com/public.nsf/allkb/B59D2B24D624B823862575FC0056F3D0].

== *Risoluzione dei problemi*


[width="100%",options="header,footer"]
|====================
|Problemi  |Cause Comuni  |Assistenza
|Impossibile compilare il programma  |C'è un errore nel programma. La Great Cow BASIC si lamenta di una particolare linea di codice?
| Forum Great Cow BASIC

  |
  |
C'è un bug in Great Cow BASIC   |Pubblica sul forum Great Cow BASIC. Assicurati di indicare la versione del compilatore e allegare il codice come un ZIP.
|Un programma viene compilato e scaricato correttamente, ma non verrà eseguito
|Oscillatore non dichiarato  |<<a-13,Configuration >>
|====================

== *Statistiche del Compilatore*

Questa sezione fornirà  alcune informazioni su ciò che fa il compilatore.

*Come si comporta il compilatore con i registri di sola lettura nella gamma famiglia PIC12?*

All'interno di questo intervallo di chip, il registro delle opzioni è un registro di sola scrittura. La lettura del registro non è consentita.

Great Cow BASIC ha bisogno di aggiornare questo quando l'utente vuole cambiare la configurazione del processo Sleep è un esempio di una modifica dell'utente.

Il compilatore gestisce questo con la creazione della variabile di byte Option_reg. Questo byte è creato dal compilatore per gestire il processo di scrittura richiesto.

La variabile Option_reg è una cache, che il compilatore creerà  se sono stati impostati bit di option_reg manualmente.

Se l'utente cambia uno dei bit in un programma, il compilatore troverà  qualsiasi utilizzo dell'opzione istruzioni e li inserisce in "movwf OPTION_REG" immediatamente prima dell'istruzione dell'opzione per memorizzare nella cache il valore nel buffer.


Se i bit Option_reg non sono impostati individualmente, quindi option_reg non viene creato, non viene fatto nulla di speciale con l'istruzione opzionale.

Essenzialmente il compilatore mantiene una variabile speciale e gestisce l'intero processo senza che l'utente sia consapevole.

*Come fa il compilatore a far fronte al registro TRIS nei PIC10f?*

Il compilatore assicura che una cache TRIS corrisponda al registro TRIS attuale. La cache TRIS è una variabile byte chiamata TRISIO. La cache TRISIO è necessaria poichè TRIS è un registro di sola scrittura.

Tutte le porte predefinite per l'input (dove tutti i bit TRIS sono a 1) al reset. Pertanto, si presume che sia il valore 255.

TRISIO viene aggiornato quando richiesto dal codice utente e quindi utilizzato nella scrittura nel registro corretto.

Il codice utente di esempio e l'assieme associato con l'assembly mostra la cache TRISIO in uso. Questo metodo è conforme con la scheda tecnica.

Codice utente

  'set as input dir gpio.0 in gpio0State = gpio.0 'impostato come output, sarÃ  necessario impostare TRIS GPIO utilizzando la cache TRISIO.

  dir gpio.0 out
  gpio.0 = 1

ASM

  ;dir gpio.0 in
    bsf TRISIO,0
    movf TRISIO,W
    tris GPIO
    ;gpio0State = gpio.0
    clrf GPIO0STATE
    btfsc GPIO,0
    incf GPIO0STATE,F
    ;dir gpio.0 out
    bcf TRISIO,0
    movf TRISIO,W
    tris GPIO
    ;gpio.0 = 1
    bsf GPIO,0

Ovunque sia impostato / azzerato un singolo bit TRIS cambiando la direzione della porta, il bit nella cache è cambiato e poi viene scritto nel registro TRIS. Forcing the ASM to contain comments
It may be useful to force comments into the ASM file. The verbose mode of creating the ASM will include ALL the source program as comments but it may be useful to have specific comments in the ASM to aid the understanding of code or to support debugging.

*Forzare l'assembly per contenere commenti:*

Potrebbe essere utile forzare i commenti nel file ASM. La modalitÃ  dettagliata di creazione dell'ASM lo farà  include TUTTO il programma sorgente come commenti, ma potrebbe essere utile avere commenti specifici in ASM per facilitare la comprensione del codice, o per supportare il debug. Per forzare un commento in assembly, utilizzare quanto segue:

          asm showdebug `commento`

Dove 'commento' verrà  inserito nel file ASM.

Esempio.

Il file sorgente contiene quanto segue, dove si trova il testo del commento OSCCON type is 100

       asm showdebug OSCCON type is 100
       OCCON1 = 0x60

L'assembly generato sarà  il seguente: questo presuppone che la modalità  dettagliata non sia selezionata.

        INITSYS
        ;osccon type is 100
        movlw 96
        banksel OSCCON1

== *Panoramica sulle librerie*

*Infomazioni sulle librerie*

Great Cow BASIC (come con la maggior parte degli altri linguaggi di programmazione dei microcontrollori) supporta le librerie.

Puoi creare la tua libreria specifica per il tuo dispositivo, non sei limitato a quelli mostrati di seguito. Se crei una nuova libreria specifica per dispositivo - si prega di inviare per l'inclusione nella prossima versione tramite il Great Cow BASIC Forum.

La manutenzione di queste librerie è completata dal team di sviluppo di Great Cow BASIC. Se vuoi, puoi adattare queste librerie, dovresti creare una copia locale, modificare e salvare all'interno della struttura del tuo file di sviluppo. Il team di sviluppo può aggiornare queste librerie come parte di una release e non vogliamo perdere le modifiche locali.

Per utilizzare una libreria, è sufficiente includere quanto segue nel codice utente:

     #include <3PI.H> 'questo includerà  le funzionalità  3PI all'interno del programma  Per utilizzare una copia locale di una libreria, è sufficiente includere quanto segue nel codice utente

     #include "C: \ mydev \ library \ 3pi.h"

     'questo includerà  una copia locale del 3pi nel tuo programma  Great Cow BASIC supporta le seguenti librerie di dispositivi.


[width="100%",options="header,footer"]
|====================
|*Libreria*  |*Classe*  |*Uso*
|3PI  |Polulu 3pi robot  |Una libreria che interfaccia il PWM per pilotare i motori.

|47XXX_EERAM.H  |I2C EERAM memory  |Una libreria specifica per dispositivo per le classi di dispositivi EERAM Microchip

|ALPS-EC11  |Rotary Encoder  |Una libreria specifica per dispositivo per un encoder rotativo.

|ADS7843  |Touch Shield |Una libreria che si interfaccia con il touch screen ADS7843.

|BME280  |Sensore di temperatura, umidità e pressione  |Una libreria che si interfaccia con il sensore BME280 e BMP280.

|CHIPINO  |Shield  |Una libreria che interfaccia la scheda Chipino con indirizzi di porta come quelli di Arduino.

|DHT  |Temperatura e umidità |Una libreria che supporta i sensori di temperatura e umidità DHT22 e DHT11.

|DS1307  |Clock  |libreria ch supporta il clock timer e le funzioni NVRAM.

|DS1672  |Clock  |Una libreria che supporta l'orologio del timer e le funzioni della NVRAM.

|DS18B20  |Temperature  |Una libreria che supporta le funzioni di temperatura.

|DS18SB0MultiPort  |Temperature  |Una libreria che supporta le funzioni di temperatura con dispositivi collegati a più porte.

|DS18S20  |Temperature  |Una libreria che supporta le funzioni di temperatura.

|DS2482  |Clock  |Una libreria che supporta le funzioni OneWire di Dallas I2C.

|DS3231  |Clock  |A library that supports the timer clock and NVRAM functions.

|DUEMILANOVE  |Shield  |Una libreria che interfaccia la scheda Duemilanove con indirizzi di porta come Arduino.

|EMC1001  |Temperature  |Una libreria che supporta le funzioni di temperatura e le altre funzionalità del dispositivo.

|FRAM  |I2C Eeprom  |Una libreria che supporta le funzioni di memoria.

|GETUSERID  |Microchip read ID  |Una libreria che supporta l'identificazione dei microcontrollori Microchip.

|GLCD  |Graphical LCD  |Una libreria di base per il supporto grafico LCD.

|GLCD_HX8347  |Graphical LCD  |Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_ILI9340  |LCD grafico | Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_ILI9341  |LCD grafico | Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_ILI9481  |Graphical LCD  |LCD grafico | Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_ILI9486L  |Graphical LCD  |A device specific library for an Graphical LCD.

|GLCD_IMAGESANDFONTS_ADDIN3  |Graphical LCD  |LCD grafico | Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_KS0108  |Graphical LCD  |LCD grafico | Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_NEXTION  |Graphical LCD  | LCD grafico | Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_PCD8544  |Graphical LCD  | LCD grafico | Una libreria specifica per dispositivo per un LCD grafico.

|GLCD_SH1106  |Graphical LCD  |A device specific library for an Graphical LCD.

|GLCD_SSD1289  |Graphical LCD  |A device specific library for an Graphical LCD.

|GLCD_SSD1306  |Graphical LCD  |A device specific library for an Graphical LCD.

|GLCD_SSD1331  |Graphical LCD  |A device specific library for an Graphical LCD.

|GLCD_ST7735  |Graphical LCD  |A device specific library for an Graphical LCD.

|GLCD_ST7920  |Graphical LCD   |A device specific library for an Graphical LCD.

|HEFLASH  |HEF Memory Driver  |Una libreria che supporta le funzioni di memoria HEF.

|HMC5883L  |Triple-axis Magnetometer  | Una libreria che supporta le funzioni del  magnetometro.

|HWI2C_ISR_HANDLER  |I2C Slave Driver  |Una libreria che supporta l'uso di un microcontrollore Microchip come slave I2C.

|HWI2C_MESSAGEINTERFACE  |I2C Slave  |A support library that supports the use of a Microchip microcontroller as an I2C slave.

|HWI2C_ISR_HANDLERKMODE  |I2C Slave Driver  |A library that supports the use of a Microchip microcontroller as an I2C slave.

|HWI2C_MESSAGEINTERFACEKMODE  |I2C Slave  |Una libreria di supporto, che supporta l'uso di un microcontrollore Microchip come I2C slave.

|I2CEEPROM  |I2C EEProm memory  |Una libreria che supporta le funzioni di memoria.

|LCD2SERIALREDIRECT  |LCD to Serial Handler  |Una libreria che supporta l'uso di un terminale seriale e PC come uno psuedo LCD.

|LEGO-PF  |Lego Mindstorms shield   |Una libreria che supporta l'uso di un terminale seriale e PC come uno psuedo LCD.

|LEGO  |Lego Mindstorms shield  | Una libreria che supporta il robot Lego Mindstorms

|MATHS  |Maths routines  |Una libreria che supporta funzioni matematiche come log, power e atan.

|MAX6675  |Temperature  |Una libreria che supporta le funzioni di temperatura.

|MAX7219_ledmatrix_driver  |LED 8*8 Matrix driver  |Una libreria che supporta le matrici LED 8 * 8 MAX7219

|MCP23008  |i2C to serial  |Una libreria che supporta le funzioni I2C in serie.

|MCP23017  |i2C to serial  |Una libreria che supporta le funzioni seriali I2C.

|MCP23017  |i2C to serial  |Una libreria che supporta le funzioni seriali I2C.

|MCP4XXXDIGITALPOT  |Digital Pot   |Una libreria che supporta la gamma di potenziometri digitali MCPxxxx.

|MCP7940N  |Clock  | Una libreria che supporta il clock del timer e le funzioni della NVRAM.

|NUNCHUCK  |Game controller  |Una libreria che supporta il controller di gioco NunChuck.

|PCA9685  |PWM  |Una libreria specifica per dispositivo per il driver PWM a 16 canali. Guarda le dimostrazioni per esempio sull'uso. Supporta fino a quattro dispositivi tramite il bus I2C.

|PCF8574  |GLCD  |Una libreria specifica per dispositivo per un LCD grafico.

|SD  |SD Card  |Una libreria specifica per dispositivo per una scheda SD.

|SMT_Timers  |Signal Measurment Timer  |Una libreria per la misurazione del segnale tramite il Timer per microcontrollori Microchip specifici.

|SOFTSERIAL  |Serial  |Una libreria per seriale software.

|SOFTSERIALCH1  |Serial  |Una libreria per seriale1 software.

|SOFTSERIALCH2  |Serial  |Una libreria per seriale software2.

|SOFTSERIALCH3  |Serial  | Una libreria per seriale software3.

|SONGLAY  |Music  | Una libreria per ascoltare musica. Supporta il formato QBASIC e RTTTL.

|SONYREMOTE  |Infrared  |Una libreria che supporta le funzioni di un telecomando Sony.

|SRF02  |Distance Sensor  |Una libreria che supporta il sensore ultrasonico SRF02.

|SRF04  |Distance Sensor  |Una libreria che supporta il sensore ultrasonico SRF04.

|TEA5767  |I2C Radio  |Una libreria che supporta il TEA5767 radioricevitore .

|TRIG2PLACES  |Maths functions  |Una libreria matematica che supporta la trignometria in due punti.

|TRIG3PLACES  |Maths functions  |Una libreria matematica che supporta la trignometria in tre punti.

|TRIG4PLACES  |Maths functions  |Una libreria matematica che supporta la trignometria in quattro punti

|UNO_MEGA328P  |Shield  |Una libreria che si interfaccia con lo shield e indirizzi di porta come Arduino.

|USB  |USB Supoort  |Una libreria che interfaccia l'USB per i microcontrollori 16f e 18f.

|====================

Great Cow BASIC supporta le seguenti librerie principali. Queste librerie sono automaticamente incluse nel tuo programma utente quindi non è necessario utilizzare '#include' per accedere alle funzionalità  delle librerie.


[width="100%",options="header,footer"]
|====================
|*Libreria*  |*Classe*  |*Uso*
|7SEGMENT  |7 Segment LED display  |Una libreria che si interfaccia con i display a 7 segmenti.

|A-D  |Analog to Digital  |Una libreria che  supporta le functionalità ADC.

|EEPROM  |EEProm  |Una libreria che supporta i dispositivi eeprom I2C.

|HWI2C  |I2C  |Una libreria che supporta i moduli hardware MSSP e TWI (I2C).

|HWI2C2  |I2C  | Una libreria che supporta i moduli hardware MSSP e TWI (I2C) sul canale due.

|HWSPI  |SPI  | Una libreria che supporta i moduli hardware MSSP e TWI della SPI.

|I2C  |I2C  | Una libreria che supporta il Bus I2C software .

|KEYPAD  |KeyPad  |Una libreria che supporta una tastiera.

|PS2  |I2C  |Una libreria che supporta la funzionalità della tastiera del PC.

|LCD  |LCD  | Una libreria che supporta la funzionalità LCD, la libreria supporta molti  e diversi metodi di comunicazione.

|PWM  |Pulse Width Modulation  |Una libreria supporta la funzionalità PWM.

|RANDOM  |Random Numbers  |Una libreria supporta la funzionalità del numero casuale.

|REMOTE  |Infrared  |Una libreria che supporta le funzioni di un controllo remoto NEC.

|RS232  |Serial  |Una libreria per comunicazioni seriali.

|SOUND  |Tones  |Una libreria per la generazione di suoni e toni

|STDBASIC  |Utility Functions  |La libreria che contiene molti dei metodi di utilità.

|STRING  |String  |La libreria che contiene i metodi di stringa.

|SYSTEM  |System  |La libreria che contiene i metodi di sistema.

|TIMER  |Timers  |La libreria che contiene i metodi del timer.

|USART  |Serial  |La libreria che contiene i metodi seriali hardware che utilizzano il modulo hardware equivilent MSSP o AVR.

|====================
Great Cow BASIC supporta le seguenti librerie principali. Queste librerie sono automaticamente incluse nel tuo programma utente quindi non è necessario utilizzare '#include' per accedere alle funzionalità  delle librerie.


[width="100%",options="header,footer"]
|====================
|*Libreria*  |*Classe*  |*Uso*

|7SEGMENT  |display a 7 Segment a LED  |Una libreria che si interfaccia con i display a 7 segmenti.

|A-D  |Analogico Digitale  |Una libreria che supporta le funzionalità ADC.

|EEPROM  |EEProm  |Una libreria che supporta i dispositivi eeprom I2C.

|HWI2C  |I2C  |Una libreria che supporta i moduli hardware MSSP e TWI di I2C.

|HWI2C2  |I2C  |Una libreria che supporta i moduli hardware MSSP e TWI (I2C) sul canale due.

|HWSPI  |SPI  |Una libreria che supporta i moduli hardware MSSP e TWI della SPI.

|I2C  |I2C  |Una libreria che supporta il bus  I2C software.

|KEYPAD  |KeyPad  |Una libreria che supporta una tastiera.

|PS2  |2C  |Una libreria che supporta la funzionalità della tastiera del PC.

|LCD  |LCD  |Una libreria che supporta la funzionalità LCD, la libreria supporta molti e diversi metodi di comunicazione.

|PWM  |Modulazione a Larghezza di Impulso  |Una libreria supporta la funzionalità PWM.

|RANDOM  |Random Numbers  |Una libreria supporta la generazione  dei numeri casuali.

|REMOTE  |Infrared  |Una libreria che supporta le funzioni di un controllo remoto NEC.

|RS232  |Serial  |Una libreria per comunicazioni seriali.

|SOUND  |Tones  |Una libreria per la generazione di suoni e toni.

|STDBASIC  |Utility Functions  |La libreria che contiene molti dei metodi di utilità.

|STRING  |String  |La libreria che contiene i metodi di stringa.

|SYSTEM  |System  |La libreria che contiene i metodi di sistema.

|TIMER  |Timers  |La libreria che contiene i metodi del timer.

|USART  |Serial  |La libreria che contiene i metodi seriali hardware che utilizzano il modulo hardware equivilent MSSP o AVR.
|====================

== *Ringraziamenti*

Hugh Considine -  Principale sviluppatore di Great Cow BASIC.

Stefano Bonomi - Subroutine LCD a due fili.

Geordie Millar - subroutine Swap e Swap4.

Jacques Nilo - HEFM e file di aiuto per la conversione in asciidoc.

Finn Stokes -  Routine moltiplicazione a 8 bit, codice di accesso alla memoria di programma.

Evan Venn -  Utilità, routine I2C riviste, questo file di aiuto e in generale tutto il resto!

*Contributori della traduzione:*

Stefano Delfiore - Italiano

Pablo Curvelo - Spagnolo

Murat Inceer - Turco

*Altri Contributori:*

Russ Hensel - Great Cow BASIC Note.

Chuck Hellebuyck - La sua documentazione per il GLCD e altri particolari, vedi  http://url[elproducts.com].

Frank Steinberg - GCB@SYN IDE per Great Cow BASIC, vedere http://url[sourceforge.net/projects/gcbasi/files/IDE/GCB%40Syn/GCB%40Syn.zip]

Alexy T. - SynWrite IDE utilizzato per GCB IDE, vedi http://url[uvviewsoft.com/synwrite]

Thomas Henry per gli esempi Select Case e Sine Table.

William Roth per il codice LCD e gli schemi di supporto.

Theo Loermans per le sezioni LCD rivedute e la libreria.

Chris Roper per i metodi bit a bit, inclusi nella libreria  FnEquBit, FnNotBit, FnlslBit, FnlsrBit, SetWith e 47xxx.

*Conversione dei file di documentazione di asciidoctor:*

Vedere http://url[tasciidoctor Web site] e il http://html[support forum].

== *Fondamenti del microcontollore*

*Entrate e Uscite*

La maggior parte dei pin di uso generico su un microcontrollore può funzionare in una delle due modalità: modalità di ingresso o modalità di uscita.

Quando agisce come ingresso, il pin di ingresso / uscita per uso generico verrà inserito in stato di alta impedenza. Il microcontrollore percepirà quindi il pin di ingresso / uscita per uso generale e il programma può leggere lo stato del pin di ingresso / uscita per uso generale e prendere decisioni basate su di esso.

In modalità di uscita, il microcontrollore connetterà il pin di ingresso / uscita per uso generico a entrambi Vcc (positiva), o Vss (ground), negativa. Il programma può quindi impostare lo stato del pin di ingresso / uscita generico su un livello alto o basso.

Great Cow BASIC tenterà di determinare la direzione di ciascun pin di ingresso / uscita per scopi generici e impostarlo in modo appropriato, quando possibile. Great Cow BASIC cercherà di impostare la direzione per scopo generale pin di ingresso / uscita. Tuttavia, se il pin di ingresso / uscita di uso generale viene letto e scritto nel tuo programma, quindi il pin di ingresso / uscita per uso generico deve essere configurato in ingresso o in uscita xref:a-13[Dir] appropriati.

*Esempio di comandi dir.*

    'L'indirizzo della porta è specifico del microcontrollore. Portx.x è un caso comune per i PIC e AVR
    dir portb.0 in
    dir portb.1 out
    'L'indirizzo della porta è specifico del microcontrollore.
    gpiox.x è un caso generale per alcuni PIC gpiox.x is a general case for some PICs
    dir gpio.0 in
    dir gpio.1 Out
    'Set the whole port as an output
    dir portb out
    dir gpio out
    'Set the whole port as an input
    dir portc in
    dir gpio in

 *Specifiche Microchip per operazioni di lettura / scrittura*

Per le porte specifiche e pin di ingresso / uscita per uso generico disponibili per uno specifico microcontrollore si prega di fare riferimento alla scheda tecnica.


[width="100%",options="header,footer"]
|====================
|*Port*  |*Scopo*  |*Esempi*
|PORTx mappe per i microcontrollori
pin digitali da 0 a 7. Dove x può essere
a,b,c,d,e,f or g  |Read: PORTx il registro dei dati di porta per una lettura
operation.  |uservar=PORTA
uservar=PORTA
.1
|PORTx mappe per microcontrollori
pin digitali da 0 a 7. Dove x può essere
a,b,c,d,e,f or g  |Write: PORTx il registro dei dati di porta per un'operazione di scrittura e, laddove LATx non è richiesto in quanto Great Cow BASIC implementerà LATx quando necessario. Vedere xref:a-14[Option NoLach]
per maggiori informazioni sui registri LAT e come per disabilitare questa funzione automatica.  |PORTA=255
PORTA.1=1
|====================

Per leggere un pin di ingresso / uscita generico, è necessario assicurarsi che la direzione sia corretta DIR Portx IN is set (default is IN) o al set specifico di bit di porta. Dove uservar = PORTx.n può essere utilizzato.

Esempio:

      uservar = PORTb.0
      uservar = PORTb

Per scrivere su un pin diingresso / uscita generico, è necessario assicurarsi che la direzione sia corretta DIR Portx OUT porta o un insieme specifico di bit di porta. Dove PORTx.n = uservar può essere utilizzato.

Esempio:

    PORTb.0 = uservar
    PORTb = uservar

*ATMEL specifiche per operazioni di lettura / scrittura*

Using a Mega328p as a general the following provides insights for the AVR devices. For the specific ports and general purpose input/output pins available for a specific microcontroller please refer to the datasheet.

[width="100%",options="header,footer"]
|====================
|*Porta*  |*Oerazioni di scrittura*  |*Operazioni di lettura*
|PORTD esegue il mapping ai pin digitali Mega328p (e, i microcontrollori AVR) da 0 a 7   |PORTD - Port D Data Register: operazione di scrittura (un'operazione di lettura su una porta fornirà lo stato di pull-up) |PIND - Il registro dei pin di ingresso della porta D - sola lettura

|PORTB esegue il mapping ai pin digitali da 8 a 13 di Mega328p (e, dei microcontrollori AVR). I due bit alti (6 e 7) mappano ai pin di cristallo e non sono utilizzabili |PORTB - Registro dati porta B: operazione di scrittura (un'operazione di lettura su una porta fornirà lo stato di pull-up)  |PINB - Il registro dei pin di ingresso della porta B - solo lettura

|PORTC esegue il mapping ai pin analogici Mega328p (e, i microcontrollori AVR) da 0 a 5. I pin 6 e 7 sono accessibili solo su Mega328p (e, i microcontrollori AVR) Mini|PORTC - Registro dati porta C: operazione di scrittura (un'operazione di lettura su una porta fornirà lo stato di pull-up)|PINC - Il registro dei pin di ingresso della porta C - solo lettura
|====================

*Esempi:*

    uservar = PORTb.0
    uservar = PORTb

*Settare le Porte e i bit delle Porte*

È possibile impostare una porta come mostrato sopra con una variabile, oppure, è possibile impostare con una costante o qualsiasi combinazione utilizzando gli operatori bit a bit e logici.

    #define InitStateofPort 0b11110000  PORTb = InitStateofPort 'imposterà incondizionatamente i bit 4:7

    PORTb = 0b11110000 'imposterà incondizionatamente bit 4:7

    PORTb = uservar OR 0b11110000 'uservar o bit 4:7 per controllo che bit 4:7 sono visualizzate a 1

È anche valido quanto segue: leggere un port.bit e quindi impostare port.bit con una variabile o un valore di porta. Come mostrato sotto.

    dir portb out
    portb.0 = NOT portb.0

Il codice utente sopra può causare problemi con glitches quando si verificano operazioni di lettura e scrittura. Diamo un'occhiata all'assembly generato.

        ;portb.0 = NOT portb.0
        banksel SYSTEMP1
        clrf SysTemp1
        btfsc PORTB,0
        incf SysTemp1,F
        comf SysTemp1,F
        bcf PORTB,0 btfsc
        SysTemp1,0
        bsf PORTB,0

Per risolvere eventuali glitches aggiungere #option Volatile nel codice.

        #option Volatile portb.0
        dir portb out
        portb.0 = NOT portb.0

Questa opzione fornisce il seguente assembly che risolve il problema tecnico.

        ;portb.0 = NOT
        portb.0 banksel SYSTEMP1
        clrf SysTemp1
        btfsc PORTB,0
        incf SysTemp1,F
        comf SysTemp1,F
        btfsc SysTemp1,0
        bsf PORTB,0 btfss
        SysTemp1,0
        bcf PORTB,0

Vedere anche  xref:a-15[Dir, #Option Volatile]

*Configurazione*


(Nota: questa sezione non si applica ai microcontroller Atmel AVR. I microcontrollori AVR hanno impostazioni di configurazione simili, ma sono controllate tramite "Fusibili di configurazione". Con Great Cow BASIC non è possibile impostare questi Fusibili è necessario utilizzare il software del programmatore).


Ogni PIC Microchip ha una Word CONFIG. Questa è un'area della memoria sul chip che memorizza le impostazioni che regolano il funzionamento del chip.

I seguenti aspetti del chip sono regolati dalla CONFIG Word:

* Selezione dell'oscillatore: il chip verrà eseguito da un oscillatore interno o esterno?
* Ripristino automatico: il chip dovrebbe essere ripristinato se la tensione scende oltre il limite previsto. Se rileva che sta eseguendo lo stesso blocco di codice più e più volte?
* Protezione del codice: quali aree della memoria devono essere nascoste una volta scritte?
* Utilizzo dei pin: quali pin sono disponibili per la programmazione, il reset del chip o l'emissione di segnali PWM?

Le esatte impostazioni di configurazione variano tra i chip. Per trovare un elenco di impostazioni valide, consultare la scheda tecnica per i microcontrollori che desideri utilizzare.

Questo potrebbe creare confusione quindi, Great Cow BASIC imposterà automaticamente alcuni registri di configurazione, salvo diversa indicazione:

* Programming a bassa tensione (LVP) non abilitata. Ciò consente al pin PGM (di solito B3 o B4) di essere usato come un normale pin I / O.
* Watchdog Timer (WDT) non abilitato. Il WDT ripristina il chip se esegue lo stesso pezzo di codice più e più volte - questo può causare problemi con alcune delle routine di delay più lunghe in Great Cow BASIC.
* Master Clear (MCLR) non abilitato dove possibile. Su molti chip più recenti ciò consente il pin MCLR (spesso PORTA.5 o PORTE.3) di essere utilizzato come porta di input standard. Rimuove anche la necessità di un resistore di pull-up sul pin MCLR.
* Verrà selezionata una modalità oscillatore, basata sulle seguenti regole:
* Se il microcontrollore ha un oscillatore interno e l'oscillatore interno è in grado di farlo generando la velocità specificata nella linea #chip, verrà utilizzato l'oscillatore interno.
* Se la velocità del clock supera i 4 Mhz, viene selezionato l'oscillatore HS esterno.
* Se la velocità di clock è 4 MHz o inferiore, viene selezionata la modalità oscillatore XT esterno.

Si noti che queste impostazioni possono essere facilmente sovrascritte individualmente quando necessario. Ad esempio, se è necessario il timer watchdog, aggiungendo la linea seguente.

    #config WDT = ON

Ciò abiliterà il timer del watchdog, senza influire su altre impostazioni di configurazione.

*Utilizzo della configurazione*

Una volta stabilite le necessarie opzioni di CONFIG, aggiungerle al programma è facile. Alla stessa riga prima citata o con una nuova riga "#config" e quindi elencare le opzioni desiderate separate da virgole, come in questa riga:

    #config OSC = RC, BODEN = OFF

Great Cow BASIC supporta anche questo formato sui chip della serie 10/12/16:

    #config INTOSC_OSC_NOCLKOUT, BODEN_OFF

Tuttavia, per la compatibilità verso l'alto con i chip 18F, è necessario utilizzare le impostazioni di configurazione dello stile =.

È possibile avere diverse linee #config in un programma, ad esempio una nel programma principale e uno in ciascuno di diversi file #include. Tuttavia, è necessario prestare attenzione per garantire che le impostazioni in un file non siano in conflitto con quelli in un altro.

Per ulteriore aiuto, vedere xref:a-16[#config direttive]

*Array*

*Informazioni sugli Array*

Un array è un tipo speciale di variabile, che può memorizzare più valori contemporaneamente. È essenzialmente una lista di numeri di byte in cui ognuno può essere indirizzato individualmente attraverso l'uso di un "indice". L'indice è un valore tra parentesi posizionato subito dopo il nome dell'array.

Esempi di nomi di array sono:


[width="100%",options="header,footer"]
|====================
|Indice/Array  |Significato
|Fish(10)  |Definizione di un array con 10 elementi chiamato Fish

|DataLog(2)  | il secondo array chiamato DataLog

|ButtonList(Temp)  |Un elemento nell'array ButtonList che viene selezionato in base al valore nella variabile Temp
|====================

*Defininre un array*

Utilizzare il comando DIM per definire un array.

    DIM array_title (number_of_element)

Il numero di elementi può essere il numero o una costante,**non una variabile**.

Il valore per gli elementi numerici in un array deve essere un numero o una costante. Il compilatore si alloca RAM per gli array in fase di compilazione, e quindi non è possibile utilizzare una variabile perché durante la compilazione il valore di una variabile non può essere determinato.

*Impostazione di un intero array in una sola volta.*

È possibile impostare diversi elementi di un array con una singola riga di codice. Questo breve esempio mostra come:

    Dim TestVar(10) TestVar = 1, 2, 3, 4, 5, 6, 7, 8, 9

Quando si utilizza il metodo sopra l'elemento 0 dell'array, TestVar verrà impostato sul numero di elementi dell'elenco, che in questo caso è 9. Ogni elemento dell'array verrà quindi caricato con il valore corrispondente nell'elenco: quindi nell'esempio, TestVar(1) sarà impostato su 1, TestVar (2) su 2 e così via.

*Solo l'elemento 0 è impostato sul numero di elementi nell'array quando si utilizza questo metodo di dati fino a 48 elementi. Array Length L'elemento 0 non deve essere utilizzato per ottenere la lunghezza dell'array. L'elemento 0 sarà solo coerente con la lunghezza della matrice quando l'array è impostato come mostrato sopra.*

Il metodo corretto consiste nell'utilizzare una costante per impostare la dimensione dell'array e utilizzare la costante all'interno del codice per ottenere la lunghezza dell'array.

    #Define ArraySizeConstant 500 Dim TestVar( ArraySizeConstant )  SerPrint ArraySizeConstant 'o, altro uso

*Utilizzo di array: (o matrici)*

Per utilizzare una matrice, viene specificato il suo nome, quindi l'indice. Le matrici possono essere utilizzate ovunque dove normali variabili possono essere usate.

Il limite della dimensione dell'array varia in base al tipo di chip:

.  La serie di chip 12F / 16F il limite dell'array è limitato a pochi byte per la gestione dell'array, la RAM disponibile è limitata.
.  Per l'Atmel AVR o un 18F non c'è limite oltre alla RAM libera.
. Tuttavia, Great Cow BASIC limita la dimensione di qualsiasi array a 10.000 elementi.

*Ottenere il massimo dalla memoria disponibile:*

L'utilizzo della RAM dell'array è determinato dall'architettura del tipo di chip. Ottenere il massimo dalla memoria disponibile è determinata dall'assegnazione dell'array all'interno dei bank di memoria disponibili.

Un esempio è un array di 6 o 7 byte quando ci sono solo 24 byte di RAM e i 24 byte sono divisi attraverso più bank di memoria. Supponiamo in questo esempio che 18 byte siano stati assegnati ad altre variabili e ci sono 29 byte totali disponibili. Un array di 6 byte si inserisce nello spazio libero in un bank, ma un array di 7 no.

Great Cow BASIC attualmente non può dividere un array su diversi bank, quindi se ci sono 6 byte liberi in un bank e 5 in un altro, non puoi avere una matrice di 7 byte. Questo sarebbe molto difficile da fare in modo efficiente nei 12F / 16F, come ci sarebbe una serie di registri di funzioni speciali nel mezzo della matrice quando si utilizzano i 12F o 16F. Questo vincolo non è il caso di 16F1 / 18F poiché l'indirizzamento lineare lo rende facile da estendere nei bank perché gli SFR non sono un problema (come con 12F / 16F).

*Usare le tabelle come alternativa.*

Se ci sono molti elementi nella matrice, potrebbe essere meglio usare una tabella di ricerca per archiviare i dati, e poi copiare alcuni degli elementi di dati in un array più piccolo, se necessario.

Per ulteriore aiuto vedere xref:a-17[Declaring arrays e DIM]

*Commenti*
*Informazioni sui Commenti*

L'aggiunta di commenti al tuo programma Great Cow BASIC viene eseguita con un apostrofo prima della linea di commento. Puoi anche commentare le sezioni di codice se vuoi semplicemente posizionando un apostrofo, un punto e virgola o utilizzare la dichiarazione REM all'inizio di ogni riga. L'IDE SynGCB ha una funzione per farlo automaticamente.


Avvertenza: il BASIC grafico di Great Cow utilizza il punto e virgola per contrassegnare i commenti che ha inserito automaticamente. Non legge questi commenti quando apre un file, quindi qualsiasi commento in un programma Great Cow Basic. Il programma BASIC che inizia con un punto e virgola verrà eliminato se il programma viene aperto utilizzando Great Cow BASIC Grafico.

*Esempio:*

    'Il numero di pin che lampeggiano
    #define FlashPins 2 REM È possibile creare un'intestazione utilizzando un apostrofo prima di ogni riga
    REM Questo è un ottimo modo per descrivere il tuo programma
    REM Puoi anche usarlo per descrivere le connessioni hardware.
    'È possibile inserire commenti sopra il comando o sulla stessa riga Dir PORTB Out
    ' Inizializza tutta la PORTB come uscita  ' Main loop
    do  PORTB = 0
    ' tutti i pin off Wait 1 S
    ' pausa 1 secondo PORTB = 0xFF
    ' tutti i pin on  Wait 1 s
    ' pausa 1 secondo
    Loop

*Condizioni*

*Informazioni sulle  Condizioni*

In Great Cow BASIC (e nella maggior parte degli altri linguaggi di programmazione) una condizione, è un'affermazione che può essere o vero o falso. Le condizioni sono usate quando il programma deve prendere una decisione. Una condizione è generalmente data come valore o variabile, un operatore relativo (come = o >), e un altro valore o variabile. Diverse condizioni possono essere combinate per formare una condizione attraverso l'uso della logica operatori come AND e OR.

Great Cow BASIC supporta questi operatori relativi:


[width="100%",options="header,footer"]
|====================
|Simbolo  | Significato
|  =  | Uguale a
|  <>   |Diverso da
|  < |Minore di
|  > |Maggiore di
|  <=  |Minore o ugale a
|  >= |Maggior o uguale a
|====================

Inoltre, questi operatori logici possono essere utilizzati per combinare più condizioni in una sola:


[width="100%",options="header,footer"]
|====================
|Nome  |Abbreviazione   | Se la condizione è Vera
|AND  |&  |entrambe le condizioni sono vere

|OR  |   |almeno una condizione è vera

|XOR  | # |ola condizione è vera

|NOT  | ! | la condizione non è vera
|====================





















































